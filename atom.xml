<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>做梦诗人的博客</title>
  <icon>https://www.gravatar.com/avatar/83682c37b4f0631369445a297d50bbe5</icon>
  <subtitle>仰天大笑出门去</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nkoo.top/"/>
  <updated>2023-04-09T00:19:35.233Z</updated>
  <id>https://nkoo.top/</id>
  
  <author>
    <name>Dreamingpoet</name>
    <email>Dreamingpoet@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE4PythonHelper</title>
    <link href="https://nkoo.top/2023/04/06/UnrealEngineOBSClient/"/>
    <id>https://nkoo.top/2023/04/06/UnrealEngineOBSClient/</id>
    <published>2023-04-06T15:20:10.000Z</published>
    <updated>2023-04-09T00:19:35.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UnrealEngineOBSClient"><a href="#UnrealEngineOBSClient" class="headerlink" title="UnrealEngineOBSClient"></a>UnrealEngineOBSClient</h1><p>This plugin provides a convenient way to access object storage services that comply with the Amazon S3 protocol.</p><p><img src="/images/obs1-1.webp" alt="ph01"></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol><li><p>Support Path and Virtual Hosted requests style.</p></li><li><p>Blueprintnode based.</p></li><li><p>With multilingual debug UMG.</p></li><li><p>Encapsulated and easier-to-use file download and upload nodes.</p></li><li><p>Fully use UE’s C++ API, theoretically supporting multiple platforms.</p><a id="more"></a> <h2 id="Startup"><a href="#Startup" class="headerlink" title="Startup"></a>Startup</h2></li><li><p>Find OBSClinet Content in Content Broswer -&gt; Plugins.</p></li><li><p>Open Example_Map and play this level.</p></li><li><p>Select a test server and Click buttons to test, the request respones will show on the right.</p></li><li><p>Open UMG_Example to see the detail usage of the blueprint node.</p></li><li><p>Things about object storage API:<br> AliCoud OSS: <a href="https://help.aliyun.com/document_detail/31947.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/31947.html</a></p><p> amazon s3: <a href="https://docs.aws.amazon.com/cli/latest/reference/s3api/" target="_blank" rel="noopener">https://docs.aws.amazon.com/cli/latest/reference/s3api/</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UnrealEngineOBSClient&quot;&gt;&lt;a href=&quot;#UnrealEngineOBSClient&quot; class=&quot;headerlink&quot; title=&quot;UnrealEngineOBSClient&quot;&gt;&lt;/a&gt;UnrealEngineOBSClient&lt;/h1&gt;&lt;p&gt;This plugin provides a convenient way to access object storage services that comply with the Amazon S3 protocol.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/obs1-1.webp&quot; alt=&quot;ph01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Features&quot;&gt;&lt;a href=&quot;#Features&quot; class=&quot;headerlink&quot; title=&quot;Features&quot;&gt;&lt;/a&gt;Features&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Support Path and Virtual Hosted requests style.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Blueprintnode based.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;With multilingual debug UMG.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Encapsulated and easier-to-use file download and upload nodes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fully use UE’s C++ API, theoretically supporting multiple platforms.&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="obs" scheme="https://nkoo.top/tags/obs/"/>
    
      <category term="oss" scheme="https://nkoo.top/tags/oss/"/>
    
      <category term="tools" scheme="https://nkoo.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK入门避坑指南</title>
    <link href="https://nkoo.top/2022/11/29/Android-NDK-Startup/"/>
    <id>https://nkoo.top/2022/11/29/Android-NDK-Startup/</id>
    <published>2022-11-28T19:00:12.000Z</published>
    <updated>2023-04-08T23:54:37.289Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>最近在尝试开发一体机VR(Android系统)，但是苦于第三方库插件一直无法打包成功，因此开始学习之路。<br>本文收藏自 <a href="https://www.jianshu.com/p/fe54d70a260e" target="_blank" rel="noopener">Android NDK入门避坑指南</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文基于自己所学到的NDk的知识和一些在网上查到的资料</p><p>因为学习NDK的时间不是很长，学到的内容难免有所错漏，希望有问题的可以明确的指出来，我会积极采纳</p><p>本文会竭尽可能的将我现在所学到的关于NDK的知识清晰的表达出来，本文主要以<strong>NDK的基本概念，NDK的组成部分，NDK的注意事项三个部分组成</strong></p><p>实践部分因为本篇文章已经6000多字了，为了不让文章过长，将会在后面的博客中</p><h1 id="一-NDK的基本概念"><a href="#一-NDK的基本概念" class="headerlink" title="一. NDK的基本概念"></a>一. NDK的基本概念</h1><p>在学习NDK之前，我首先得知道什么是NDK，NDK可以干些什么，使用NDK的好处有哪些，知道了这些，我们才可以更好的学习NDK</p><h3 id="1-什么是NDK"><a href="#1-什么是NDK" class="headerlink" title="1. 什么是NDK"></a>1. 什么是NDK</h3><p>NDK即<code>Native Development Kit</code>,是Android中的一个开发工具包,为我们提供native开发的环境</p><p>NDK是我们实现Java与Native进行交互的一个<strong>手段</strong></p><a id="more"></a><h3 id="2-NDK可以干什么"><a href="#2-NDK可以干什么" class="headerlink" title="2. NDK可以干什么"></a>2. NDK可以干什么</h3><p>可以快速开发<code>C</code>、 <code>C++</code>的动态库，并自动将<code>so</code>和应用一起打包成 <code>APK</code></p><p>即可通过 <code>NDK</code>使 <code>Java</code>与native代码（如 C、C++）交互</p><p>NDK在现在很多热门的技术中都有使用，如：Android 音视频开发，热更新，OpenCV，等等</p><h3 id="3-我们为什么要使用NDK"><a href="#3-我们为什么要使用NDK" class="headerlink" title="3. 我们为什么要使用NDK"></a>3. 我们为什么要使用NDK</h3><ol><li><p>允许程序开发人员直接使用 C/C++ 源代码，极大的提高了 Android 应用程序开发的灵活性</p></li><li><p>跨平台应用移植、使用第三方库。如：许多第三方库只有 C/C++ 语言的版本，而 Android 应用程序需要使用现有的第三方库，如 FFmpeg、OpenCV等，则必须使用NDK</p></li><li><p>采用C++代码来处理性能要求高的操作，提高了Android APP的性能</p></li><li><p>安全性高</p></li></ol><h3 id="4-NDK与SDK的关系"><a href="#4-NDK与SDK的关系" class="headerlink" title="4. NDK与SDK的关系"></a>4. NDK与SDK的关系</h3><p>在Android开发中，最常用的是SDK，那么SDK与NDK的关系是什么呢？</p><p>在SDK中，我们使用Java来进行开发，而在NDK中，我们使用C++来进行开发</p><p>SDK支持了Android开发中的大部分操作，如UI展示，用户与手机的交互等，主要是支持了Android APP开发的<strong>基础功能</strong></p><p>NDK支持了一些复杂的，比较高级的操作，如音视频的解析，大量数据的运算，提高Android游戏的运行速度等，主要是Android APP的一些<strong>高级功能</strong></p><p>所以<strong>NDK与SDK是并列关系，NDK是SDK的有效补充</strong></p><p><img src="/images/16847684-01f5fcda5a1591f0.webp" alt="image"></p><h1 id="二-NDK的组成部分"><a href="#二-NDK的组成部分" class="headerlink" title="二. NDK的组成部分"></a>二. NDK的组成部分</h1><p>现在我们知道了NDK是什么，NDK的作业，优点了，那我们该开始正式学习NDK了，但是<code>工欲善其事，必先利其器</code>，在使用NDK这个工具以前，我们必须先好好地了解NDK</p><p>所以本部分将分析NDK中的一些组成及他们的作用</p><p>本部分将讲述NDK中的<strong><code>JNI</code> ，二进制文件（.so 和 .a）, ABI ，本机编译工具，交叉编译工具等等</strong></p><h2 id="1-JNI"><a href="#1-JNI" class="headerlink" title="1. JNI"></a>1. JNI</h2><ul><li><p>定义</p><p>JNI 即<code>Java Native Interface</code>,即Javanative接口</p><p>JNI是一种编程框架，使得 Java 虚拟机中的 Java 程序可以调用本地应用 / 或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序</p><p>上文中，NDK也是支持Java代码与Native代码的交互，那他们之间有什么区别呢？</p><p>实际上，JNI是一个编程框架，是一个抽象的东西，NDK是一个工具包，是一个</p><p>所以：<strong>NDK是实现JNI的一个手段</strong></p></li><li><p>作用 <strong>支持Java代码与native代码进行交互</strong>，即Java代码调用native代码 或者 native代码调用Java代码 native代码主要指<code>C</code>和<code>C++</code></p></li><li><p>使用JNI的原因</p><p>有些事情 Java 无法处理时，JNI 允许程序员用其他编程语言来解决，例如，Java 标准库不支持的平台相关功能或者程序库。也用于改造已存在的用其它语言写的程序，供 Java 程序调用</p></li><li><p>使用JNI的步骤</p><ol><li><p>使用<code>Native</code>关键字定义<code>Java</code>方法（即需要调用的native方法）</p></li><li><p>使用<code>javac</code>编译上述 <code>Java</code>源文件 （即 <code>.java文件</code>）最终得到 <code>.class</code>文件</p></li><li><p>通过 <code>javah</code> 命令编译<code>.class</code>文件,最终导出<code>JNI</code>的头文件（<code>.h</code>文件）</p></li><li><p>使用 <code>Java</code>需要交互的native代码，以及实现在 <code>Java</code>中声明的<code>Native</code>方法</p></li><li><p>编译<code>.so</code>库文件</p></li><li><p>通过<code>Java</code>命令执行 <code>Java</code>程序，最终实现<code>Java</code>调用<code>native</code>代码编译生成的.so文件</p></li></ol><p>实际上2345步骤的目的就是<strong>生成.so 文件</strong></p><p>所以上面的步骤可以归纳为三步：</p><ol><li><p><strong>声明Native方法</strong></p></li><li><p><strong>实现Native方法，经过一系列操作，最终生成.so 文件</strong></p></li><li><p><strong>加载.so文件，调用Native方法</strong></p><p>这里只简单介绍JNI的步骤，具体实现的例子在后面的博客中</p></li></ol></li></ul><h2 id="2-so-和-a-文件"><a href="#2-so-和-a-文件" class="headerlink" title="2 .so 和 .a 文件"></a>2 .so 和 .a 文件</h2><p>上面我们已经说到，JNI 支持了<code>Java</code>代码和<code>native</code>代码的互相调用</p><p>但是JNI是直接调用Java代码和native代码吗？</p><blockquote><p>实际上，JNI是调用<code>java</code>代码和<code>native</code>代码编译后的<code>.so</code>和<code>.a</code>文件来实现了Java代码和native代码的交互</p></blockquote><p>那么<code>.so</code>和<code>.a</code>文件是什么呢？下面我列出了.so和.a文件的一些定义</p><ul><li><p>动态链接库 (.so 后缀):</p><p><strong>运行</strong>时才动态加载这个库;</p><p>动态链接库，也叫共享库，因为在 NDK 中用 <code>shared</code> 来表示是动态库</p><p>现在热门的插件化，热更新以及缩小APK大小等技术都使用了 <code>.so</code> 文件</p></li><li><p>静态链接库 (.a 后缀)</p><p>在<strong>编译</strong>的时候, 就把静态库打包进 APK 中</p><ul><li><p>缺点 : 使用静态库编译, 编译的时间比较长，同时也使得APK比较大</p></li><li><p>优点 : 只导出一个库, 可以隐藏自己调用的库;</p></li></ul></li><li><p><code>.so</code>和<code>.a</code>本质上都是<strong>二进制文件</strong>，下文我将用二进制文件统称这两个文件</p></li><li><p><strong>每个CPU系统只能使用相对应的二进制文件</strong>，即他们不像<code>jar</code>包一样，所有的CPU系统都可以使用一个jar包，.so 和 .a 每个系统必须使用自己的，不能使用别的，如 <code>armeabi</code>的<code>.so</code>文件，不能被应用到<code>x86</code>中</p></li></ul><h2 id="3-CPU架构"><a href="#3-CPU架构" class="headerlink" title="3. CPU架构"></a>3. CPU架构</h2><p>Android 平台，其支持的设备型号繁多，单单就设备的核心 CPU 而言，都有三大类：<strong>ARM、x86 和 MIPS</strong></p><p>**ARM主要应用于手机中，x86主要应用于PC中</p><p>Android中使用<code>x86</code>主要是因为：<strong>因为PC是x86架构，所以PC上的手机模拟器需要x86的二进制文件</strong></p><p>而在<strong>NDK r17</strong>中，有了大的变化：</p><p><strong>在NDK r17 以后，NDK 不在支持<code>32位和64位 MIPS</code> 和<code>ARM v5(armeabi)</code></strong></p><p>所以现在NDK只支持<code>ARM</code>和<code>x86</code>，而<code>ARM</code>和<code>x86</code>又各自分为两种：</p><p>简单的来说:<strong>ARM 和 x86 各分为 32位和64位两种，所以现在NDK一共支持4种CPU架构</strong></p><p>即：ARM 32位 ，ARM 64位 ， x86 32位 ，x86 64位</p><h2 id="4-ABI"><a href="#4-ABI" class="headerlink" title="4. ABI"></a>4. ABI</h2><p>ABI ： Application Binary Interface</p><p>我们上面说了，每个系统只能使用相对应的二进制文件，</p><p><strong>不同的 Android 设备使用不同的 CPU，而不同的 CPU 支持不同的指令集。CPU 与指令集的每种组合都有专属的应用二进制接口 (ABI)</strong></p><p>简而言之：而<strong>ABI定义了二进制文件是怎么运行在对应的CPU中的</strong></p><p>上文中我们大致了解了Android中常用的CPU架构，而且我们知道，ABI 定义了二进制文件时怎么在CPU中运行的，那么我们可以知道，<strong>每一个CPU架构必定有一个相对应的ABI</strong></p><p>上面我们已经知道了有四种，那么ABI也有四种，他们分别是：<strong>armeabi-v7a，armeabi-v8a，x86，x86_64</strong></p><table><thead><tr><th>ABI</th><th>对应的CPU架构</th><th>应用</th></tr></thead><tbody><tr><td>armeabi-v7a</td><td>ARM 32位</td><td>手机</td></tr><tr><td>armeabi-v8a</td><td>ARM 64位</td><td>手机</td></tr><tr><td>X86</td><td>X86 32位</td><td>PC</td></tr><tr><td>X86_64</td><td>X86 64位</td><td>PC</td></tr></tbody></table><p>CPU架构中<strong>64位的CPU架构兼容32位的ABI和64位的ABI，32位的CPU架构只支持32位的ABI</strong></p><blockquote><p>armeabi-v7a设备只兼容armeabi-v7a</p><p>armeabi-v8a设备兼容armeabi-v7a，armeabi-v7a</p><p>X86设备只兼容X86_64</p><p>X86_64兼容X86，X86_64</p></blockquote><p>NDK编译实际上<strong>默认编译出所有系统的文件</strong></p><p>但是有时我们只需要使用指定的系统，我们就可以指定编译什么系统，减少二进制文件，避免我们不会使用到的二进制文件被打包到apk中，如我们在PC上使用模拟器来执行APP时，我们需要x86，但是我们APP最终是要在手机上运行的，这样我们只需要ARM的就行了，我们就可以在最终打包APK时，去掉x86的</p><p>我们可以使用下面的代码来指定我们要编译什么CPU架构的二进制文件</p><p> <code class="gradle  language-gradle">//在project的build.gradle中<br>android {<br>    defaultConfig {<br>        ndk {<br>            abiFilters ‘arm64-v8a’, ‘x86_64’<br>        }<br>    }</code> </p><h2 id="5-编译工具"><a href="#5-编译工具" class="headerlink" title="5. 编译工具"></a>5. 编译工具</h2><h3 id="5-1-本机编译工具"><a href="#5-1-本机编译工具" class="headerlink" title="5.1 本机编译工具"></a>5.1 本机编译工具</h3><p>我们已经知道，每个系统只能使用自己系统的二进制文件，本机编译工具正是<strong>编译出本机系统可以使用的二进制文件</strong></p><p>在Android中可以使用的<strong>本机编译工具有两种：<code>ndk-build</code>和 <code>cmake</code></strong></p><ol><li><p>cmake</p><p>我们已经知道，每个系统只能使用自己的二进制文件</p><p>那么我们在开发中，就需要编译出对应的二进制文件，而且如果我们的软件想要跨平台，那么我们就得保证在每一个平台上都可以编译</p><p>即：如果我们的软件想在Mac OS 和 Windows上运行，那么我们的软件在Mac OS上运行时，要生成可以在Mac OS上运行的二进制文件，在Windows上运行，要生成Windows上可以运行的二进制文件</p><p>这样的话，那我们得为每一个平台都要编写一次<code>MakeFile</code>文件，这将是一个很无趣，很令人抓狂的操作</p></li></ol><p>而CMake就是针对上述问题的一个工具</p><p>它<strong>允许开发者编写一种与平台无关的CMakeList.txt文件来定制整个编译流程，然后再根据目标用户的平台逐步生成所需的本地化Makefile和工程文件</strong>，如Unix的Makefile或Windows的Visual Studio工程</p><p>从而达到“<strong>只写一次，到处运行</strong>”</p><p>即：我们只要写一个 <code>cmakeLists.txt</code>文件，那么就可以在所有平台中编译出对应的二进制文件</p><p>这样的话，当运行在Windows上时，自动生成Windows的，在Mac OS行运行，自动生成MacOS的，但是，我们只需要写一个<code>cmakeList.txt</code>文件即可！！！</p><p>使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile（<code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面）。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li><li>使用 <code>make</code> 命令进行编译。</li></ol><p>当然，在Android开发过程中，我们不需要执行上面的流程，因为在 Android studio 当中已经为我们集成了，我们<strong>只需要编写<code>cmakeLists.txt</code>文件，剩下的就交给 Android studio 就行了</strong></p><p>在Android开发过程中，使用cmake只需要两个文件，<code>xxx.cpp</code> 和<code>CMakeLists.txt</code></p><ul><li>cmakeLists.txt 就如上面所述，定义整个的编译流程</li><li>xxx.cpp 则是要被编译的 C++ 文件</li></ul><p>具体的实现方式我会在下面列出</p><ol><li>ndk-build</li></ol><p>ndk-build是一个和cmake功能差不多的工具，他们都减少了我们定制编译流程的操作</p><p>但是ndk-build是以前常使用的工具，我们现在常用cmake，ndk-build的操作要比cmake复杂一些</p><p><code>ndk-build</code>本质上是一个脚本,它的位置就在NDK目录的最上层，即在<code>&lt; NDK &gt;/ndk-build</code>路径下</p><p>因为是一个脚本，所以下面的命令等同于<code>ndk-build</code></p><p> <code class="shell  language-shell"># $GNUMAKE 指 GNU Make 3.81 或更高版本</code></p><h1 id="则指向-NDK-安装目录"><a href="#则指向-NDK-安装目录" class="headerlink" title=" 则指向 NDK 安装目录"></a><ndk> 则指向 NDK 安装目录</ndk></h1><p>$GNUMAKE -f <ndk>/build/core/build-local.mk <parameters></parameters></ndk></p><p>#等同于<br>ndk-build </p><p><strong>使用ndk-build我们需要两个文件: Android.mk 和 Application.mk</strong></p><ol><li><p>Android.mk</p><p>Google的官方文档对Android.mk的定义如下</p><blockquote><p><code>Android.mk</code> 文件位于项目 <code>jni/</code> 目录的子目录中，用于向构建系统描述源文件和共享库。它实际上是构建系统解析一次或多次的微小 GNU makefile 片段。<code>Android.mk</code> 文件用于定义 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Fndk%2Fguides%2Fapplication_mk%3Fhl%3Dzh-cn" target="_blank" rel="noopener"><code>Application.mk</code></a>、构建系统和环境变量所未定义的项目级设置。它还可替换特定模块的项目级设置。</p><p><code>Android.mk</code> 的语法支持将源文件分组为“模块”。模块是静态库、共享库或独立的可执行文件。您可在每个 <code>Android.mk</code> 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。构建系统只将共享库放入您的应用软件包。此外，静态库可生成共享库。</p><p>除了封装库之外，构建系统还可为您处理各种其他事项。例如，您无需在 <code>Android.mk</code> 文件中列出头文件或生成的文件之间的显式依赖关系。NDK 构建系统会自动计算这些关系。因此，您应该能够享受到未来 NDK 版本中支持的新工具链/平台功能带来的益处，而无需处理 <code>Android.mk</code> 文件。</p><p>此文件的语法与随整个 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsource.android.com%2F%3Fhl%3Dzh-cn" target="_blank" rel="noopener">Android 开源项目</a>分发的 <code>Android.mk</code> 文件中使用的语法非常接近。虽然使用这些语法的构建系统实现并不相同，但通过有意将语法设计得相似，可使应用开发者更轻松地将源代码重复用于外部库。</p></blockquote></li></ol><p>这个的定义很长，简单的来说，Android.mk的作用如下：</p><ol><li>描述了源文件的位置和名字</li><li>描述了生成什么文件，如共享库，静态库等</li><li>自动处理构建中的一些事项，如文件之间的依赖关系</li><li>语法设置得与Android开源项目相似，使得我们可以轻易的将源代码重复使用</li></ol><p>Android.mk的一些常用的变量如下：</p><p>  <code class="shell  language-shell"># 这个是源文件的路径，call my-dir表示了返回当前Android.mk所在的目录<br>  LOCAL_PATH := $(call my-dir)</code></p><h3 id="清除许多-LOCAL-XXX-变量"><a href="#清除许多-LOCAL-XXX-变量" class="headerlink" title="清除许多 LOCAL_XXX 变量"></a>清除许多 LOCAL_XXX 变量</h3><h3 id="注意：不会清除-LOCAL-PATH"><a href="#注意：不会清除-LOCAL-PATH" class="headerlink" title="注意：不会清除 LOCAL_PATH"></a>注意：不会清除 LOCAL_PATH</h3><p>  include $(CLEAR_VARS)</p><h3 id="LOCAL-MODULE-变量存储要构建的模块的名称"><a href="#LOCAL-MODULE-变量存储要构建的模块的名称" class="headerlink" title="LOCAL_MODULE 变量存储要构建的模块的名称"></a>LOCAL_MODULE 变量存储要构建的模块的名称</h3><h3 id="这里最终会生成叫-libhello-jni-so-的文件"><a href="#这里最终会生成叫-libhello-jni-so-的文件" class="headerlink" title="这里最终会生成叫 libhello-jni.so 的文件"></a>这里最终会生成叫 libhello-jni.so 的文件</h3><p>  LOCAL_MODULE := hello-jni</p><h3 id="源文件名字"><a href="#源文件名字" class="headerlink" title="源文件名字"></a>源文件名字</h3><h3 id="可以有多个源文件，使用空格隔开"><a href="#可以有多个源文件，使用空格隔开" class="headerlink" title="可以有多个源文件，使用空格隔开"></a>可以有多个源文件，使用空格隔开</h3><p>  LOCAL_SRC_FILES := hello-jni.c</p><h3 id="指定编译出什么二进制文件"><a href="#指定编译出什么二进制文件" class="headerlink" title="指定编译出什么二进制文件"></a>指定编译出什么二进制文件</h3><h3 id="这里编译出共享库，即-so文件"><a href="#这里编译出共享库，即-so文件" class="headerlink" title="这里编译出共享库，即:.so文件"></a>这里编译出共享库，即:.so文件</h3><h3 id="编译出静态库可以使用：-BUILD-STATIC-LIBRARY"><a href="#编译出静态库可以使用：-BUILD-STATIC-LIBRARY" class="headerlink" title="编译出静态库可以使用： BUILD_STATIC_LIBRARY"></a>编译出静态库可以使用： BUILD_STATIC_LIBRARY</h3><p>  include $(BUILD_SHARED_LIBRARY) </p><ol><li><p>Application.mk</p><p><code>Application.mk</code> 指定 ndk-build 的项目范围设置。默认情况下，它位于应用项目目录中的 <code>jni/Application.mk</code> 下</p><p>简单的来说，Application.mk的功能主要是：主要是<strong>描述了Android Native开发需要的模组（module）</strong></p><p>一些常用的变量如下：</p><p><code class="shell  language-shell"># 定义生成的二进制文件要生成的CPU架构</code></p><h1 id="这里指定生成-arm64-v8a-可以用的二进制文件"><a href="#这里指定生成-arm64-v8a-可以用的二进制文件" class="headerlink" title="这里指定生成 arm64-v8a 可以用的二进制文件"></a>这里指定生成 arm64-v8a 可以用的二进制文件</h1><p>APP_ABI := arm64-v8a</p></li></ol><h1 id="定义可以使用该二进制文件的Android版本"><a href="#定义可以使用该二进制文件的Android版本" class="headerlink" title="定义可以使用该二进制文件的Android版本"></a>定义可以使用该二进制文件的Android版本</h1><p>APP_PLATFORM := android-21</p><h1 id="默认情况下，ndk-build-假定-Android-mk-文件位于项目根目录的相对路径-jni-Android-mk-中。"><a href="#默认情况下，ndk-build-假定-Android-mk-文件位于项目根目录的相对路径-jni-Android-mk-中。" class="headerlink" title="默认情况下，ndk-build 假定 Android.mk 文件位于项目根目录的相对路径 jni/Android.mk 中。"></a>默认情况下，ndk-build 假定 Android.mk 文件位于项目根目录的相对路径 jni/Android.mk 中。</h1><h1 id="要从其他位置加载-Android-mk-文件，将-APP-BUILD-SCRIPT-设置为-Android-mk-文件的绝对路径。"><a href="#要从其他位置加载-Android-mk-文件，将-APP-BUILD-SCRIPT-设置为-Android-mk-文件的绝对路径。" class="headerlink" title="要从其他位置加载 Android.mk 文件，将 APP_BUILD_SCRIPT 设置为 Android.mk 文件的绝对路径。"></a>要从其他位置加载 Android.mk 文件，将 APP_BUILD_SCRIPT 设置为 Android.mk 文件的绝对路径。</h1><p>APP_BUILD_SCRIPT </p><p>​</p><ol><li><p>cmake 和 ndk-build 都可以在Android开发中使用，但是<strong>现在默认使用的是cmake，以前常用的是ndk-build</strong></p><p><code>ndk-build</code> 的实现过程比<code>cmake</code>复杂的多,所以现在推荐使用cmake</p><p>但是因为以前的项目常用 <code>ndk-build</code> ，如果我们要参与以前 NDK项目 的开发，那么 <code>ndk-build</code>也是需要了解的</p><p>所以，如果<strong>要新建一个项目，那么推荐使用<code>cmake</code>,要参与以前老项目的开发，<code>ndk-build</code>也不可落下</strong></p></li></ol><h3 id="5-2交叉编译工具"><a href="#5-2交叉编译工具" class="headerlink" title="5.2交叉编译工具"></a>5.2交叉编译工具</h3><p>与本机编译对应的，有时我们需要编译出其他系统的二进制文件，如我们在PC上写Android文件，那么我们PC中就需要编译出Android中可以运行的二进制文件</p><p>交叉编译工具，又叫<strong>交叉编译链( <code>toolchain</code>)</strong></p><p>交叉编译链（编译器、链接器等）来<strong>生成可以在其他系统中运行的二进制文件</strong></p><p><strong>在NDK中，交叉编译工具主要有两种：<code>clang</code>和<code>gcc</code></strong></p><h1 id="三-NDK中一些值得注意的事情"><a href="#三-NDK中一些值得注意的事情" class="headerlink" title="三. NDK中一些值得注意的事情"></a>三. NDK中一些值得注意的事情</h1><h2 id="1-NDK版本变化的问题"><a href="#1-NDK版本变化的问题" class="headerlink" title="1. NDK版本变化的问题"></a>1. NDK版本变化的问题</h2><h3 id="1-1-NDK中编译工具的变化"><a href="#1-1-NDK中编译工具的变化" class="headerlink" title="1.1 NDK中编译工具的变化"></a>1.1 NDK中编译工具的变化</h3><p>cmake 和 ndk-build 都可以在Android开发中使用，但是<strong>现在默认使用的是cmake，以前常用的是ndk-build</strong></p><p><code>ndk-build</code> 的实现过程比<code>cmake</code>复杂的多,所以现在推荐使用cmake</p><p>但是因为以前的项目常用 <code>ndk-build</code> ，如果我们要参与以前 NDK项目 的开发，那么 <code>ndk-build</code>也是需要了解的</p><p>所以，如果<strong>要新建一个项目，那么推荐使用<code>cmake</code>,要参与以前老项目的开发，<code>ndk-build</code>也不可落下</strong></p><h3 id="1-2-NDK中交叉编译的工具的变化"><a href="#1-2-NDK中交叉编译的工具的变化" class="headerlink" title="1.2 NDK中交叉编译的工具的变化"></a>1.2 NDK中交叉编译的工具的变化</h3><p><strong>在ndk r17c 以后默认使用的变成了clang，而不是gcc</strong></p><h4 id="库文件和头文件的变化"><a href="#库文件和头文件的变化" class="headerlink" title="库文件和头文件的变化"></a>库文件和头文件的变化</h4><p>在r17c以前，头文件，库文件以及gcc的路径如下：</p><blockquote><p><code class="shell  language-shell"># 库文件路径<br>android-ndk-r17c/platforms/android-21/arch-arm/usr/lib</code></p><h1 id="头文件路径"><a href="#头文件路径" class="headerlink" title="头文件路径"></a>头文件路径</h1><p>android-ndk-r17c/sysroot/usr/include</p><p>#gcc的路径<br>android-ndk-r17c/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin</p></blockquote><p>而在r17以后，如 r20 中，头文件和库文件统一放到了<strong><code>sysroot</code></strong>中：</p><p>  <code class="shell  language-shell">#头文件<br> toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include</code></p><p> #库文件<br> toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/lib </p><p>我们可以发现 r20 把头文件和库文件弄到了一起</p><p>但是，r20 中也没有把 r17 中的库文件删除，即我们也可以在下面的路径中找到头文件</p><p> <code class="shell  language-shell">android-ndk-r17c/platforms/android-21/arch-arm/usr/lib</code> </p><h4 id="交叉编译工具位置的变化"><a href="#交叉编译工具位置的变化" class="headerlink" title="交叉编译工具位置的变化"></a>交叉编译工具位置的变化</h4><p>在 <strong>NDK r19以前</strong>的 <code>ndk</code> 内置了一个可以自动生成<code>交叉编译工具(toolchain)</code> 的<code>.py</code>文件，放在</p><p>ndk路径下面的<strong><code>build/tool/make_standalone_toolchain.py</code></strong></p><p>要生成toolchain，使用下面的命令</p><blockquote><p>$NDK_HOME/build/tools/make_standalone_toolchain.py –arch arm –api 21 –install-dir /Users/fczhao/Desktop</p><p>后面的几个都是必要的</p><p>–arch 指定了生成的toolchain要在哪个CPU框架中使用</p><p>–api 指定了生成的toolchain要在哪个Android API 中使用</p><p>–install-dir 生成的toolchain的路径</p></blockquote><p>如果使用的是<code>NDK r19以前的</code>，可以参考下面的这个文章</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Fndk%2Fguides%2Fstandalone_toolchain%3Fhl%3Dzh-cn" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/standalone_toolchain?hl=zh-cn</a></p><p>但是<strong><code>NDK r19</code>以后</strong>的NDK已经内置了这些文件，如果运行上面的命令，会出现这样的日志</p><p> <code class="shell  language-shell">WARNING:<strong>main</strong>:make_standalone_toolchain.py is no longer necessary. The</code></p><p>#$NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin 这个路径已经有了我们要生成的文件<br>$NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin directory contains target-specific scripts that perform<br>the same task. For example, instead of:</p><pre><code>$ python $NDK/build/tools/make_standalone_toolchain.py \    --arch arm --api 21 --install-dir toolchain$ toolchain/bin/clang++ src.cpp</code></pre><p>Instead use:</p><pre><code>$ $NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang++ src.cpp</code></pre><p>Installation directory already exists. Use –force. </p><p>然后让我们去上面输出的路径中看看，就可以看到NDK的确已经提供了很多的<strong>clang</strong>,这里我只截取了一部分</p><p> <img src="//upload-images.jianshu.io/upload_images/16847684-5a115c705121ccd3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p><p> image-20200601130753041</p><h3 id="1-3-NDK支持的CPU架构的变化"><a href="#1-3-NDK支持的CPU架构的变化" class="headerlink" title="1.3 NDK支持的CPU架构的变化"></a>1.3 NDK支持的CPU架构的变化</h3><p>上文中我们在ABI已经提到了CPU架构相关的东西，但是为了增加印象，这里稍微重新提一下</p><p>Android 平台核心 CPU有三大类：<strong>ARM、x86 和 MIPS</strong></p><p>而在<strong>NDK r17</strong>中，有了大的变化：</p><p><strong>在NDK r17 以后，NDK 不在支持<code>32位和64位 MIPS</code> 和<code>ARM v5(armeabi)</code></strong></p><p>所以现在NDK中只支持armeabi-v7a，armeabi-v8a，x86,x86_64四类</p><h2 id="2-NDK-的系统是否适用的问题"><a href="#2-NDK-的系统是否适用的问题" class="headerlink" title="2. NDK 的系统是否适用的问题"></a>2. NDK 的系统是否适用的问题</h2><p>值得注意的是：<br>在下载NDK时，不像我们下载JDK一样</p><blockquote><p>当下载同一版本的JDK时，所有的电脑（不论是macOS，Windows还是Linus）下载的都是一样</p><p>而当我们下载相同版本的NDK时，会发现Google提供了适合于不同系统的NDK，如下图</p><p> <img src="/images/16847684-f06815c59e5f8fed.webp" alt></p><p> NDK截图</p><p>之所以提供针对每个系统的NDK的原因是是</p><p>因为Java良好的跨平台性，所以所有的系统都可以使用同一个JDK</p><p>而NDK调用的是C++代码，C++没有这么好的跨平台性，从而我们必须为每一个平台配置适合于它的NDK</p></blockquote><p>所以在我们看别人的NDK博客时，一定要<strong>注意是否与自己使用的NDK是一个系统的，一个版本</strong>的，否则一定会出现问题</p><h2 id="3-NDK-中Java与native代码的交互"><a href="#3-NDK-中Java与native代码的交互" class="headerlink" title="3. NDK 中Java与native代码的交互"></a>3. NDK 中Java与native代码的交互</h2><p>Java 和 c/c++ 有两种交互方式:</p><ul><li><p>Java调用 native 代码</p></li><li><p>native 代码调用 Java 代码</p></li></ul><p>也就是说，交互是Java与C++之间的互相调用</p><p>但是在NDK中他们实际上的顺序是：</p><p><strong>Java调用C++代码，然后C++调用Java代码返回C++执行后的数据</strong>，如图所示</p><p> <img src="//upload-images.jianshu.io/upload_images/16847684-29df9ae030e17745.png?imageMogr2/auto-orient/strip|imageView2/2/w/610/format/webp" alt></p><p> image-20200528190701126</p><p>从图中可以看到，我们使用NDK的目的实际上是：</p><p>​ <strong>Java调用C++，让C++处理一些复杂的操作，然后把处理后的数据返回到Java中</strong></p><p>​ 而我们为什么不直接使用Java来进行处理，而是绕了一圈，通过 <code>Java -&gt; C++ -&gt; Java</code>的方式来实现，其中的原因是：</p><p>​ C++速度比Java快</p><p>​ 举个简单的例子，在ACM或者LeetCode中，C++代码运行的超时时间是 1s，而Java的是 2s</p><p>​ 所以对于一些计算量很大的操作，如音视频的渲染等我们采用C++可以有效的减少计算时间和内存占用，减少手机发热和耗电量等</p><hr><p>现在我们已经大致了解了一些NDK的东西了，后面的博客我将分别分析cmake，ndk-build，clang，gcc的具体实现过程</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;最近在尝试开发一体机VR(Android系统)，但是苦于第三方库插件一直无法打包成功，因此开始学习之路。&lt;br&gt;本文收藏自 &lt;a href=&quot;https://www.jianshu.com/p/fe54d70a260e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android NDK入门避坑指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文基于自己所学到的NDk的知识和一些在网上查到的资料&lt;/p&gt;
&lt;p&gt;因为学习NDK的时间不是很长，学到的内容难免有所错漏，希望有问题的可以明确的指出来，我会积极采纳&lt;/p&gt;
&lt;p&gt;本文会竭尽可能的将我现在所学到的关于NDK的知识清晰的表达出来，本文主要以&lt;strong&gt;NDK的基本概念，NDK的组成部分，NDK的注意事项三个部分组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实践部分因为本篇文章已经6000多字了，为了不让文章过长，将会在后面的博客中&lt;/p&gt;
&lt;h1 id=&quot;一-NDK的基本概念&quot;&gt;&lt;a href=&quot;#一-NDK的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一. NDK的基本概念&quot;&gt;&lt;/a&gt;一. NDK的基本概念&lt;/h1&gt;&lt;p&gt;在学习NDK之前，我首先得知道什么是NDK，NDK可以干些什么，使用NDK的好处有哪些，知道了这些，我们才可以更好的学习NDK&lt;/p&gt;
&lt;h3 id=&quot;1-什么是NDK&quot;&gt;&lt;a href=&quot;#1-什么是NDK&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是NDK&quot;&gt;&lt;/a&gt;1. 什么是NDK&lt;/h3&gt;&lt;p&gt;NDK即&lt;code&gt;Native Development Kit&lt;/code&gt;,是Android中的一个开发工具包,为我们提供native开发的环境&lt;/p&gt;
&lt;p&gt;NDK是我们实现Java与Native进行交互的一个&lt;strong&gt;手段&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://nkoo.top/categories/Android/"/>
    
    
      <category term="android" scheme="https://nkoo.top/tags/android/"/>
    
      <category term="ndk" scheme="https://nkoo.top/tags/ndk/"/>
    
      <category term="jdk" scheme="https://nkoo.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>在 Docker 中运行 PostgreSQL</title>
    <link href="https://nkoo.top/2022/10/08/Docker-PostgreSQL/"/>
    <id>https://nkoo.top/2022/10/08/Docker-PostgreSQL/</id>
    <published>2022-10-08T10:46:12.000Z</published>
    <updated>2022-10-08T10:39:01.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>我们在这里要做的是下载PostgreSQL镜像，检查镜像是否准备好，使用特定参数运行镜像，最后连接到正在运行的PostgreSQL实例。</p></blockquote><h3 id="1-拉取一个-PostgreSQL-服务器-Docker-镜像"><a href="#1-拉取一个-PostgreSQL-服务器-Docker-镜像" class="headerlink" title="1.拉取一个 PostgreSQL 服务器 Docker 镜像"></a>1.拉取一个 PostgreSQL 服务器 Docker 镜像</h3><p>首先，我们需要从Docker Hub获取现有的 PostgreSQL 官方镜像。如果您需要特定版本，latest 请将标签更改 为所需版本。<br>现在让我们拉取镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull postgres:latest</span><br></pre></td></tr></table></figure></p><p>使用上述命令将从 Docker Hub 存储库中提取最新可用版本的 PostgreSQL。</p><h3 id="2-从-PostgreSQL-服务器-Docker-镜像运行容器"><a href="#2-从-PostgreSQL-服务器-Docker-镜像运行容器" class="headerlink" title="2. 从 PostgreSQL 服务器 Docker 镜像运行容器"></a>2. 从 PostgreSQL 服务器 Docker 镜像运行容器</h3><p>在部署之前，您需要设置一个 Docker 卷或绑定安装来持久化您的数据库。否则，当容器重新启动时，您的数据将丢失。安装应该 /var/lib/postgresql/data 在容器内的目录中。<br>出于本指南的目的，我们将创建一个 docker 卷并将其附加到您的 PostgreSQL 容器。<br>以下命令将在您的本地计算机中创建卷，您可以稍后与 PostgreSQL 容器连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker volume create postgres-volume</span><br></pre></td></tr></table></figure><p>现在你的机器上有 PostgreSQL 镜像和一个用于保存数据的卷，你可以部署一个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name=postgres14 -p 5432:5432 -v postgres-volume:/var/lib/postgresql/data -e POSTGRES_PASSWORD=your_password postgres</span><br></pre></td></tr></table></figure><p>默认用户名是 postgres</p><a id="more"></a><p>该 docker run 命令将在 Docker 容器中创建一个正在运行的 PostgreSQL 数据库。</p><p>让我们分解一下这个语法。以下是该命令中每个参数的含义：</p><p>-d 将以分离模式运行此容器，以便它在后台运行。<br>–name 将名称“postgres13”分配给您的容器实例。<br>-p会将 PostgreSQL 容器端口 5432 绑定到主机上的相同端口。您将能够localhost:5432 使用psql在您的主机上运行的PostgreSQL 客户端进行连接 。<br>-v选项将容器卷 ( /var/lib/postgresql)内的数据文件夹绑定到postgres-volume您在上一步中创建的本地 Docker 卷。<br>-e设置环境变量。在这种情况下，PostgreSQL 根密码。<br>postgres 是我们用来创建容器的镜像的名称。<br>您可以通过列出正在运行的容器来检查容器是否正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure><p>恭喜！您的新 PostgreSQL 实例现在正在 Docker 上运行。</p><p>此外，您可以使用以下命令检查正在运行的 PostgreSQL 容器的日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs postgres14</span><br></pre></td></tr></table></figure><h3 id="3-连接到PostgreSQL服务器"><a href="#3-连接到PostgreSQL服务器" class="headerlink" title="3. 连接到PostgreSQL服务器"></a>3. 连接到PostgreSQL服务器</h3><p>您可以通过附加到容器并运行psql命令来获得交互式 PostgreSQL shell 。这提供了完整的 PostgreSQL 命令行界面，因此您可以使用所有熟悉的命令和标志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it postgres13 psql -U postgres</span><br></pre></td></tr></table></figure><p>psql如果您在主机上预安装了PostgreSQL 客户端，您还可以使用PostgreSQL 客户端连接 PostgreSQL Docker 实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h localhost -U postgres</span><br></pre></td></tr></table></figure><h3 id="4-用可视化工具-pgadmin4-管理"><a href="#4-用可视化工具-pgadmin4-管理" class="headerlink" title="4. 用可视化工具 pgadmin4 管理"></a>4. 用可视化工具 pgadmin4 管理</h3><h3 id="4-1-在docker中部署pgadmin4"><a href="#4-1-在docker中部署pgadmin4" class="headerlink" title="4.1 在docker中部署pgadmin4"></a>4.1 在docker中部署pgadmin4</h3><p>拉取postgresql可视化工具pgadmin4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dpage/pgadmin4</span><br></pre></td></tr></table></figure><p>运行pgadmin4：</p><p>-p 5433:80 将容器的80端口映射到宿主机的5433端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5433:80 --name pgadmin4 -e PGADMIN_DEFAULT_EMAIL=<span class="built_in">test</span>@123.com -e PGADMIN_DEFAULT_PASSWORD=your_password dpage/pgadmin4</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;我们在这里要做的是下载PostgreSQL镜像，检查镜像是否准备好，使用特定参数运行镜像，最后连接到正在运行的PostgreSQL实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-拉取一个-PostgreSQL-服务器-Docker-镜像&quot;&gt;&lt;a href=&quot;#1-拉取一个-PostgreSQL-服务器-Docker-镜像&quot; class=&quot;headerlink&quot; title=&quot;1.拉取一个 PostgreSQL 服务器 Docker 镜像&quot;&gt;&lt;/a&gt;1.拉取一个 PostgreSQL 服务器 Docker 镜像&lt;/h3&gt;&lt;p&gt;首先，我们需要从Docker Hub获取现有的 PostgreSQL 官方镜像。如果您需要特定版本，latest 请将标签更改 为所需版本。&lt;br&gt;现在让我们拉取镜像：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker pull postgres:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用上述命令将从 Docker Hub 存储库中提取最新可用版本的 PostgreSQL。&lt;/p&gt;
&lt;h3 id=&quot;2-从-PostgreSQL-服务器-Docker-镜像运行容器&quot;&gt;&lt;a href=&quot;#2-从-PostgreSQL-服务器-Docker-镜像运行容器&quot; class=&quot;headerlink&quot; title=&quot;2. 从 PostgreSQL 服务器 Docker 镜像运行容器&quot;&gt;&lt;/a&gt;2. 从 PostgreSQL 服务器 Docker 镜像运行容器&lt;/h3&gt;&lt;p&gt;在部署之前，您需要设置一个 Docker 卷或绑定安装来持久化您的数据库。否则，当容器重新启动时，您的数据将丢失。安装应该 /var/lib/postgresql/data 在容器内的目录中。&lt;br&gt;出于本指南的目的，我们将创建一个 docker 卷并将其附加到您的 PostgreSQL 容器。&lt;br&gt;以下命令将在您的本地计算机中创建卷，您可以稍后与 PostgreSQL 容器连接：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker volume create postgres-volume&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在你的机器上有 PostgreSQL 镜像和一个用于保存数据的卷，你可以部署一个容器：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker run -d --name=postgres14 -p 5432:5432 -v postgres-volume:/var/lib/postgresql/data -e POSTGRES_PASSWORD=your_password postgres&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认用户名是 postgres&lt;/p&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://nkoo.top/categories/DataBase/"/>
    
      <category term="PostgreSQL" scheme="https://nkoo.top/categories/DataBase/PostgreSQL/"/>
    
    
      <category term="PostgreSQL" scheme="https://nkoo.top/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>如何用tauri + vue 搭建一个windows应用</title>
    <link href="https://nkoo.top/2022/10/08/Tauri-vue/"/>
    <id>https://nkoo.top/2022/10/08/Tauri-vue/</id>
    <published>2022-10-08T10:46:12.000Z</published>
    <updated>2023-03-21T07:56:48.001Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语</p><p>本次实验，使用 tauri 作为桌面框架，使用 Rust 语言作为后端，使用 axum 作为后端框架，使用 vue3 + element-plus 作为前端UI，使用 cargo + npm 作为包管理器，使用 vite 作为前端打包工具， 使用 TS 作为前端开发语言<br>使用 websocket 作为通信协议</p></blockquote><p>npm 官网<br><a href="https://www.npmjs.com/package/npm" target="_blank" rel="noopener">https://www.npmjs.com/package/npm</a><br><a href="https://docs.npmjs.com/" target="_blank" rel="noopener">https://docs.npmjs.com/</a></p><h3 id="1-用vite创建一个vue项目"><a href="#1-用vite创建一个vue项目" class="headerlink" title="1.用vite创建一个vue项目"></a>1.用vite创建一个vue项目</h3><p>vite 官网<br><a href="https://vitejs.cn/" target="_blank" rel="noopener">https://vitejs.cn/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><p>  cd vite-project<br>  npm install<br>  npm run dev</p><p>VS Code 安装的插件</p><p>JavaScript and TypeScript Nightly<br>Tauri<br>rust-analyzer<br>Vue Language Features (Volar)</p><p>CodeLLDB<br>es6-string-html</p><h3 id="添加到-github-进行版本管理"><a href="#添加到-github-进行版本管理" class="headerlink" title="添加到 github 进行版本管理"></a>添加到 github 进行版本管理</h3><p>在项目根目录下初始化</p><p>初始化本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\RustProject\espect-launcher&gt; git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> E:/RustProject/espect-launcher/.git/</span><br></pre></td></tr></table></figure></p><p>当前分支更名为main<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M main</span><br></pre></td></tr></table></figure></p><p>添加本地所有文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></p><p>提交本次修改（新增加文件）到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"new project"</span></span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS E:\RustProject\espect-launcher&gt; git commit -m <span class="string">"new project"</span></span><br><span class="line">[main (root-commit) 167eb52] new project</span><br><span class="line"> 16 files changed, 1713 insertions(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"> create mode 100644 .vscode/extensions.json</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"> create mode 100644 index.html</span><br><span class="line"> create mode 100644 package-lock.json</span><br><span class="line"> create mode 100644 package.json</span><br><span class="line"> create mode 100644 public/vite.svg</span><br><span class="line"> create mode 100644 src/App.vue</span><br><span class="line"> create mode 100644 src/assets/vue.svg</span><br><span class="line"> create mode 100644 src/components/HelloWorld.vue</span><br><span class="line"> create mode 100644 src/main.ts</span><br><span class="line"> create mode 100644 src/style.css</span><br><span class="line"> create mode 100644 src/vite-env.d.ts</span><br><span class="line"> create mode 100644 tsconfig.json</span><br><span class="line"> create mode 100644 tsconfig.node.json</span><br><span class="line"> create mode 100644 vite.config.ts</span><br></pre></td></tr></table></figure></p><p>添加远程仓库（origin）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:DreamingPoet/espect_launcher.git</span><br></pre></td></tr></table></figure></p><p>推送当前main 分支到 远程仓库（origin）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS E:\RustProject\espect-launcher&gt; git push -u origin main </span><br><span class="line">Enumerating objects: 23, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (23/23), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (23/23), 13.42 KiB | 859.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 23 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">To github.com:DreamingPoet/espect-launcher.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch <span class="string">'main'</span> <span class="built_in">set</span> up to track <span class="string">'origin/main'</span>.</span><br></pre></td></tr></table></figure></p><p>安装 element-plus<br>npm install element-plus –save<br><a href="http://element-plus.org/" target="_blank" rel="noopener">http://element-plus.org/</a></p><h3 id="安装后端相关"><a href="#安装后端相关" class="headerlink" title="安装后端相关"></a>安装后端相关</h3><p>tauri官网<br><a href="https://tauri.app/" target="_blank" rel="noopener">https://tauri.app/</a></p><p>install tauri cli</p><p>初始化后端Rust，添加 tauri<br>cargo tauri init</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS E:\RustProject\espect-launcher&gt; cargo tauri init</span><br><span class="line">✔ What is your app name? · espect-launcher</span><br><span class="line">✔ What should the window title be? · espect-launcher</span><br><span class="line">✔ Where are your web assets (HTML/CSS/JS) located, relative to the <span class="string">"&lt;current dir&gt;/src-tauri/tauri.conf.json"</span> file that will be created? · ../dist</span><br><span class="line">✔ What is the url of your dev server? · http://localhost:8080</span><br><span class="line">✔ What is your frontend dev <span class="built_in">command</span>? · npm run dev    </span><br><span class="line">✔ What is your frontend build <span class="built_in">command</span>? · npm run build</span><br></pre></td></tr></table></figure><p>启动调试<br>cargo tauri dev</p><h3 id="连接前后端"><a href="#连接前后端" class="headerlink" title="连接前后端"></a>连接前后端</h3><p>npm install @tauri-apps/api</p><p>Tauri 应用篇 - 系统托盘<br><a href="https://zhuanlan.zhihu.com/p/548270127" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/548270127</a><br><a href="https://www.cnblogs.com/yjmyzz/p/system-tray-with-tauri.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjmyzz/p/system-tray-with-tauri.html</a></p><p><a href="https://github.com/caojianyu/tauri-ti" target="_blank" rel="noopener">https://github.com/caojianyu/tauri-ti</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;导语&lt;/p&gt;
&lt;p&gt;本次实验，使用 tauri 作为桌面框架，使用 Rust 语言作为后端，使用 axum 作为后端框架，使用 vue3 + element-plus 作为前端UI，使用 cargo + npm 作为包管理器，使用 vite 作为前
      
    
    </summary>
    
      <category term="Rust" scheme="https://nkoo.top/categories/Rust/"/>
    
      <category term="Tauri" scheme="https://nkoo.top/categories/Rust/Tauri/"/>
    
    
      <category term="vue" scheme="https://nkoo.top/tags/vue/"/>
    
      <category term="element-plus" scheme="https://nkoo.top/tags/element-plus/"/>
    
      <category term="npm" scheme="https://nkoo.top/tags/npm/"/>
    
      <category term="vite" scheme="https://nkoo.top/tags/vite/"/>
    
      <category term="tauri" scheme="https://nkoo.top/tags/tauri/"/>
    
      <category term="git" scheme="https://nkoo.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>FString和各种数据格式间转换</title>
    <link href="https://nkoo.top/2022/04/20/UE4-FString/"/>
    <id>https://nkoo.top/2022/04/20/UE4-FString/</id>
    <published>2022-04-20T14:46:15.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、UE4-Source-Header-References"><a href="#一、UE4-Source-Header-References" class="headerlink" title="一、UE4 Source Header References"></a>一、UE4 Source Header References</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CString.h</span><br><span class="line">UnrealString.h</span><br><span class="line">NameTypes.h</span><br><span class="line">StringConv.h (TCHAR_TO_ANSI etc)</span><br></pre></td></tr></table></figure><p>CString.h可以查到更多，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atoi64 (<span class="built_in">string</span> to int64)</span><br><span class="line">Atod (<span class="built_in">string</span> to <span class="keyword">double</span> precision <span class="keyword">float</span>)</span><br></pre></td></tr></table></figure></p><h3 id="二、日志打印"><a href="#二、日志打印" class="headerlink" title="二、日志打印"></a>二、日志打印</h3><h4 id="1-输出字符串到output-log中"><a href="#1-输出字符串到output-log中" class="headerlink" title="1.输出字符串到output log中"></a>1.输出字符串到output log中</h4><h4 id="1-1-最普通的三种"><a href="#1-1-最普通的三种" class="headerlink" title="1.1 最普通的三种"></a>1.1 最普通的三种</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FString filePath</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"Hello,World!"</span>));</span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(<span class="string">"Hello,World!"</span>));</span><br><span class="line">UE_LOG(LogTemp, Error, TEXT(<span class="string">"Hello,World!"</span>));</span><br><span class="line">#### <span class="number">1.2</span> %d打印<span class="keyword">int</span>，%f打印<span class="keyword">float</span>，%s <span class="built_in">string</span></span><br></pre></td></tr></table></figure><a id="more"></a> <p>前面加throttle是为了知道打印的对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">UE_LOG(LogTemp，Log，TEXT(<span class="string">"throttle %d"</span>), throttle);</span><br><span class="line"><span class="comment">//输出：throttle 1532</span></span><br><span class="line">FString filePath</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"%s"</span>), *filePath);</span><br></pre></td></tr></table></figure></p><h4 id="1-3-自定义-分类的名字-的log"><a href="#1-3-自定义-分类的名字-的log" class="headerlink" title="1.3 自定义 分类的名字 的log"></a>1.3 自定义 分类的名字 的log</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">    <span class="function">DECLARE LOG CATEGORY <span class="title">EXTERN</span><span class="params">(MyLog,Log，All)</span></span>;</span><br><span class="line">.cpp</span><br><span class="line">    DEFINE_LOG_CATEGORY(MyLog);</span><br><span class="line">​</span><br><span class="line">UE_LOG(MyLog,Warning,TEXT (<span class="string">"Success"</span>));</span><br><span class="line">​</span><br><span class="line">输出：</span><br><span class="line">MyLog:Warning:Success</span><br></pre></td></tr></table></figure><h4 id="2-输出字符串到屏幕上"><a href="#2-输出字符串到屏幕上" class="headerlink" title="2.输出字符串到屏幕上"></a>2.输出字符串到屏幕上</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FString filePath;</span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">5.f</span>, FColor::Green, FString::Printf(TEXT(<span class="string">"DLL_Init"</span>)));</span><br><span class="line"> </span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">5.f</span>, FColor::Green, FString::Printf(TEXT(<span class="string">"%s"</span>), *filePath));</span><br></pre></td></tr></table></figure><h3 id="三、FString"><a href="#三、FString" class="headerlink" title="三、FString"></a>三、FString</h3><h4 id="3-1-FString-To-FNames"><a href="#3-1-FString-To-FNames" class="headerlink" title="3.1 FString To FNames"></a>3.1 FString To FNames</h4><p>不可靠，因为FName不区分大小写，所以转换存在丢失<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line">FString TheString = <span class="string">"Hello，world"</span>;</span><br><span class="line"><span class="comment">//将FString转换为FName</span></span><br><span class="line">FName ConvertedFString = FName(*TheString);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-FString-To-FText"><a href="#3-2-FString-To-FText" class="headerlink" title="3.2 FString To FText"></a>3.2 FString To FText</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"Hello，world"</span>;</span><br><span class="line">FText ConvertedFSting=FText::FromSting(TheString);</span><br></pre></td></tr></table></figure><h4 id="3-3-FString-To-Array"><a href="#3-3-FString-To-Array" class="headerlink" title="3.3 FString To Array"></a>3.3 FString To Array</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">FString JsonStr;  </span><br><span class="line">TArray&lt;uint8&gt; content;  </span><br><span class="line"> </span><br><span class="line">content.SetNum(JsonStr.Len());  </span><br><span class="line"><span class="built_in">memcpy</span>(content.GetData(), TCHAR_TO_ANSI(*JsonStr), JsonStr.Len());</span><br><span class="line">​</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">FString StrData;  </span><br><span class="line"><span class="keyword">const</span> TCHAR* StrPtr = *StrData;  </span><br><span class="line"><span class="function">FTCHARToUTF8 <span class="title">UTF8String</span><span class="params">(StrPtr)</span></span>;  </span><br><span class="line">int32 CTXSize = UTF8String.Length();  </span><br><span class="line"> </span><br><span class="line">TArray&lt;uint8&gt; URLData;  </span><br><span class="line">URLData.SetNum(CTXSize);  </span><br><span class="line"><span class="built_in">memcpy</span>(URLData.GetData(), UTF8String.Get(), CTXSize);</span><br></pre></td></tr></table></figure><h4 id="3-4-FString-To-char"><a href="#3-4-FString-To-char" class="headerlink" title="3.4 FString To char*"></a>3.4 FString To char*</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"Hello，world"</span>;</span><br><span class="line"><span class="keyword">char</span>* MyCharPtr = TCHAR_TO_UTF8(*MyFString);</span><br></pre></td></tr></table></figure><h4 id="3-5-FString-To-const-char"><a href="#3-5-FString-To-const-char" class="headerlink" title="3.5 FString To const char *"></a>3.5 FString To const char *</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *plainText= TCHAR_TO_ANSI(*aes_content);</span><br></pre></td></tr></table></figure><h4 id="3-6-FString-To-TCHAR"><a href="#3-6-FString-To-TCHAR" class="headerlink" title="3.6 FString To TCHAR*"></a>3.6 FString To TCHAR*</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString s=<span class="string">"a"</span>;</span><br><span class="line">TCHAR* t=*s;</span><br></pre></td></tr></table></figure><h4 id="3-7-FString-To-std-string"><a href="#3-7-FString-To-std-string" class="headerlink" title="3.7 FString To std::string"></a>3.7 FString To std::string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">​</span><br><span class="line">FString UE4Str = <span class="string">"Flowers"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> MyStdString = TCHAR_TO_UTF8(*UE4Str);</span><br></pre></td></tr></table></figure><h4 id="3-8-FString-To-JsonObject"><a href="#3-8-FString-To-JsonObject" class="headerlink" title="3.8 FString To JsonObject"></a>3.8 FString To JsonObject</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;FJsonObject&gt; JsonObject = MakeShareable(<span class="keyword">new</span> FJsonObject);</span><br><span class="line">TSharedRef&lt;TJsonReader&lt;&gt;&gt; Reader = TJsonReaderFactory&lt;&gt;::Create(JsonStr);</span><br><span class="line">FJsonSerializer::Deserialize(Reader,JsonObject);</span><br><span class="line"><span class="comment">//JsonObject就是Json</span></span><br></pre></td></tr></table></figure><h4 id="3-9-FString-To-bool"><a href="#3-9-FString-To-bool" class="headerlink" title="3.9 FString To bool"></a>3.9 FString To bool</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="keyword">bool</span> MyBool = MyFString.ToBool();</span><br></pre></td></tr></table></figure><h4 id="3-10-FString-To-int32"><a href="#3-10-FString-To-int32" class="headerlink" title="3.10 FString To int32"></a>3.10 FString To int32</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="comment">//注意，Atoi和Atof是静态函数，所以使用语法FCString：：TheFunction调用它：)</span></span><br><span class="line">int32 MyShinyNewInt = FCString::Atoi(*TheString);</span><br></pre></td></tr></table></figure><h4 id="3-11-FString-To-int64"><a href="#3-11-FString-To-int64" class="headerlink" title="3.11 FString To int64"></a>3.11 FString To int64</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"12312345678789561234879"</span>;</span><br><span class="line"><span class="comment">//注意，Atoi64是静态函数，所以使用语法FCString::TheFunction调用它：)</span></span><br><span class="line">int64 MyShinyNewInt = FCString::Atoi64(*TheString);</span><br></pre></td></tr></table></figure><h4 id="3-12-FString-To-float"><a href="#3-12-FString-To-float" class="headerlink" title="3.12 FString To float"></a>3.12 FString To float</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="comment">//注意，Atoi和Atof是静态函数，所以使用语法FCString：：TheFunction调用它：)</span></span><br><span class="line"><span class="keyword">float</span> MyShinyNewFloat = FCString::Atof(*TheString);</span><br></pre></td></tr></table></figure><h4 id="3-13-FString-To-double"><a href="#3-13-FString-To-double" class="headerlink" title="3.13 FString To double"></a>3.13 FString To double</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数方式</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UDoubleFunction::FStringToDouble</span><span class="params">(FString str,<span class="keyword">double</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> numString = TCHAR_TO_UTF8(*str);</span><br><span class="line">    <span class="keyword">double</span> b = atof(numString.c_str());</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num =b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//直接转换</span></span><br><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="comment">//注意，Atod是静态函数，所以使用语法FCString：：TheFunction调用它：)</span></span><br><span class="line"><span class="keyword">double</span> MyShinyNewFloat = FCString::Atod(*TheString);</span><br><span class="line">​</span><br><span class="line"><span class="comment">//FString转String转Double</span></span><br><span class="line">FString str = <span class="string">"113.5246854"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> numString = TCHAR_TO_UTF8(*str);</span><br><span class="line"><span class="keyword">double</span> b = atof(numString.c_str());</span><br></pre></td></tr></table></figure><h4 id="3-14-转换-To-FString"><a href="#3-14-转换-To-FString" class="headerlink" title="3.14 转换 To FString"></a>3.14 转换 To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int</span></span><br><span class="line">FString NewString = FString::FromInt(MyInt);</span><br><span class="line"><span class="comment">//float //double    ----只能精确到小数点后6位</span></span><br><span class="line">FString VeryCleanString = FString::SanitizeFloat(MyFloat);</span><br><span class="line"><span class="comment">//bool</span></span><br><span class="line">FString MyFString = MyBool?TEXT(<span class="string">"true"</span>) :TEXT(<span class="string">"false"</span>);</span><br><span class="line"><span class="comment">//FVector</span></span><br><span class="line">FString MyFString = MyVector.ToString();</span><br><span class="line"><span class="comment">//FVector2D</span></span><br><span class="line">FString MyFString = MyVector2D.ToString();</span><br><span class="line"><span class="comment">//FRotator</span></span><br><span class="line">FString MyFString = MyRotator.ToString();</span><br><span class="line"><span class="comment">//FLinearColor</span></span><br><span class="line">FString MyFString = MyLinearColor.ToString();</span><br><span class="line"><span class="comment">//UObject</span></span><br><span class="line">FString MyFString = (MyObj != <span class="literal">NULL</span>) ? MyObj-&gt;GetName() : FString(TEXT(<span class="string">"None"</span>));</span><br><span class="line"><span class="comment">//FMatrix</span></span><br><span class="line"><span class="function">FMatrix <span class="title">rotationMatrix</span><span class="params">(FPlane(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),FPlane(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>),FPlane(<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>),FPlane(<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>))</span></span>;          </span><br><span class="line">FString str = rotationMatrix.ToString();</span><br></pre></td></tr></table></figure><h4 id="3-15-double-To-FString"><a href="#3-15-double-To-FString" class="headerlink" title="3.15 double To FString"></a>3.15 double To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接转换：精确到小数点后6位</span></span><br><span class="line"><span class="keyword">return</span>   FString::SanitizeFloat(numeral.dou);</span><br><span class="line"></span><br><span class="line"><span class="comment">//double→string→FString精确到小数点后6位</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Str = <span class="built_in">std</span>::to_string(numeral.dou);</span><br><span class="line">FString <span class="built_in">string</span> = UTF8_TO_TCHAR(Str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出有效位数15位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">double</span> d = numeral.dou;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; setprecision(<span class="number">15</span>) &lt;&lt; d;</span><br><span class="line">str = ss.str();</span><br><span class="line">FString <span class="built_in">string</span> = UTF8_TO_TCHAR(str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定小数点后几位   --注：double的有效位数只有16位，小数点算一位</span></span><br><span class="line"><span class="keyword">double</span> doub = <span class="number">9999.1234567891011121314</span>;</span><br><span class="line">FString TimeDesc = FString::Printf(TEXT(<span class="string">"%.15f"</span>), doub);<span class="comment">//9999.123456789100601</span></span><br></pre></td></tr></table></figure><h4 id="3-16-bytes-To-FString"><a href="#3-16-bytes-To-FString" class="headerlink" title="3.16 bytes To FString"></a>3.16 bytes To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FString fstr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; FaceArray.Num() * <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    FString tmpStr;</span><br><span class="line">    ByteToHex(f_arrbytes[i], tmpStr);</span><br><span class="line">    fstr.Append(tmpStr);</span><br><span class="line">&#125;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"%S"</span>), *fstr);</span><br></pre></td></tr></table></figure><h4 id="3-17-FArrayReaderPtr-to-FString"><a href="#3-17-FArrayReaderPtr-to-FString" class="headerlink" title="3.17 FArrayReaderPtr to FString"></a>3.17 FArrayReaderPtr to FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8 data[<span class="number">512</span>];  </span><br><span class="line">FMemory::Memzero(data, <span class="number">512</span>);  </span><br><span class="line">FMemory::Memcpy(data, ArrayReaderPtr-&gt;GetData(), ArrayReaderPtr-&gt;Num());</span><br></pre></td></tr></table></figure><p>FString str = ((const char*)data);</p><h4 id="3-18-Array-to-FString"><a href="#3-18-Array-to-FString" class="headerlink" title="3.18 Array to FString"></a>3.18 Array to FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;uint8&gt; content;  </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">cstr</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(content.GetData()), content.Num())</span></span>;  </span><br><span class="line">FString frameAsFString = cstr.c_str();  </span><br><span class="line">UE_LOG(VRSLog, Warning, TEXT(<span class="string">"%s"</span>), *frameAsFString);</span><br></pre></td></tr></table></figure><h3 id="四、FName"><a href="#四、FName" class="headerlink" title="四、FName"></a>四、FName</h3><h4 id="4-1-FName-To-FString"><a href="#4-1-FName-To-FString" class="headerlink" title="4.1 FName To FString"></a>4.1 FName To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FName str = FName(TEXT(<span class="string">"hello"</span>));</span><br><span class="line">FString fstr = str.ToString();</span><br></pre></td></tr></table></figure><h4 id="4-2-FName-To-FText"><a href="#4-2-FName-To-FText" class="headerlink" title="4.2 FName To FText"></a>4.2 FName To FText</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FName str = FName(TEXT(<span class="string">"hello"</span>));</span><br><span class="line">FText = FText::FromName(str);</span><br></pre></td></tr></table></figure><h3 id="五、FText"><a href="#五、FText" class="headerlink" title="五、FText"></a>五、FText</h3><p>FText To FString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不可靠，在一些语言中存在损耗</span></span><br><span class="line">FString Name = MyText.ToString();</span><br></pre></td></tr></table></figure></p><h3 id="六、TChar"><a href="#六、TChar" class="headerlink" title="六、TChar*"></a>六、TChar*</h3><p>TChar<em> 与 char</em> 的互相转换<br>主要是使用下面的四个宏定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCHAR_TO_ANSI(str) ANSI_TO_TCHAR(str) TCHAR_TO_UTF8(str) UTF8_TO_TCHAR(str)</span><br></pre></td></tr></table></figure></p><h3 id="七、std-string"><a href="#七、std-string" class="headerlink" title="七、std::string"></a>七、std::string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> To FString</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>std::string MyStdString = “Happy”;<br>FString HappyString(UTF8_TO_TCHAR(MyStdString.c_str()));  //可防止string的中文转换出错<br>To string函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c++<span class="number">11</span>标准增加了全局函数<span class="built_in">std</span>::to_string:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">float</span> val)</span></span>;       <span class="comment">//只能精确到小数点后6位</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">double</span> val)</span></span>;      <span class="comment">//只能精确到小数点后6位</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure></p><p>string To函数<br>string To int<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> n = atoi(str.c_str());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n; <span class="comment">//123</span></span><br></pre></td></tr></table></figure></p><p>double-&gt;string<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有效位数20位   ---据说待考证</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">double</span> b=<span class="number">1245683.141592653</span>;</span><br><span class="line"><span class="keyword">int</span> ndight=<span class="number">20</span>;<span class="comment">//有效数字位数</span></span><br><span class="line">gcvt(b,ndight,buffer);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//一般使用方法:只能精确到小数点后6位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.1415926535897932384</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(d);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 3.141593</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">//使用stringstream，在输入流时使用setprecision设置精度，需包含头文件 &lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">//精度保持到小数点后15位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; setprecision(<span class="number">15</span>) &lt;&lt; d;</span><br><span class="line">str = ss.str();   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 3.14159265358979</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>//对于double类型，setprecision(15) 参数最大有效值为15，超过15，数据就不保证可靠了。<br>string-&gt;double<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"1245683.141592653"</span>;</span><br><span class="line"><span class="keyword">double</span> num=atof(str.c_str());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0.9lf\n"</span>,num);</span><br></pre></td></tr></table></figure></p><h3 id="八、char"><a href="#八、char" class="headerlink" title="八、char*"></a>八、char*</h3><p>char* To FString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FString MyFString = FString(UTF8_TO_TCHAR(MyCharPtr));</span><br></pre></td></tr></table></figure></p><h3 id="九、UE4-Json"><a href="#九、UE4-Json" class="headerlink" title="九、UE4_Json"></a>九、UE4_Json</h3><p>JsonObject To FString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Jdata转换为了JsonStr</span></span><br><span class="line">FString JsonStr;</span><br><span class="line">TSharedRef&lt;TJsonWriter&lt;&gt;&gt; Writer = TJsonWriterFactory&lt;&gt;::Create(&amp;JsonStr);</span><br><span class="line">FJsonSerializer::Serialize(Jdata.ToSharedRef(), Writer);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、UE4-Source-Header-References&quot;&gt;&lt;a href=&quot;#一、UE4-Source-Header-References&quot; class=&quot;headerlink&quot; title=&quot;一、UE4 Source Header References&quot;&gt;&lt;/a&gt;一、UE4 Source Header References&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CString.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UnrealString.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NameTypes.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringConv.h (TCHAR_TO_ANSI etc)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CString.h可以查到更多，如&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;atoi64 (&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; to int64)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Atod (&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; to &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; precision &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、日志打印&quot;&gt;&lt;a href=&quot;#二、日志打印&quot; class=&quot;headerlink&quot; title=&quot;二、日志打印&quot;&gt;&lt;/a&gt;二、日志打印&lt;/h3&gt;&lt;h4 id=&quot;1-输出字符串到output-log中&quot;&gt;&lt;a href=&quot;#1-输出字符串到output-log中&quot; class=&quot;headerlink&quot; title=&quot;1.输出字符串到output log中&quot;&gt;&lt;/a&gt;1.输出字符串到output log中&lt;/h4&gt;&lt;h4 id=&quot;1-1-最普通的三种&quot;&gt;&lt;a href=&quot;#1-1-最普通的三种&quot; class=&quot;headerlink&quot; title=&quot;1.1 最普通的三种&quot;&gt;&lt;/a&gt;1.1 最普通的三种&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FString filePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UE_LOG(LogTemp, Log, TEXT(&lt;span class=&quot;string&quot;&gt;&quot;Hello,World!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UE_LOG(LogTemp, Warning, TEXT(&lt;span class=&quot;string&quot;&gt;&quot;Hello,World!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UE_LOG(LogTemp, Error, TEXT(&lt;span class=&quot;string&quot;&gt;&quot;Hello,World!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### &lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt; %d打印&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;，%f打印&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;，%s &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="FString" scheme="https://nkoo.top/tags/FString/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统目录结构</title>
    <link href="https://nkoo.top/2022/04/16/LinuxFileSys/"/>
    <id>https://nkoo.top/2022/04/16/LinuxFileSys/</id>
    <published>2022-04-16T07:30:22.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<p>树状目录结构：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p><a id="more"></a> <p>以下是对这些目录的解释：</p><p>/bin：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p><p>/boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><p>/dev ：<br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p><p>/etc：<br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><p>/home：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p><p>/lib：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><p>/lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>/media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p><p>/mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p><p>/opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p><p>/proc：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><p>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all<br>/root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p><p>/sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p><p>/selinux：<br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p><p>/srv：<br> 该目录存放一些服务启动之后需要提取的数据。</p><p>/sys：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><p>/tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p><p>/usr：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p><p>/usr/bin：<br>系统用户使用的应用程序。</p><p>/usr/sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p><p>/usr/src：<br>内核源代码默认的放置目录。</p><p>/var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p><p>/run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p><p>值得提出的是 /bin、/usr/bin 是给系统用户使用的指令（除 root 外的通用用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树状目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://nkoo.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://nkoo.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UE4PythonHelper</title>
    <link href="https://nkoo.top/2022/03/27/UnrealEnginePythonHelper%20copy/"/>
    <id>https://nkoo.top/2022/03/27/UnrealEnginePythonHelper copy/</id>
    <published>2022-03-27T05:20:10.000Z</published>
    <updated>2023-04-08T23:55:02.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE4PythonHelper"><a href="#UE4PythonHelper" class="headerlink" title="UE4PythonHelper"></a>UE4PythonHelper</h1><p>This plugin is only used in editor mode!!!</p><p><img src="/images/ph01.webp" alt="ph01"></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol><li>This plug-in provides an “unreallib.py” module, which contains a complete UnrealEngine Python API. When you use it in text editors such as VS Code, you will get intelligent code prompt, function parameter prompt, return value type inference, comments, etc. you can also jump to the function in the module to view the detailed function definition. It’s better than automatically generated unreal.py file, smaller and compact, and supports the Type Hint syntax of python3.<a id="more"></a> </li><li><p>Automatically detect all Python files in the “$ProjectDir$/ Python” directory and run the file by clicking a button.</p></li><li><p>After clicking the python file, it will automatically identify the functions defined and call them directly by clicking a button (only functions without parameters can be executed)</p></li><li><p>When you edit a file in VS Code, it will automatically detect the change of the file and refresh the list of callable functions. The automatic refresh function can be turned off. Note: when “import” a module for the first time or through “importlib.reload ()” to reload a module, it executes the entire module.</p></li><li><p>You can directly open the python folder of the current work by shortcut.</p></li><li><p>When the panel is closed, all automatic detection will be closed until the panel is reopened.</p></li></ol><h2 id="Startup"><a href="#Startup" class="headerlink" title="Startup"></a>Startup</h2><ol><li>Open PythonHelper Tab( MainMenu -&gt; Window -&gt; PythonHelper)  </li></ol><p><img src="/images/ph02.webp" alt="ph02"></p><h2 id="Known-Issue"><a href="#Known-Issue" class="headerlink" title="Known Issue"></a>Known Issue</h2><ol><li><p>File named in “test.py” or directory named in “test” is not supported.</p></li><li><p>File name or directory start with number is not supported.</p></li><li><p>Numeric directory and file name are not supported.</p></li><li><p>Chinese directory and Chinese file name are not supported.</p></li></ol><h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>本插件只能在编辑器模式下使用</p><h2 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h2><ol><li><p>本插件提供一个 unreallib.py 模块，模块中包含了完整的 UnrealEngine Python API, 当你在VS Code 等编辑器中使用的时候，将获得智能代码提示，函数参数提示，返回值类型推断，注释等，也能跳转到模块中的函数，查看详细的函数定义。</p></li><li><p>自动检测 “$ProjectDir$/ Python” 目录下的所有 python 文件，通过点击按钮运行该文件</p></li><li><p>点选Python文件后，会自动识别文件中定义的函数，通过点击按钮直接调用（只能执行无参数的函数）</p></li><li><p>当你在VS Code 中编辑文件的时候，自动检测文件的变动，并且重新刷新可调用函数列表。自动刷新功能可以关闭。注意：在第一次 import 模块的时候，和通过 importlib.reload() 重新加载模块的时候，会执行整个模块。</p></li><li><p>可以通过快捷方式，直接打开当前工作的Python文件夹</p></li><li><p>当面板关闭的时候，所有的自动检测将会关闭，直到重新打开面板</p></li></ol><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ol><li><p>文件 “test.py” 和目录 “test” 不被支持.</p></li><li><p>以纯数字开头的文件目录和文件名不被支持.</p></li><li><p>纯数字的文件目录和文件名不被支持.</p></li><li><p>不支持中文目录和中文文件名.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UE4PythonHelper&quot;&gt;&lt;a href=&quot;#UE4PythonHelper&quot; class=&quot;headerlink&quot; title=&quot;UE4PythonHelper&quot;&gt;&lt;/a&gt;UE4PythonHelper&lt;/h1&gt;&lt;p&gt;This plugin is only used in editor mode!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ph01.webp&quot; alt=&quot;ph01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Features&quot;&gt;&lt;a href=&quot;#Features&quot; class=&quot;headerlink&quot; title=&quot;Features&quot;&gt;&lt;/a&gt;Features&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;This plug-in provides an “unreallib.py” module, which contains a complete UnrealEngine Python API. When you use it in text editors such as VS Code, you will get intelligent code prompt, function parameter prompt, return value type inference, comments, etc. you can also jump to the function in the module to view the detailed function definition. It’s better than automatically generated unreal.py file, smaller and compact, and supports the Type Hint syntax of python3.
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="tools" scheme="https://nkoo.top/tags/tools/"/>
    
      <category term="python" scheme="https://nkoo.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼编码在 UE4 中的实现</title>
    <link href="https://nkoo.top/2021/12/04/HuffmanEncode/"/>
    <id>https://nkoo.top/2021/12/04/HuffmanEncode/</id>
    <published>2021-12-04T03:05:10.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在UE4 中实现哈夫曼编码的本意是在网络数据传输的时候，进行数据包一定程度的数据压缩。但是实现完之后发现并无用武之地，一个是因为压缩的数据中还必须要包含编码表，对于高频、小数据包反而会增加数据的大小和增加编码解码的计算消耗。二是因为好多要传输的数据本身就是已经编码压缩过了，再次编码压缩已经没有效果了（比如UE4 的 RenderTarget 图像数据 和 VoiceData）。所以权当是一次代码练习吧。</p></blockquote><h2 id="关于哈夫曼编码"><a href="#关于哈夫曼编码" class="headerlink" title="关于哈夫曼编码"></a>关于哈夫曼编码</h2><p>Huffman于1952年提出一种编码方法，该方法完全依据出现概率来构造异字头的平均长度最短的码字 。简单来说就是用最少的bit来表示出现频率最高的字符，生成一张编码对照表，解码的时候根据对照表依次还原就行。<br>比如 “aabccade”，其中总共有a、b、c、d、e 五个字符，a出现3次，c出现2次，b、d、e出现1次，<br>那么可以用0表示a，用1表示c，用10表示b，用11表示d，用100表示e。所以原字符就可以用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span><span class="number">-0</span><span class="number">-10</span><span class="number">-1</span><span class="number">-1</span><span class="number">-0</span><span class="number">-11</span><span class="number">-100</span></span><br></pre></td></tr></table></figure></p><p>来表示了。当然具体实现细节要更复杂一点，涉及到二叉树，前缀码等。</p><p>好了，话不多说，上代码！<br><a id="more"></a> </p><p>HuffmanEncode.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETBIT(souce, index) souce |= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 设置0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEARBIT(souce, index) souce &amp;= ~(1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 位取反</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVERSEBIT(souce, index) souce ^= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 获取位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETBIT(souce, index) ((souce) &gt;&gt; (index) &amp; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">DECLARE_LOG_CATEGORY_EXTERN(HuffmanEncode, Log, All);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Huffman</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一颗 哈夫曼 树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ch = <span class="string">'\0'</span>; <span class="comment">// 该节点中的字符</span></span><br><span class="line"><span class="keyword">int</span> freq = <span class="number">0</span>; <span class="comment">// 该节点字符出现的次数（频率）</span></span><br><span class="line">Node* left = <span class="literal">nullptr</span>; <span class="comment">// 左叶子节点</span></span><br><span class="line">Node* right = <span class="literal">nullptr</span>; <span class="comment">// 右叶子节点</span></span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">unsigned</span> <span class="keyword">char</span> _c, <span class="keyword">int</span> f, Node* l = <span class="literal">nullptr</span>, Node* r = <span class="literal">nullptr</span>)</span><br><span class="line">:ch(_c), freq(f), left(l), right(r)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~Node()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; "~ Node " &lt;&lt; this-&gt;ch &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt; 运算符，在加入优先队列的时候决定如何处理结点位置</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> freq &gt; node.freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从输入流中读字节流，并将编码后的结果写入输出流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* inData, <span class="keyword">const</span> <span class="keyword">int</span> dataNum, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码</span></span><br><span class="line"><span class="comment"> * 读取编码的比特流，</span></span><br><span class="line"><span class="comment"> * 将比特流对应为路径在单词查找树上找，将找到的结点中的字符写出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span> dataSize, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataSize)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============= 辅助函数 ============ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delTree</span><span class="params">(Node* root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读比特流，得出一颗单词查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node* <span class="title">readTree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span>&amp; nodeIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将单词查找树编码成比特输出串并写入到输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTree</span><span class="params">(Node* x, <span class="keyword">int</span>&amp; count, <span class="keyword">unsigned</span> <span class="keyword">char</span>* tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建编译表，每个char值与一个比特字符串（即Huffman树上路径）的对照表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(<span class="built_in">string</span> st[], Node* x, <span class="built_in">string</span> s)</span></span>; <span class="comment">// st[63] = "001"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param freq 字符出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> freq[], <span class="keyword">int</span>&amp; outLeafNum)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HuffmanEncode.cpp </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HuffmanEncode.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">DEFINE_LOG_CATEGORY(HuffmanEncode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Huffman</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* inData, <span class="keyword">const</span> <span class="keyword">int</span> dataNum, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 计算【ascii 0-255】每个字符出现的次数，数组的index就是字符的值，数组的值是字符出现的次数</span></span><br><span class="line"><span class="keyword">int</span> freq[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataNum; i++) &#123;</span><br><span class="line">freq[inData[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 构建Huffman树</span></span><br><span class="line"><span class="keyword">int</span> leafNum = <span class="number">0</span>; <span class="comment">// 叶子节点数量</span></span><br><span class="line">Node* root = buildTree(freq, leafNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 构建编译表，每个char值与一个比特字符串（即Huffman树上路径）的对照表</span></span><br><span class="line"><span class="built_in">string</span> st[<span class="number">256</span>] = &#123; <span class="string">""</span> &#125;;</span><br><span class="line">buildCode(st, root, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 将单词查找树编码成比特输出串并写入到buff</span></span><br><span class="line">short <span class="keyword">int</span> treeByteNum = leafNum * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* tree = &amp;outData[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> currentByteIndex = <span class="number">0</span>; <span class="comment">// 当前写到第几个字节</span></span><br><span class="line">writeTree(root, currentByteIndex, tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用前面 1 个字节存储最后个1字节写到第几个bit,从0开始算起</span></span><br><span class="line"><span class="comment">// outData[0] = xxx;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 将单词总数编码成比特输出串并写入到输出流</span></span><br><span class="line"><span class="keyword">int</span> outBitCount = <span class="number">0</span>; <span class="comment">// 写当前字节的第几位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* outBitBuff = &amp;outData[treeByteNum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> outBuffCount = <span class="number">0</span>; <span class="comment">// 当前在写第几个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataNum; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> code = st[inData[i]];   <span class="comment">//code表示Huffman单词查找数上的路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; code.length(); j++) &#123;  <span class="comment">//要一位一位地输出</span></span><br><span class="line"><span class="keyword">if</span> (code[j] == <span class="string">'1'</span>)</span><br><span class="line">&#123;</span><br><span class="line">SETBIT(outBitBuff[outBuffCount], outBitCount);</span><br><span class="line">outBitCount++;</span><br><span class="line"><span class="keyword">if</span> (outBitCount == <span class="number">8</span>) &#123; outBitCount = <span class="number">0</span>; outBuffCount++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">CLEARBIT(outBitBuff[outBuffCount], outBitCount);</span><br><span class="line">outBitCount++;</span><br><span class="line"><span class="keyword">if</span> (outBitCount == <span class="number">8</span>) &#123; outBitCount = <span class="number">0</span>; outBuffCount++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经压缩的字节总数</span></span><br><span class="line"><span class="keyword">int</span> inDataEncodeByte = outBuffCount + (outBitCount &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用前面 1 个字节存储最后个1字节写到第几个bit,从0开始算起</span></span><br><span class="line">outData[<span class="number">0</span>] = outBitCount;</span><br><span class="line"></span><br><span class="line">outDataNum = <span class="number">1</span> + treeByteNum + inDataEncodeByte;</span><br><span class="line">UE_LOG(HuffmanEncode, Warning, TEXT(<span class="string">"======= Encode finished ========="</span>));</span><br><span class="line">delTree(root);  <span class="comment">// 清空内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span> dataSize, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1，获取最后一个字节需要读到第几个bit</span></span><br><span class="line"><span class="keyword">int</span> lastByteBitCount = indata[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2，读出查找树</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* treeData = &amp;indata[<span class="number">1</span>];</span><br><span class="line">Node* root = readTree(treeData, index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3，</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* encodedData = &amp;indata[index + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> N = dataSize - index - <span class="number">2</span>;  <span class="comment">//读出存在压缩文件中的字符串长度</span></span><br><span class="line"></span><br><span class="line">outDataSize = <span class="number">0</span>;</span><br><span class="line">Node* x = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;   <span class="comment">//找出源文件中每个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == N - <span class="number">1</span> &amp;&amp; j == lastByteBitCount + <span class="number">1</span>) <span class="comment">// </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!x-&gt;isLeaf()) <span class="comment">//遍历，直到叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (GETBIT(encodedData[i], j)) &#123;</span><br><span class="line">x = x-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x = x-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; " decode is " &lt;&lt; x-&gt;ch &lt;&lt; endl;</span></span><br><span class="line">outData[outDataSize] = x-&gt;ch;</span><br><span class="line">outDataSize++;</span><br><span class="line">j--;</span><br><span class="line">x = root; <span class="comment">// 重新从根节点出发</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UE_LOG(HuffmanEncode, Warning, TEXT(<span class="string">"======= Decode finished ========="</span>));</span><br><span class="line">delTree(root); <span class="comment">// 清空内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delTree</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root-&gt;isLeaf()) <span class="comment">//读到1，说明是叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">delTree(root-&gt;left);</span><br><span class="line">delTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">readTree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span>&amp; nodeIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nodeIndex++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indata[nodeIndex] == <span class="number">1</span>) <span class="comment">//读到1，说明是叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">nodeIndex++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(indata[nodeIndex], <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//读到的是0，说明是中间结点，需要递归直到读到1为止</span></span><br><span class="line">&#123;</span><br><span class="line">Node* left = readTree(indata, nodeIndex);</span><br><span class="line">Node* right = readTree(indata, nodeIndex);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTree</span><span class="params">(Node* x, <span class="keyword">int</span>&amp; count, <span class="keyword">unsigned</span> <span class="keyword">char</span>* tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x-&gt;isLeaf()) &#123;</span><br><span class="line">tree[count] = <span class="number">1</span>; count++;</span><br><span class="line">tree[count] = x-&gt;ch;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree[count] = <span class="number">0</span>; count++;</span><br><span class="line">writeTree(x-&gt;left, count, tree);</span><br><span class="line">writeTree(x-&gt;right, count, tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(<span class="built_in">string</span> st[], Node* x, <span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x-&gt;isLeaf()) &#123;</span><br><span class="line">buildCode(st, x-&gt;left, s + <span class="string">"0"</span>);</span><br><span class="line">buildCode(st, x-&gt;right, s + <span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">st[x-&gt;ch] = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> freq[], <span class="keyword">int</span>&amp; outLeafNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小列队</span></span><br><span class="line">priority_queue&lt;Node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化多个将构成一颗Huffman树的结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>) pq.push(Node(i, freq[i], <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outLeafNum = pq.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// special case in case there is only one character with a nonzero frequency</span></span><br><span class="line"><span class="keyword">if</span> (pq.size() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (freq[<span class="string">'\0'</span>] == <span class="number">0</span>) pq.push(Node(<span class="string">'\0'</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line"><span class="keyword">else</span> pq.push(Node(<span class="string">'\1'</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并两个小树</span></span><br><span class="line"><span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">Node* left = <span class="keyword">new</span> Node(pq.top()); pq.pop();</span><br><span class="line">Node* right = <span class="keyword">new</span> Node(pq.top()); pq.pop();</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, left-&gt;freq + right-&gt;freq, left, right);<span class="comment">//创建连接子树的中间结点</span></span><br><span class="line">pq.push(*parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* root = <span class="keyword">new</span> Node(pq.top()); pq.pop();</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝图代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TArray&lt;uint8&gt; <span class="title">UBPFLibrary::HFM_Encode</span><span class="params">(TArray&lt;uint8&gt; indata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8* outdata = <span class="keyword">new</span> uint8[indata.Num()* <span class="number">3</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> outdatasize =<span class="number">0</span>;</span><br><span class="line">    Huffman::Encode(indata.GetData),indata.Numo,outdata, outdatasize);</span><br><span class="line">    TArray&lt;uint8&gt; outdatal;</span><br><span class="line">    outdata1.Init(o,outdatasize);</span><br><span class="line">    FMemory::Memcpy(outdata1.GetData(),outdata,outdatasize);</span><br><span class="line">    <span class="keyword">return</span> outdatal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt;UBPFLibrary::HFM_Decode(TArray&lt;uint8&gt; indata)</span><br><span class="line">&#123;</span><br><span class="line">    uint8* outdata = <span class="keyword">new</span> uint8[indata.Num)* <span class="number">3</span>]&#123; e &#125;;</span><br><span class="line">    <span class="keyword">int</span> outdatasize = <span class="number">0</span>;</span><br><span class="line">    Huffman::Decode(indata.GetData(),indata.Num(),outdata, outdatasize);</span><br><span class="line">    TArray&lt;uint8&gt;outdatal;</span><br><span class="line">    outdata1.Init(e,outdatasize);</span><br><span class="line">    FMemory::Memcpy(outdata1.GetData(),outdata,outdatasize);</span><br><span class="line">    <span class="keyword">return</span> outdatal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在UE4 中实现哈夫曼编码的本意是在网络数据传输的时候，进行数据包一定程度的数据压缩。但是实现完之后发现并无用武之地，一个是因为压缩的数据中还必须要包含编码表，对于高频、小数据包反而会增加数据的大小和增加编码解码的计算消耗。二是因为好多要传输的数据本身就是已经编码压缩过了，再次编码压缩已经没有效果了（比如UE4 的 RenderTarget 图像数据 和 VoiceData）。所以权当是一次代码练习吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于哈夫曼编码&quot;&gt;&lt;a href=&quot;#关于哈夫曼编码&quot; class=&quot;headerlink&quot; title=&quot;关于哈夫曼编码&quot;&gt;&lt;/a&gt;关于哈夫曼编码&lt;/h2&gt;&lt;p&gt;Huffman于1952年提出一种编码方法，该方法完全依据出现概率来构造异字头的平均长度最短的码字 。简单来说就是用最少的bit来表示出现频率最高的字符，生成一张编码对照表，解码的时候根据对照表依次还原就行。&lt;br&gt;比如 “aabccade”，其中总共有a、b、c、d、e 五个字符，a出现3次，c出现2次，b、d、e出现1次，&lt;br&gt;那么可以用0表示a，用1表示c，用10表示b，用11表示d，用100表示e。所以原字符就可以用&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-10&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来表示了。当然具体实现细节要更复杂一点，涉及到二叉树，前缀码等。&lt;/p&gt;
&lt;p&gt;好了，话不多说，上代码！&lt;br&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="编码" scheme="https://nkoo.top/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="哈夫曼" scheme="https://nkoo.top/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/"/>
    
  </entry>
  
  <entry>
    <title>C++ 智能指针</title>
    <link href="https://nkoo.top/2021/09/12/smartpointer01/"/>
    <id>https://nkoo.top/2021/09/12/smartpointer01/</id>
    <published>2021-09-12T03:56:23.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇不对智能指针的实现原理做详细研究，只讨论为什么要使用智能指针，以及使用规范和注意事项。</p></blockquote><h2 id="关于指针和智能指针"><a href="#关于指针和智能指针" class="headerlink" title="关于指针和智能指针"></a>关于指针和智能指针</h2><p>指针是一个变量，存储一块内存区域的地址。<br>指针指向一块内存，通过该指针可随意修改或者删除其中内容，那么我们可以说这个指针对这块内存具有所有权(ownership) 。</p><p>PS:通常说的指向一个对象的指针，严格意义上来说应该是指向一个对象所在内存的指针。指针可以说和对象本身是没关系的，只是对象的类型(class)更详细的描述这块内存区域存的是什么内容。</p><p>指针存在的意义:<br>1.访问特定内存中的数据<br>2.管理所拥有的内存，不再使用的内存要及时通知系统释放  </p><p>裸指针能满足以上的访问和管理内存的需求，但是存在缺陷:<br> <strong>多个指针可以指向同一块内存</strong><br>也就是意味着权限混乱，比如创建(new)多个指针指向同一块内存，但是每个指针使用完毕，都没有释放(delete)，从而导致内存泄露。<br>或者所有的指针只要自己使用完毕就去释放内存，势必会造成正在使用该内存的地方产生未知结果，或者重复释放(delete)同一块内存导致崩溃。</p><a id="more"></a> <p>案例一:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Entity* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// e 的生命周期有多长，在我使用过程中会被其他函数删除吗？</span></span><br><span class="line"><span class="comment">// 我用完了e，需要删除它吗？删除它会对其他引用e 的地方造成未知影响吗？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> Entity();</span><br><span class="line">e-&gt;dosomething();</span><br><span class="line">foo(e);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存泄露了，e 的内存没有被释放</span></span><br></pre></td></tr></table></figure></p><p>智能指针就是为了解决这些问题而出现的。<br><strong>意味着不再使用 new 和 delete。</strong></p><p>三种智能指针:<br>unique_ptr 独占指针<br>shared_ptr 共享指针<br>weak_ptr  弱指针  </p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>同一时刻只能有一个unique_ptr指针指向一块内存；<br>独占所有权，所有权可以转移，转移之后该指针不可使用；<br>离开作用域之时，指向的内存自动释放(默认使用delete操作符，用户可指定其他操作)。<br>（通过禁止拷贝语义、只有移动语义来实现）。<br>基本操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Entity() construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Entity() destruct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" Do something "</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Entity&gt; <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp_entity = make_unique&lt;Entity&gt;();</span><br><span class="line">    <span class="keyword">return</span> temp_entity; <span class="comment">// 转移所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;Entity&gt; entity_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    entity_-&gt;DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========enter scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Entity&gt; entity1 = make_unique&lt;Entity&gt;(); <span class="comment">//推荐用法创建唯一指针</span></span><br><span class="line"><span class="keyword">auto</span> entity2 = make_unique&lt;Entity&gt;(); <span class="comment">//推荐用法创建</span></span><br><span class="line"><span class="keyword">auto</span> entity3 = move(entity2); <span class="comment">// 转移所有权</span></span><br><span class="line">foo(move(entity3)); <span class="comment">// 转移所有权</span></span><br><span class="line">foo(bar());</span><br><span class="line"></span><br><span class="line">Entity* rawe = entity1.release(); <span class="comment">// 放弃所有权，并置为nullptr，不释放内存，返回对象的裸指针。请慎重操作</span></span><br><span class="line"><span class="keyword">delete</span> rawe;</span><br><span class="line"></span><br><span class="line">entity1.reset(<span class="comment">/* p */</span>); <span class="comment">// 释放内存，并置为nullptr。如果传入一个裸指针p作为参数，则释放内存后重新指向p。</span></span><br><span class="line">entity1 = <span class="literal">nullptr</span>; <span class="comment">// 释放内存，并置为nullptr。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave main scope========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用智能指针来实现文章开头的案例一<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;Entity&gt; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e-&gt;DoSomething();</span><br><span class="line"><span class="comment">// e 离开作用域会自动释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = make_unique&lt;Entity&gt;(); <span class="comment">// 创建智能指针</span></span><br><span class="line">e-&gt;dosomething();</span><br><span class="line">foo(move(e));  <span class="comment">// 转移所有权</span></span><br><span class="line"><span class="comment">// e 的权限被转移，以下不可以使用e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 没有内存泄露</span></span><br></pre></td></tr></table></figure></p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个shared_ptr指向同一块内存，当所有shared_ptr都全部释放时，该内存释放。每个shared_ptr都对这块内存有所有权。<br>简单实现原理:<br>一个对象被shared_ptr指针引用的次数，由一个计数对象来记录。每次复制一个shared_ptr，计数+1，每次释放(主动调用或者离开作用域时)一个shared_ptr，计数-1，当计数为0时，释放该对象所在内存。<br>基本操作:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">Entity(<span class="keyword">int</span> id_)</span><br><span class="line">&#123;</span><br><span class="line">id=id_;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Entity(id"</span>&lt;&lt; id &lt;&lt;<span class="string">") construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Entity(id"</span>&lt;&lt; id &lt;&lt;<span class="string">") destruct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" Do something "</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp_entity = make_shared&lt;Entity&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> temp_entity; <span class="comment">// 移动所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Entity&gt; entity_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"entity"</span>&lt;&lt; entity_-&gt;getId() &lt;&lt;<span class="string">"转移所有权到函数后计数"</span>&lt;&lt; entity_.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    entity_-&gt;DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========enter scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Entity&gt; entity0 = make_shared&lt;Entity&gt;(<span class="number">0</span>); <span class="comment">//推荐用法创建共享指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> entity1 = make_shared&lt;Entity&gt;(<span class="number">1</span>); <span class="comment">//推荐用法创建</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1创建赋值后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> entity2 = entity1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1复制赋值后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> entity3 = move(entity2); <span class="comment">// 移动所有权</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1转移所有权后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">foo(move(entity3)); <span class="comment">// 移动所有权</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1离开函数作用域后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">foo(bar());</span><br><span class="line"></span><br><span class="line">entity1.reset(<span class="comment">/* p */</span>); <span class="comment">// 释放内存，并置为nullptr。如果传入一个裸指针p作为参数，则释放内存后重新指向p。</span></span><br><span class="line">entity1 = <span class="literal">nullptr</span>; <span class="comment">// 释放内存，并置为nullptr。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave main scope========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 只能和shared_ptr搭配使用的。<br>弱指针的弱是相对于shared_ptr和unique_ptr对对象的所有权来说的。shared_ptr和unique_ptr的所有权关乎所指对象的生死(销毁)。<br>weak_ptr只是提供一种访问对象的途径，没有对对象的所有权。通俗点可以说先用weak_ptr占个坑位，但并不能直接使用它。<br>使用之前先检查所指向的对象是否已经销毁( expired() )，如果没销毁就通过调用weak_ptr.lock()获得一个shared_ptr同时对象的引用计数+1。<br>至于weak_ptr，有几个关键词，循环引用，多线程保活，比较复杂，但是又不是很常用，所以打算另写一篇来记录。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于指针到底指向什么？<br>指针就是一块内存区域的地址，所以可以说指向一块内存区域是没问题的。<br>但是有的时候又希望表述为指向一个对象（c++ 中一切皆对象），可以说指向一个空对象，可以说指向的对象被销毁了。我觉得都没问题，因为指针虽然是一个地址，但是指针大部分情况是带着类型信息的，就是用来描述所指向的内存中的数据的组织方式，类型信息决定了如何正确使用这块内存中的记录的一堆东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇不对智能指针的实现原理做详细研究，只讨论为什么要使用智能指针，以及使用规范和注意事项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于指针和智能指针&quot;&gt;&lt;a href=&quot;#关于指针和智能指针&quot; class=&quot;headerlink&quot; title=&quot;关于指针和智能指针&quot;&gt;&lt;/a&gt;关于指针和智能指针&lt;/h2&gt;&lt;p&gt;指针是一个变量，存储一块内存区域的地址。&lt;br&gt;指针指向一块内存，通过该指针可随意修改或者删除其中内容，那么我们可以说这个指针对这块内存具有所有权(ownership) 。&lt;/p&gt;
&lt;p&gt;PS:通常说的指向一个对象的指针，严格意义上来说应该是指向一个对象所在内存的指针。指针可以说和对象本身是没关系的，只是对象的类型(class)更详细的描述这块内存区域存的是什么内容。&lt;/p&gt;
&lt;p&gt;指针存在的意义:&lt;br&gt;1.访问特定内存中的数据&lt;br&gt;2.管理所拥有的内存，不再使用的内存要及时通知系统释放  &lt;/p&gt;
&lt;p&gt;裸指针能满足以上的访问和管理内存的需求，但是存在缺陷:&lt;br&gt; &lt;strong&gt;多个指针可以指向同一块内存&lt;/strong&gt;&lt;br&gt;也就是意味着权限混乱，比如创建(new)多个指针指向同一块内存，但是每个指针使用完毕，都没有释放(delete)，从而导致内存泄露。&lt;br&gt;或者所有的指针只要自己使用完毕就去释放内存，势必会造成正在使用该内存的地方产生未知结果，或者重复释放(delete)同一块内存导致崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://nkoo.top/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://nkoo.top/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>宏 Macro</title>
    <link href="https://nkoo.top/2021/09/05/macro/"/>
    <id>https://nkoo.top/2021/09/05/macro/</id>
    <published>2021-09-04T23:43:11.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇是关于宏定义的一些知识总结</p></blockquote><h3 id="1-预处理-preprocess"><a href="#1-预处理-preprocess" class="headerlink" title="1. 预处理 preprocess"></a>1. 预处理 preprocess</h3><p>根据程序中的预处理指令，预处理器把宏名替换成其表示的内容–宏展开（macro expansion）；<br>预处理器指令从#开始运行，到后面的第1个换行符为止(指用Enter按下的换行，而不是 \n)。即：指令的长度仅限于一行；<br>在预处理开始前，编译器会把多行物理行（physical line）处理为一行逻辑行（logical line）。即：找到反斜杠\后面的换行符，把反斜杠和换行符删掉<br>双引号字符串中的文本不会被宏替换！<br> <a id="more"></a></p><h3 id="2-宏定义常量和表达式"><a href="#2-宏定义常量和表达式" class="headerlink" title="2. 宏定义常量和表达式"></a>2. 宏定义常量和表达式</h3><p>宏定义只做简单的替换，不计算，不对表达式求值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14<span class="comment">// 定义常量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR (2*2)<span class="comment">// 定义表达式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIX (2 * 3)<span class="comment">// 不要求代码中用空格来分隔记号（token：2 * 3 代表三个token，2*3 是一个token）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIGHT (2 \</span></span><br><span class="line">*<span class="number">4</span>)<span class="comment">// 反斜杠扩展逻辑行</span></span><br></pre></td></tr></table></figure></p><p>关于 #define 和 const 定义常量</p><p>#define 定义的常量是直接替换，没有类型检查，而 const 有对应的数据类型，有类型检查  </p><p>#define 仅展开，不分配内存；const 会分配内存；#define 定义的常量占用代码段的内存，const 定义的常量占用数据段的内存</p><p>#define 可以通过 #undef 取消再重新定义，const 不能重定义。</p><blockquote><p>建议！！！只使用const常量而不使用宏常量。</p></blockquote><h3 id="3-在宏定义中使用参数"><a href="#3-在宏定义中使用参数" class="headerlink" title="3. 在宏定义中使用参数"></a>3. 在宏定义中使用参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVSQR(x) (1/((x)*(x))) <span class="comment">// 求x平方的倒数</span></span></span><br></pre></td></tr></table></figure><blockquote><p>建议！！！用()把所有的参数和整个替换体包裹起来<br>建议！！！不要在宏中使用递增或递减运算符(++,–)</p></blockquote><h4 id="3-1-运算符-，-，以及宏VA-ARGS"><a href="#3-1-运算符-，-，以及宏VA-ARGS" class="headerlink" title="3.1 运算符 #，##，以及宏VA_ARGS"></a>3.1 运算符 #，##，以及宏<strong>VA_ARGS</strong></h4><h5 id="3-1-1-把记号-token-转换成字符串"><a href="#3-1-1-把记号-token-转换成字符串" class="headerlink" title="3.1.1 # :把记号(token)转换成字符串"></a>3.1.1 # :把记号(token)转换成字符串</h5><p>例如，如果x是一个宏形参，那么#x就是转换为字符串”x”的形参名。这个过程称为字符串化（stringizing）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_ARG_NANE(x) printf(#x <span class="meta-string">"\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTSQR(x) printf(<span class="meta-string">"The square of "</span> #x <span class="meta-string">" is %d \n"</span>, ((x)*(x))) <span class="comment">// ANSI C字符串可以自动串联</span></span></span><br></pre></td></tr></table></figure></p><h5 id="3-1-2-连接运算符"><a href="#3-1-2-连接运算符" class="headerlink" title="3.1.2 ## :连接运算符"></a>3.1.2 ## :连接运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x##n <span class="comment">// 给传入的宏参数加上一个x前缀  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTXN(n) printf(<span class="meta-string">"x"</span> #n <span class="meta-string">" is %d \n"</span> , x##n) <span class="comment">// 注意其中的x就等于是你键盘敲入的一个x，不代表其他任何东西</span></span></span><br></pre></td></tr></table></figure><h5 id="3-1-3-VA-ARGS-宏"><a href="#3-1-3-VA-ARGS-宏" class="headerlink" title="3.1.3 __VA_ARGS__宏"></a>3.1.3 __VA_ARGS__宏</h5><p>__VA_ARGS__就是把…表示的参数包，原封不动的抄过去<br> … 表示可变的参数（variadic argument）,包括里面的逗号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变参数不可为空</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPRINT(...) \</span></span><br><span class="line">        <span class="built_in">printf</span>(__VA_ARGS__)</span><br></pre></td></tr></table></figure><p>如果可变参数为空，就会出现一个多余的逗号printf(,)会报错<br>“##”操作符如果一侧没有内容就会连接失败，并且删除两侧要连接的内容，此处就会删除这个多余的逗号<br>也可以给可变参数…起个名字，而不用__VA_ARGS__，使用方法和效果是完全一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(fomart, args...) \</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"debug: "</span> fomart, ##args)</span><br></pre></td></tr></table></figure><p>测试代码及结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; FOUR * (SIX + EIGHT) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 56</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; SIX / EIGHT &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; EIGHT &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"EIGHT"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// EIGHT 双引号字符串中的文本不会被宏替换</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; INVSQR(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; INVSQR(<span class="number">2.f</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> int_a = <span class="number">10</span>;</span><br><span class="line">    PRINT_ARG_NANE(int_a); <span class="comment">// int_a</span></span><br><span class="line">    PRINTSQR(int_a); <span class="comment">// The square of int_a is 100</span></span><br><span class="line">    PRINTSQR(<span class="number">4</span> + <span class="number">6</span>); <span class="comment">// The square of 4 + 6 is 100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">10</span>; <span class="comment">//  展开后：int x1 = 10;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">20</span>; <span class="comment">//  展开后：int x2 = 20;</span></span><br><span class="line">    <span class="keyword">int</span> x3 = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 20</span></span><br><span class="line">    PRINTXN(<span class="number">3</span>); <span class="comment">// x3 is 30</span></span><br><span class="line">    </span><br><span class="line">    MYPRINT(<span class="string">"a = %d \n"</span>, <span class="number">5</span>); <span class="comment">// a = 5</span></span><br><span class="line">    DEBUG(<span class="string">"a = %d \n"</span>, <span class="number">5</span>); <span class="comment">// debug: a = 5</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他<br>预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma<br>关键字：_Generic、_Noreturn、_Static_assert<br>函数/宏：sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_copy()、va_end()</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇是关于宏定义的一些知识总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-预处理-preprocess&quot;&gt;&lt;a href=&quot;#1-预处理-preprocess&quot; class=&quot;headerlink&quot; title=&quot;1. 预处理 preprocess&quot;&gt;&lt;/a&gt;1. 预处理 preprocess&lt;/h3&gt;&lt;p&gt;根据程序中的预处理指令，预处理器把宏名替换成其表示的内容–宏展开（macro expansion）；&lt;br&gt;预处理器指令从#开始运行，到后面的第1个换行符为止(指用Enter按下的换行，而不是 \n)。即：指令的长度仅限于一行；&lt;br&gt;在预处理开始前，编译器会把多行物理行（physical line）处理为一行逻辑行（logical line）。即：找到反斜杠\后面的换行符，把反斜杠和换行符删掉&lt;br&gt;双引号字符串中的文本不会被宏替换！&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://nkoo.top/categories/C-C/"/>
    
    
      <category term="宏" scheme="https://nkoo.top/tags/%E5%AE%8F/"/>
    
      <category term="macro" scheme="https://nkoo.top/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Working with git and ssh</title>
    <link href="https://nkoo.top/2021/08/29/git-ssh/"/>
    <id>https://nkoo.top/2021/08/29/git-ssh/</id>
    <published>2021-08-29T01:26:22.000Z</published>
    <updated>2022-10-08T09:54:45.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>从2021年8月14日之后，使用git对github进行身份验证操作的时候不再接受使用账号密码形式clone和push代码，必须使用acces_token或者基于SSH 的方式了。本文记录SSH 的使用过程。</p></blockquote><h3 id="一、生成shh密钥"><a href="#一、生成shh密钥" class="headerlink" title="一、生成shh密钥"></a>一、生成shh密钥</h3><p>进入 .ssh 目录，windows下一般在默认用户文件夹下 <code>Users/Administrator/.ssh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\Administrator\.ssh</span><br><span class="line"></span><br><span class="line">ssh -V <span class="comment"># 查看版本号，确认是否安装ssh</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"email@abc.com"</span> <span class="comment"># 生成ssh密钥</span></span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_pubrepo <span class="comment"># 此处输入密钥的名称，方便后面管理多个密钥</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="comment"># 回车</span></span><br><span class="line">Enter same passphrase again:<span class="comment"># 回车</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> id_rsa_pubrepo.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> id_rsa_pubrepo.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:xxxxxxxxxxxxx email@abc.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|     .   . .     |</span></span><br><span class="line"><span class="string">|    o =   oo.    |</span></span><br><span class="line"><span class="string">|     . ..*+. .   |</span></span><br><span class="line"><span class="string">|    .  .o.B.*    |</span></span><br><span class="line"><span class="string">|    . *.E=o      |</span></span><br><span class="line"><span class="string">|     ..+*B=      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><a id="more"></a> <h3 id="二、将公钥部署到github"><a href="#二、将公钥部署到github" class="headerlink" title="二、将公钥部署到github"></a>二、将公钥部署到github</h3><p>查看并复制公钥内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa_pubrepo.pub <span class="comment"># 查看公钥，注意是.pub后缀的文件</span></span><br><span class="line"></span><br><span class="line">cat id_rsa_pubrepo.pub | clip <span class="comment"># windows下复制文件内容到剪贴板</span></span><br></pre></td></tr></table></figure><p>登录github，点击头像；</p><p>在Settings -&gt; SSH and GPG keys 设置项中；</p><p>点击New SSH key，粘贴刚才复制的内容(“ ssh-rsa AAA…..= ”)，并输入名称。</p><p>至此，你就可以clone和push该github账户下的所有的仓库内容了。</p><blockquote><p>PS：远程地址一定要用ssh地址 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:XXX/XXX.git ，而不是HTTPS地址。</p></blockquote><h3 id="三、管理多个ssh密钥"><a href="#三、管理多个ssh密钥" class="headerlink" title="三、管理多个ssh密钥"></a>三、管理多个ssh密钥</h3><h4 id="1、多个ssh部署到多个github账户"><a href="#1、多个ssh部署到多个github账户" class="headerlink" title="1、多个ssh部署到多个github账户"></a>1、多个ssh部署到多个github账户</h4><p>因为每个ssh key只能在github上部署一次，如果我们要管理多个github账号，那么就必须生成多个 ssh key，并且用 config 来管理，这样在进行仓库操作的时候，git才知道该使用那么key。</p><p>假如我们有两个 github账号：Account01，Account02；</p><p>首先创建两个 ssh key：id_rsa_mykey01，id_rsa_mykey02</p><p>在 .ssh 目录下创建 config 文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为每个ssh key配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可</span></span><br><span class="line"><span class="comment"># Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如：</span></span><br><span class="line"><span class="comment"># Host mygithub 这样定义的话，命令如下，即git@后面紧跟的名字改为mygithub</span></span><br><span class="line"><span class="comment"># git clone git@mygithub:PopFisher/AndroidRotateAnim.git</span></span><br><span class="line"><span class="comment"># HostName 　　　　　　　   这个是真实的域名地址</span></span><br><span class="line"><span class="comment"># IdentityFile 　　　　　　　  这里是id_rsa的地址，  # 可以指定特定的ssh私钥文件</span></span><br><span class="line"><span class="comment"># PreferredAuthentications   配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等</span></span><br><span class="line"><span class="comment"># User 　　　　　　　　　　　配置使用用户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Host01</span></span><br><span class="line">Host Host01</span><br><span class="line">  HostName github.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_mykey01</span><br><span class="line"></span><br><span class="line"><span class="comment"># Host02</span></span><br><span class="line">Host Host02</span><br><span class="line">  HostName github.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_mykey02</span><br></pre></td></tr></table></figure><p>以上我们配置了2个 Host：</p><p>host01 对应 id_rsa_mykey01 ，id_rsa_mykey01.pub 配置到github 的账号 Account01的 SSH and GPG keys  中；</p><p>host02 对应 id_rsa_mykey02 ，id_rsa_mykey02.pub 配置到github 的账号 Account02的 SSH and GPG keys  中。</p><p>假如我们 clone  Account01 的 mydemo 项目，我们会得到克隆地址  <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Account01/mydemo.git ,不能直接使用，需要把改为 git@Host01:Account01/mydemo.git ，也就是说我们的git项目的远程HostName，以及认证文件的配置采用.ssh  config 中的Host01，账号Account02的项目同理。</p><p>至此，我们在同一台电脑上，用多个ssh key 分别管理了多个github 账号中的仓库文件。</p><h4 id="2、为单个repository部署Deploy-key"><a href="#2、为单个repository部署Deploy-key" class="headerlink" title="2、为单个repository部署Deploy key"></a>2、为单个repository部署Deploy key</h4><p>有的项目是小组多人协同开发的，同一个github下有多个项目，那么如何给每一个仓库设置单独的ssh key呢？</p><p>我们需要配置 Deploy keys。</p><p>打开仓库的 Settings （不同与账户的 Setting），在Deploy keys 设置项中点击 add deploy key 添加。</p><p>至此，我们的账户中配置了 ssh key，用该 key 配对的私钥，可以操作该账户下的所有的仓库的代码。</p><p>而仓库单独设置的 Deploy key 对于的私钥，只能访问和操作该仓库，对其他仓库没有权限。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>github已经不再接受使用账号密码形式。</p><p>ssh key配置方法可以免登录账号密码。</p><p>多个ssh key，需要用config 来配置。</p><p>账户中配置的 ssh key，可以操作该账户下的所有的仓库的代码。</p><p>仓库的 Deploy key 只能操作该仓库。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;从2021年8月14日之后，使用git对github进行身份验证操作的时候不再接受使用账号密码形式clone和push代码，必须使用acces_token或者基于SSH 的方式了。本文记录SSH 的使用过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、生成shh密钥&quot;&gt;&lt;a href=&quot;#一、生成shh密钥&quot; class=&quot;headerlink&quot; title=&quot;一、生成shh密钥&quot;&gt;&lt;/a&gt;一、生成shh密钥&lt;/h3&gt;&lt;p&gt;进入 .ssh 目录，windows下一般在默认用户文件夹下 &lt;code&gt;Users/Administrator/.ssh&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; C:\Users\Administrator\.ssh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -V &lt;span class=&quot;comment&quot;&gt;# 查看版本号，确认是否安装ssh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -C &lt;span class=&quot;string&quot;&gt;&quot;email@abc.com&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 生成ssh密钥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Generating public/private rsa key pair.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter file &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_pubrepo &lt;span class=&quot;comment&quot;&gt;# 此处输入密钥的名称，方便后面管理多个密钥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter passphrase (empty &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; no passphrase):&lt;span class=&quot;comment&quot;&gt;# 回车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter same passphrase again:&lt;span class=&quot;comment&quot;&gt;# 回车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your identification has been saved &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; id_rsa_pubrepo.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your public key has been saved &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; id_rsa_pubrepo.pub.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key fingerprint is:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SHA256:xxxxxxxxxxxxx email@abc.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key&lt;span class=&quot;string&quot;&gt;&#39;s randomart image is:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;+---[RSA 3072]----+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|     .   . .     |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|    o =   oo.    |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|     . ..*+. .   |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|    .  .o.B.*    |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|    . *.E=o      |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|     ..+*B=      |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;+----[SHA256]-----+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="git" scheme="https://nkoo.top/categories/git/"/>
    
    
      <category term="ssh" scheme="https://nkoo.top/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Garbage Collection in UE4</title>
    <link href="https://nkoo.top/2021/08/23/ue4%20GC/"/>
    <id>https://nkoo.top/2021/08/23/ue4 GC/</id>
    <published>2021-08-23T15:42:03.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>UE4 C++ 不同于原生的C++, UE内置了GC系统。对于有些人来说，GC帮我们处理了弃用的对象，防止了内存泄漏，确实是一件令人愉快的事情。然后有的时候，如果不了解GC规则，可能会给开发带来大麻烦。</p></blockquote><h3 id="什么对象会被GC-系统处理？"><a href="#什么对象会被GC-系统处理？" class="headerlink" title="什么对象会被GC 系统处理？"></a>什么对象会被GC 系统处理？</h3><p>GC主要思想很简单——要让 GC系统 相信对象是多余的并删除它，必须满足以下几个条件：</p><ul><li><p>这个对象不再被UE 的反射系统引用。</p></li><li><p>指向对象的指针没有被保存在容器中。</p></li><li><p>对象在其作用域内没有被强指针指向，比如<a href="or just plainly [strong pointers]">shared pointers, shared references, unique pointers</a> </p></li><li><p>创建对象的代码块经结束执行(离开作用域)</p></li><li><p>对象没有添加到根节点 AddToRoot()  </p></li><li><p>对象必须是继承自Uobject</p></li></ul><p>有一个要特殊注意的例外，我们可以显式地将UObject派生的类对象标记为销毁。</p><a id="more"></a> <h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>场景中的 Actor 和 Actor 组件，被他们的父对象引用（比如 level 本身）。在场景中生成的actor，不需要特殊的GC 考虑</li><li>当一个新的关卡或者地图加载的时候，引擎将销毁world 并且创建一个新的world， 所有旧场景中的对象将被垃圾回收，包括GM GS,以及它们引用或指针指向的所有内容（假设这是指向对象的唯一引用或指针）。</li><li>并不是所有的不可用对象的指针都等于nullptr，因为如果一个对象被标记为销毁或者没有被正确初始化，那么它的指针可能不是nullptr。因此要养成用IsValid（）来判断对象是否可用的习惯。</li><li>任何对象类如果不是继承自UObject 将不会被GC回收，也就是我们创建的对象类最好是UE 已经存在的类，至少也应该继承自 UObject.</li></ul><h3 id="GC对象树"><a href="#GC对象树" class="headerlink" title="GC对象树"></a>GC对象树</h3><p>到目前为止，我们已经讨论了UE引擎的GC规则和原理，那么它在技术上是如何实现的呢？</p><p>UE引擎维护了一张所有对象的树状图，在树的最根部节点是永远不会被回收的。</p><p>每当需要GC时，引擎将从根集合开始，并通过[反射系统]查看它们引用和指向的对象(<a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)或容器类。任何指向或引用的内容都将添加到“不可触及”列表。然后，它将检查新添加的对象指向或引用的对象，并将所有这些对象也添加到树中。通过这种方式沿着树移动，垃圾收集系统最终会构建一个所有不可接触对象的列表，并删除所有其他对象。" target="_blank" rel="noopener">https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)或容器类。任何指向或引用的内容都将添加到“不可触及”列表。然后，它将检查新添加的对象指向或引用的对象，并将所有这些对象也添加到树中。通过这种方式沿着树移动，垃圾收集系统最终会构建一个所有不可接触对象的列表，并删除所有其他对象。</a></p><p><img src="/images/gc.webp" alt="img" style="zoom:75%;"></p><p>如果一个对象可以通过引擎的属性系统指针追溯到根集，它将不会被垃圾收集。一旦这些与根集的联系被切断，对象将被GC掉。</p><h2 id="Slate-UI"><a href="#Slate-UI" class="headerlink" title="Slate UI"></a>Slate UI</h2><p>需要注意的是Slate UI 是不太适用之前的GC 规则，从4.25开始，它不使用强指针来保持用户界面中使用的对象（通常是uasset）。这意味着如果一个对象被Slate UI引用，但是不再被其他对象引用，那么GC将无情地删除它。而且，当它使用的对象被GC时，Slate UI可能会使程序崩溃。</p><p>为了处理这一问题，请确保传递给Slate UI的每个对象都已受到严格保护，不受垃圾收集的影响。如有必要，可以使用显式强指针，但通常这将通过属性系统完成。例如，可以在垃圾收集图的根集中创建一个新对象，并让它保存与Slate UI小部件相对应的其他对象数组。这些对象将指向Slate UI使用的资源对象。每个专用于自己的Slate UI小部件的对象都可能在小部件启动后被销毁。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>有时我们的代码中有一个问题可能是由垃圾收集引起的，但我们还不能确定。这很可能是一个对象初始化问题，也可能是一系列其他问题。</p><p>我们可以使用断言在代码执行的任何阶段测试对象是否有效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">checkf(IsValid(Object), TEXT(<span class="string">" object is invalid !"</span>));</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"> check(IsValid(Object));</span><br></pre></td></tr></table></figure><p>###　正确示例</p><p>第一个很好的习惯用法是在容器类（如TArray）中使用或者用UPROPERTY（）声明指针。</p><p>一旦不再有“父”对象以这种方式指向“子”对象，“子”对象才能销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中的声明</span></span><br><span class="line"></span><br><span class="line">UPROPERTY()</span><br><span class="line"></span><br><span class="line">UMyCustomClass * MyPointer;</span><br><span class="line"></span><br><span class="line">UPROPERTY()</span><br><span class="line"></span><br><span class="line">UTexture2D * MyTexture;</span><br><span class="line"></span><br><span class="line">UPROPERTY()</span><br><span class="line"></span><br><span class="line">TArray&lt;UStaticMesh*&gt; MyArrayOfMeshes;</span><br></pre></td></tr></table></figure><p>我们可以自由地从多个其他对象指向同一对象。只要至少有一个活动对象使用属性系统指向它，它就不会被垃圾收集。</p><p>“临时对象”会在作用域结束执行后进行垃圾收集。</p><p>下面是一段功能代码，它临时创建一个新对象，以从场景捕获组件捕获图片并将其存储到像素颜色数组中。</p><p>此范围结束后，TextureEnderTarget　本身将被GC适当地清除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 部分定义在 ASceneCapture2D-derived class　中的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint16 Resolution = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line">UTextureRenderTarget2D * TextureRenderTarget = NewObject&lt;UTextureRenderTarget2D &gt;();</span><br><span class="line"></span><br><span class="line">USceneCaptureComponent2D* SCC2D = GetCaptureComponent2D();</span><br><span class="line"></span><br><span class="line">TextureRenderTarget-&gt;InitCustomFormat(Resolution,Resolution,PF_B8G8R8A8,**<span class="literal">false</span>**);</span><br><span class="line"></span><br><span class="line">SCC2D-&gt;TextureTarget = TextureRenderTarget;</span><br><span class="line"></span><br><span class="line">SCC2D-&gt;CaptureScene();</span><br><span class="line"></span><br><span class="line">TArray&lt;FColor&gt; RawPixels;</span><br><span class="line"></span><br><span class="line">RawPixels.Reserve(Resolution * Resolution);</span><br><span class="line"></span><br><span class="line">TextureRenderTarget-&gt;GameThread_GetRenderTargetResource()-&gt;ReadPixels(RawPixels);</span><br><span class="line"></span><br><span class="line">RawPixels.Shrink();</span><br></pre></td></tr></table></figure><h3 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h3><p>两个坏习惯：</p><p>1、是将所有对象都 AddToRoot（）</p><p>2、创建不符合上述GC规则的对象，但是又没有被及时的删除</p><p>有时在函数定义的范围内使用新指针创建对象，并将其指针返回（返回临时对象了）。有时，甚至大多数时候，它可能会起作用。</p><p>还有一个个坏习惯——过度依赖nullptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="keyword">if</span>**(ObjectPointer) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来非常方便，但即使对象未初始化或标记为kill，ObjectPointer的计算结果也将为true。如果要使用对象，最好使用　IsValid（ObjectPointer）来判断。</p><p>###　总结</p><p>总而言之，GC 系统是UE引擎使得代码强健的一部分，有效避免了内存泄漏。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;UE4 C++ 不同于原生的C++, UE内置了GC系统。对于有些人来说，GC帮我们处理了弃用的对象，防止了内存泄漏，确实是一件令人愉快的事情。然后有的时候，如果不了解GC规则，可能会给开发带来大麻烦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么对象会被GC-系统处理？&quot;&gt;&lt;a href=&quot;#什么对象会被GC-系统处理？&quot; class=&quot;headerlink&quot; title=&quot;什么对象会被GC 系统处理？&quot;&gt;&lt;/a&gt;什么对象会被GC 系统处理？&lt;/h3&gt;&lt;p&gt;GC主要思想很简单——要让 GC系统 相信对象是多余的并删除它，必须满足以下几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这个对象不再被UE 的反射系统引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指向对象的指针没有被保存在容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象在其作用域内没有被强指针指向，比如&lt;a href=&quot;or just plainly [strong pointers]&quot;&gt;shared pointers, shared references, unique pointers&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建对象的代码块经结束执行(离开作用域)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象没有添加到根节点 AddToRoot()  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象必须是继承自Uobject&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一个要特殊注意的例外，我们可以显式地将UObject派生的类对象标记为销毁。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="GC" scheme="https://nkoo.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>UE4 数据压缩方法(三)</title>
    <link href="https://nkoo.top/2020/11/20/UE4-dataCompress03/"/>
    <id>https://nkoo.top/2020/11/20/UE4-dataCompress03/</id>
    <published>2020-11-20T14:44:23.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>之前我们压缩了整数<a href="/2020/11/19/UE4-dataCompress/">（压缩方法一）</a>，Angle角度浮点数<a href="/2020/11/20/UE4-dataCompress02/">（压缩方法二）</a>，那么用来同步位置的FVector是否也可以压缩呢？<br>整数压缩部分是用编码解压实现的，属于无损压缩，Angle角度浮点数是用一个小范围的数据集来表示一个大范围的数据集，属于有损压缩。那么我们可能会问，如果同步的数据不一致，对于不同客户端的计算或者显示结果是否会有影响呢？比如一个游戏中，一个玩家在不同的客户端上的位置和方向存在较大的差异，那肯定是不行的。</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>本次我的思路是对于特定情况下的一些数据压缩提供一种思路。比如我们的一个多人在线应用，用户的活动范围被限制在一定的范围内，也就是玩家的位置坐标的最大值能用更短的整数来存储。那么我们就有压缩的空间了。</p><a id="more"></a> <h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用短整形表示的坐标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FShortLoc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">int16 X;</span><br><span class="line">int16 Y;</span><br><span class="line">int16 Z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩位置信息 -3275 -&gt; +3275</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE FShortLoc <span class="title">LocDataCom</span><span class="params">(FVector Loc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FShortLoc a;</span><br><span class="line">a.X = CompFloatTo16Bit_(Loc.X);</span><br><span class="line">a.Y = CompFloatTo16Bit_(Loc.Y);</span><br><span class="line">a.Z = CompFloatTo16Bit_(Loc.Z);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压缩位置信息 -3275 -&gt; +3275</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE FVector <span class="title">LocDataDec</span><span class="params">(FShortLoc source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FVector a;</span><br><span class="line">a.X = DecomFloatTo16Bit_(source.X);</span><br><span class="line">a.Y = DecomFloatTo16Bit_(source.Y);</span><br><span class="line">a.Z = DecomFloatTo16Bit_(source.Z);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE int16 <span class="title">CompFloatTo16Bit_</span><span class="params">(<span class="keyword">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// -3276.7 -&gt; +3276.7</span></span><br><span class="line">int16 a = value * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE <span class="keyword">float</span> <span class="title">DecomFloatTo16Bit_</span><span class="params">(int16 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// -3276.7 -&gt; +3276.7</span></span><br><span class="line"><span class="keyword">return</span> (value / <span class="number">10.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上代码我们把坐标的范围控制在了 -3275.0 -&gt; +3275.0 ,并且保留了一位小数点。对于位置精度不高，玩家获得范围不超过半径为32.75米的圆形区域（约3,367.8㎡）内的情况下，这种数据压缩节约了1/2的带宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;之前我们压缩了整数&lt;a href=&quot;/2020/11/19/UE4-dataCompress/&quot;&gt;（压缩方法一）&lt;/a&gt;，Angle角度浮点数&lt;a href=&quot;/2020/11/20/UE4-dataCompress02/&quot;&gt;（压缩方法二）&lt;/a&gt;，那么用来同步位置的FVector是否也可以压缩呢？&lt;br&gt;整数压缩部分是用编码解压实现的，属于无损压缩，Angle角度浮点数是用一个小范围的数据集来表示一个大范围的数据集，属于有损压缩。那么我们可能会问，如果同步的数据不一致，对于不同客户端的计算或者显示结果是否会有影响呢？比如一个游戏中，一个玩家在不同的客户端上的位置和方向存在较大的差异，那肯定是不行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;本次我的思路是对于特定情况下的一些数据压缩提供一种思路。比如我们的一个多人在线应用，用户的活动范围被限制在一定的范围内，也就是玩家的位置坐标的最大值能用更短的整数来存储。那么我们就有压缩的空间了。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="压缩" scheme="https://nkoo.top/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="编码" scheme="https://nkoo.top/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="FVector" scheme="https://nkoo.top/tags/FVector/"/>
    
  </entry>
  
  <entry>
    <title>UE4 数据压缩方法(二)</title>
    <link href="https://nkoo.top/2020/11/20/UE4-dataCompress02/"/>
    <id>https://nkoo.top/2020/11/20/UE4-dataCompress02/</id>
    <published>2020-11-20T00:16:20.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在之前的<a href="/2020/11/19/UE4-dataCompress/">压缩方法一</a>里面我们把表示状态的数据编码到uint32的每个bit上，进行网络传输后再解码出来，以达到压缩数据，节省带宽的效果。这次我们尝试把UE4中的Rotator数据也进行压缩。</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>UE中的Rotator本质上就是一个结构体，其中有三个float，那么传输一个Rotator要占用12个字节。<br>但是可以发现Rotator就是表示三个轴的旋转角度，而角度的范围是0 - 360.0，远小于float可以表示的范围，那么我们的目标就变成了如何用更小的数据量来传递0 - 360.0 了。<br>根据压缩精度不同，本文提供2种压缩方法，均为有损压缩。</p><a id="more"></a> <h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p>其实UE 的 Actor 移动同步中已经有一些对数据进行量化（Quantization）的设置了。</p><p>量化的意思就是把某个数值范围映射（Map）到另一个数值范围。</p><p><img src="/images/image-20210818221744775.webp" alt="image-20210818221744775"></p><p>我把源码翻出来了，需要的话自己封装一下，就可以用啦！</p><p>Runtime\Core\Public\Math\Rotator.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩一个float的角度值为一个byte.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 要压缩的角度.</span></span><br><span class="line"><span class="comment"> * @return 压缩后的角度byte值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8 <span class="title">CompressAxisToByte</span><span class="params">( <span class="keyword">float</span> Angle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个byte的角度值到解压为一个float.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 角度byte值.</span></span><br><span class="line"><span class="comment"> * @return 解压后的角度.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">DecompressAxisFromByte</span><span class="params">( uint8 Angle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩一个float的角度值为一个uint16.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 要压缩的角度.</span></span><br><span class="line"><span class="comment"> * @return 压缩后的角度uint16值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint16 <span class="title">CompressAxisToShort</span><span class="params">( <span class="keyword">float</span> Angle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个uint16的角度值到解压为一个float.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 角度uint16值.</span></span><br><span class="line"><span class="comment"> * @return 解压后的角度.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">DecompressAxisFromShort</span><span class="params">( uint16 Angle )</span></span>;</span><br></pre></td></tr></table></figure><p>Rotator.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE uint8 <span class="title">FRotator::CompressAxisToByte</span><span class="params">( <span class="keyword">float</span> Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 映射 [0-&gt;360) 到 [0-&gt;256) and mask off any winding</span></span><br><span class="line"><span class="keyword">return</span> FMath::RoundToInt(Angle * <span class="number">256.f</span> / <span class="number">360.f</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">float</span> <span class="title">FRotator::DecompressAxisFromByte</span><span class="params">( uint8 Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map [0-&gt;256) to [0-&gt;360)</span></span><br><span class="line"><span class="keyword">return</span> (Angle * <span class="number">360.f</span> / <span class="number">256.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE uint16 <span class="title">FRotator::CompressAxisToShort</span><span class="params">( <span class="keyword">float</span> Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map [0-&gt;360) to [0-&gt;65536) and mask off any winding</span></span><br><span class="line"><span class="keyword">return</span> FMath::RoundToInt(Angle * <span class="number">65536.f</span> / <span class="number">360.f</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">float</span> <span class="title">FRotator::DecompressAxisFromShort</span><span class="params">( uint16 Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map [0-&gt;65536) to [0-&gt;360)</span></span><br><span class="line"><span class="keyword">return</span> (Angle * <span class="number">360.f</span> / <span class="number">65536.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>UE 中有很多优秀的源码的，多读源码可以少造轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在之前的&lt;a href=&quot;/2020/11/19/UE4-dataCompress/&quot;&gt;压缩方法一&lt;/a&gt;里面我们把表示状态的数据编码到uint32的每个bit上，进行网络传输后再解码出来，以达到压缩数据，节省带宽的效果。这次我们尝试把UE4中的Rotator数据也进行压缩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;UE中的Rotator本质上就是一个结构体，其中有三个float，那么传输一个Rotator要占用12个字节。&lt;br&gt;但是可以发现Rotator就是表示三个轴的旋转角度，而角度的范围是0 - 360.0，远小于float可以表示的范围，那么我们的目标就变成了如何用更小的数据量来传递0 - 360.0 了。&lt;br&gt;根据压缩精度不同，本文提供2种压缩方法，均为有损压缩。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="压缩" scheme="https://nkoo.top/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="编码" scheme="https://nkoo.top/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="Rotator" scheme="https://nkoo.top/tags/Rotator/"/>
    
  </entry>
  
  <entry>
    <title>UE4 数据压缩方法(一)</title>
    <link href="https://nkoo.top/2020/11/19/UE4-dataCompress/"/>
    <id>https://nkoo.top/2020/11/19/UE4-dataCompress/</id>
    <published>2020-11-19T00:42:11.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>对于一个多人实时在线系统，数据同步是关键环节，在相同的网络环境下，数据量决定了同时在线用户量体，数据量也会影响网络延迟和加载时间。所以承载数据的网络带宽是珍贵且昂贵的，所以要在网络数据同步环节细扣每一个 bit !</p></blockquote><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>一个用户有16个设备，每个设备有三种状态: 0 未连接，1 连接异常，2 连接正常。需要用最小的数据量来同步这16个设备的连接状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DeviceState</span><br><span class="line">&#123;</span><br><span class="line">Connected,</span><br><span class="line">Abnormal,</span><br><span class="line">Normal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>每个 bit 有 0 和 1 两种状态，那么至少需要用2个 bit 来表示三种状态，16个设备需要32个 bit。<br>可以把这8个属性编码到一个 uint32 的整数中，前16位分别表示是否连接，后16位分别表示连接是否正常。  </p><a id="more"></a> <h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>这里涉及到整数每个位的操作，我们先在蓝图函数库中写几个位操作的函数，同时暴露给蓝图。  </p><p>MyBPFLibrary.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyBPFLibrary.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 source 第 index 位设置为 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETBIT(souce, index) souce |= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 把 source 第 index 位设置为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEARBIT(souce, index) souce &amp;= ~(1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 把 source 第 index 位取反</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVERSEBIT(souce, index) souce ^= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 获取 source 第 index 位的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETBIT(souce, index) ((souce) &gt;&gt; (index) &amp; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYPROJECT_API</span> <span class="title">UMyBPFLibrary</span> :</span> <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置一个 int32 的每一个位的值 0 or 1</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param source 输入值</span></span><br><span class="line"><span class="comment">* @param index 第几位</span></span><br><span class="line"><span class="comment">* @param value 要设置的值 0 or 1</span></span><br><span class="line"><span class="comment">* @return 修改后的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UFUNCTION(BlueprintPure, BlueprintCallable, Category = <span class="string">"Bitwise"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE int32 <span class="title">SetBitValue</span><span class="params">(int32 source, <span class="keyword">const</span> int32 index, <span class="keyword">const</span> uint8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value ? SETBIT(source, index) : CLEARBIT(source, index) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取一个 int32 的某位的值 0 or 1</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param source 输入值</span></span><br><span class="line"><span class="comment">* @param index 第几位</span></span><br><span class="line"><span class="comment">* @return 获取的值 0 or 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UFUNCTION(BlueprintPure, BlueprintCallable, Category = <span class="string">"Bitwise"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE uint8 <span class="title">GetBitValue</span><span class="params">(<span class="keyword">const</span> int32 source, <span class="keyword">const</span> int32 index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> GETBIT(source, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20210817233346631.webp" alt="image-20210817233346631"></p><h3 id="纯蓝图实现"><a href="#纯蓝图实现" class="headerlink" title="纯蓝图实现"></a>纯蓝图实现</h3><p>蓝图只支持 int32 的位运算，而且只有四种（ 与，或，非，异或）。所以实现起来稍微麻烦一点，执行效率未知。</p><p>因为涉及到求2的n次方，所以先写一个求n次方的函数：<br><img src="/images/image-20210818213329750.webp" alt="image-20210818213329750"></p><p>默认输入值设置为 2<br><img src="/images/image-20210818213524122.webp" alt="image-20210818213524122"></p><p>再写一个获取某一位的值：<br><img src="/images/image-20210818213651817.webp" alt="image-20210818213651817"></p><p>然后是设置某一位的值：<br><img src="/images/image-20210818213727555.webp" alt="image-20210818213727555"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上我们就通过C++ 和 蓝图分别实现了如何对一个整数的每一个位的0/1值进行编码，用来表示和传输一些属性的状态。接收到数据后再根据编码规则获得每个位的值所表示的状态。<br>设备的状态原来用 uint8 也就是8个 bit来存储，编码后只需要2个bit就可以了，数据量减少了3/4。在同步帧率较高的情况下，效果是显著的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;对于一个多人实时在线系统，数据同步是关键环节，在相同的网络环境下，数据量决定了同时在线用户量体，数据量也会影响网络延迟和加载时间。所以承载数据的网络带宽是珍贵且昂贵的，所以要在网络数据同步环节细扣每一个 bit !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;案例说明&quot;&gt;&lt;a href=&quot;#案例说明&quot; class=&quot;headerlink&quot; title=&quot;案例说明&quot;&gt;&lt;/a&gt;案例说明&lt;/h3&gt;&lt;p&gt;一个用户有16个设备，每个设备有三种状态: 0 未连接，1 连接异常，2 连接正常。需要用最小的数据量来同步这16个设备的连接状态。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; DeviceState&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Connected,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Abnormal,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Normal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;每个 bit 有 0 和 1 两种状态，那么至少需要用2个 bit 来表示三种状态，16个设备需要32个 bit。&lt;br&gt;可以把这8个属性编码到一个 uint32 的整数中，前16位分别表示是否连接，后16位分别表示连接是否正常。  &lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="压缩" scheme="https://nkoo.top/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="位运算" scheme="https://nkoo.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>UE4 Config配置文件的使用</title>
    <link href="https://nkoo.top/2020/11/17/UE4-Config/"/>
    <id>https://nkoo.top/2020/11/17/UE4-Config/</id>
    <published>2020-11-17T00:54:11.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇文章将简单介绍UE4 项目开发过程中, 如何使用配置文件来修改项目中的参数<br>我们知道在UE4项目的根目录下都会有一个 Config 的文件夹,里面有各种.ini 结尾的文件,这里面都是UE4 默认生成的一些配置文件. 今天我们要做的就是使用自己定义的.ini 文件,定义自己的 Config 变量, 并用这些变量来初始化 Class 中的定义的成员变量.</p><p>版本：UE4.25</p></blockquote><h4 id="1-关于打包后Config文件的位置"><a href="#1-关于打包后Config文件的位置" class="headerlink" title="1.关于打包后Config文件的位置"></a>1.关于打包后Config文件的位置</h4><p>如果采用Development 或者DebugGame 模式打包的话, Config 文件会生成在 <code>打包目录\项目名称\Saved\Config\WindowsNoEditor</code> 目录中, 但是如果用Shipping 模式打包的话, 会发现找不到这个目录了, 那么在Windows 系统下 我们可以在如下地址找到 <code>C:\Users\用户名\AppData\Local\项目名称\Saved\Config\WindowsNoEditor</code>.<br>接下来也会把我们自己的 Config 文件生成在指定的目录下,方便找到和修改.</p><h4 id="2-把成员变量设置为可用Config-配置"><a href="#2-把成员变量设置为可用Config-配置" class="headerlink" title="2. 把成员变量设置为可用Config 配置"></a>2. 把成员变量设置为可用Config 配置</h4><p>在UE4 c++ Class 变量的宏定义中, 加入 <code>config</code> 关键字<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否作为服务器启动</span></span><br><span class="line">UPROPERTY(config ,Category=<span class="string">"CustomIni"</span>)</span><br><span class="line"><span class="keyword">bool</span> bServer=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="3-定义-Config-目录"><a href="#3-定义-Config-目录" class="headerlink" title="3. 定义 Config 目录"></a>3. 定义 Config 目录</h4><p>在类的构造函数中可以定义 自己的 Config 目录, 这里定义为项目目录下的 Settings 文件夹, 配置文件的名称是 Custom.ini<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigPath = FPaths::ProjectDir() / TEXT(<span class="string">"Settings/Custom.ini"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="4-加载和保存-Config-配置"><a href="#4-加载和保存-Config-配置" class="headerlink" title="4. 加载和保存 Config 配置"></a>4. 加载和保存 Config 配置</h4><p>定义两个函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::LoadCustomConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GConfig-&gt;Flush(<span class="literal">true</span>, ConfigPath);</span><br><span class="line">ReloadConfig(<span class="keyword">this</span>-&gt;GetClass(), *ConfigPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::SaveCustomConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SaveConfig(CPF_Config, *ConfigPath);</span><br><span class="line">GConfig-&gt;Flush(<span class="literal">false</span>, ConfigPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在 void UMyGameInstance::Init() 中调用SaveCustomConfig();  (Actor 类可以在 BeginPlay  中 ) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::Init();</span><br><span class="line"></span><br><span class="line">bServer = <span class="literal">true</span>; <span class="comment">// bServer 默认为false, 而SaveCustomConfig() 函数只会把和默认值不一致的变量存入 Custom.ini中,所以此处先修改一下</span></span><br><span class="line">SaveCustomConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用 SaveCustomConfig()  的目的是为了在 <code>项目目录/Settings</code> 下生成 一个 Custom.ini.<br>Custom.ini 里面的 内容如下 <code>我为了测试方便是在蓝图中调用的</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Game/Blueprints/GameControl/BP_PTGameInstance.BP_PTGameInstance_C]</span><br><span class="line">bServer=true</span><br></pre></td></tr></table></figure></p><p>然后把保存的函数注释掉, 只保留加载函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bServer = true;</span></span><br><span class="line"><span class="comment">// SaveCustomConfig();</span></span><br><span class="line"></span><br><span class="line">LoadCustomConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用 LoadCustomConfig() 的目的是为了把 UMyGameInstance 中 bServer 这个变量的值设置为 Custom.ini 中的值. 名称是一一对应的.</p><p>这个就实现了, 无论是Development, Debug模式,还是Shipping 模式打包的项目, 都可以在 <code>项目目录/Settings</code>  下面设置 Custom.ini 中的变量, 设置的变量的值就会被设置为对应的变量的值.<br>对于同一个项目,需要不同自定义配置来启动的话,这将是一个很方面的方式.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇文章将简单介绍UE4 项目开发过程中, 如何使用配置文件来修改项目中的参数&lt;br&gt;我们知道在UE4项目的根目录下都会有一个 Config 的文件夹,里面有各种.ini 结尾的文件,这里面都是UE4 默认生成的一些配置文件. 今天我们要做的就是使用自己定义的.ini 文件,定义自己的 Config 变量, 并用这些变量来初始化 Class 中的定义的成员变量.&lt;/p&gt;
&lt;p&gt;版本：UE4.25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-关于打包后Config文件的位置&quot;&gt;&lt;a href=&quot;#1-关于打包后Config文件的位置&quot; class=&quot;headerlink&quot; title=&quot;1.关于打包后Config文件的位置&quot;&gt;&lt;/a&gt;1.关于打包后Config文件的位置&lt;/h4&gt;&lt;p&gt;如果采用Development 或者DebugGame 模式打包的话, Config 文件会生成在 &lt;code&gt;打包目录\项目名称\Saved\Config\WindowsNoEditor&lt;/code&gt; 目录中, 但是如果用Shipping 模式打包的话, 会发现找不到这个目录了, 那么在Windows 系统下 我们可以在如下地址找到 &lt;code&gt;C:\Users\用户名\AppData\Local\项目名称\Saved\Config\WindowsNoEditor&lt;/code&gt;.&lt;br&gt;接下来也会把我们自己的 Config 文件生成在指定的目录下,方便找到和修改.&lt;/p&gt;
&lt;h4 id=&quot;2-把成员变量设置为可用Config-配置&quot;&gt;&lt;a href=&quot;#2-把成员变量设置为可用Config-配置&quot; class=&quot;headerlink&quot; title=&quot;2. 把成员变量设置为可用Config 配置&quot;&gt;&lt;/a&gt;2. 把成员变量设置为可用Config 配置&lt;/h4&gt;&lt;p&gt;在UE4 c++ Class 变量的宏定义中, 加入 &lt;code&gt;config&lt;/code&gt; 关键字&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 是否作为服务器启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UPROPERTY(config ,Category=&lt;span class=&quot;string&quot;&gt;&quot;CustomIni&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; bServer=&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
    
      <category term="Config" scheme="https://nkoo.top/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>UE4 重复点击检测</title>
    <link href="https://nkoo.top/2020/10/04/UE4-ClickCheck/"/>
    <id>https://nkoo.top/2020/10/04/UE4-ClickCheck/</id>
    <published>2020-10-03T23:12:23.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在开发过程中，我们经常会有这样的需求：限制用户的点击频率。一方面考虑到服务器数据请求的压力，一方面防止恶意攻击服务器。<br>我在网上也能看到其他的实现方法，有用Delay 节点的，有传递点击按钮对象的。总觉得使用起来不是很方便，因此打算自己实现一个，简单易用，没有任何使用代价的方式。自认为是最优雅的方式了。</p><p>版本：UE4.25</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>本次针对的是UE4 蓝图UMG 系统，所以是在蓝图的基础上实现的，利用了系统的运行时间。<br>首先第一点击之后调用一个宏记录当前的系统运行时间，然后第二次点击再次调用该宏，比对当前时间和上次记录的时间的差值是否小于我们设定的点击间隔。以此来决定后面的代码要不要继续执行。</p><a id="more"></a> <h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p><img src="/images/image-20210818234356402.webp" alt="image-20210818234356402"></p><p><img src="/images/image-20210818234624047.webp" alt="image-20210818234624047"></p><p>蓝图代码地址<code>https://blueprintue.com/render/y96sbq1v/</code></p><iframe src="https://blueprintue.com/render/y96sbq1v/" scrolling="no" allowfullscreen width="100%" height="300px"></iframe><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>没有什么高深的 Code 技术，但是逻辑思维很重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在开发过程中，我们经常会有这样的需求：限制用户的点击频率。一方面考虑到服务器数据请求的压力，一方面防止恶意攻击服务器。&lt;br&gt;我在网上也能看到其他的实现方法，有用Delay 节点的，有传递点击按钮对象的。总觉得使用起来不是很方便，因此打算自己实现一个，简单易用，没有任何使用代价的方式。自认为是最优雅的方式了。&lt;/p&gt;
&lt;p&gt;版本：UE4.25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;本次针对的是UE4 蓝图UMG 系统，所以是在蓝图的基础上实现的，利用了系统的运行时间。&lt;br&gt;首先第一点击之后调用一个宏记录当前的系统运行时间，然后第二次点击再次调用该宏，比对当前时间和上次记录的时间的差值是否小于我们设定的点击间隔。以此来决定后面的代码要不要继续执行。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
      <category term="UMG" scheme="https://nkoo.top/categories/UE4/UMG/"/>
    
    
      <category term="蓝图" scheme="https://nkoo.top/tags/%E8%93%9D%E5%9B%BE/"/>
    
      <category term="宏" scheme="https://nkoo.top/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>UE4 多线程FRunnable（一）</title>
    <link href="https://nkoo.top/2019/11/04/UE4-Ansyc01/"/>
    <id>https://nkoo.top/2019/11/04/UE4-Ansyc01/</id>
    <published>2019-11-04T12:35:33.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在开发过程中，有时候会遇到需要使用线程相关逻辑，比如网络相关，动态加载资源的，希望不要影响主线程的运行。<br>版本：UE4.25</p></blockquote><p>UE4遵循C++11的标准，但是他并没有使用std::thread，而是自己实现了一套多线程机制。</p><p>在UE4里面创建多线程的三种方式，我们会分三篇来分析和使用：</p><ol><li>继承FRunnable接口创建一个线程任务，适用于复杂运算</li><li>直接创建AsyncTask来调用线程池里面空闲的线程</li><li>通过TaskGraph系统来异步完成一些自定义任务</li></ol><p>这三种方式本质相同，但是用法不同。</p><p>本篇尝试使用FRunnable。</p><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>给定一个txt文件路径数组，通过异步的方式读取文件，并且返回文件的内容数组。</p><h3 id="FRunnable分析"><a href="#FRunnable分析" class="headerlink" title="FRunnable分析"></a>FRunnable分析</h3><p>FRunnable 是线程的执行体，提供相应的接口。FRunnable需要依附与一个FRunnableThread对象，才能被执行，  </p><p>真正的线程其实是FRunnableThread，不同平台的线程都继承自他，如FRunnableThreadWin，里面会调用Windows平台的创建线程的API接口。</p><a id="more"></a> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Windows平台的实现类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRunnableThreadWin</span> :</span> <span class="keyword">public</span> FRunnableThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window平台的线程句柄</span></span><br><span class="line">    HANDLE Thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime\Core\Public\HAL\Runnable.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_API</span> <span class="title">FRunnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，在聚合此方法的线程对象的上下文（FRunnableThread）中调用，而不是在将此runnable传递给新线程的线程中调用</span></span><br><span class="line">    <span class="comment">// 在FRunnableThread创建线程对象后调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化成功后才会调用，这是执行线程任务的地方</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> uint32 <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程请求提前结束</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出，执行清理的时候在聚合线程的上下文（FRunnableThread）中调用。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在禁用多线程情况下运行这个可执行对象的时候，该函数可以获取单线程接口指针</span></span><br><span class="line"><span class="comment">// 如果这个接口没有实现</span></span><br><span class="line"><span class="comment">// 而且当FPlatformProcess::SupportsMultithreading() is false 时这个可执行对象不会被执行</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> class FSingleThreadRunnable* <span class="title">GetSingleThreadInterface</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚析构函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~FRunnable() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>创建TxtReadTask.h 重新生成项目代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TxtReadTask.h</span></span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在开发过程中，有时候会遇到需要使用线程相关逻辑，比如网络相关，动态加载资源的，希望不要影响主线程的运行。&lt;br&gt;版本：UE4.25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UE4遵循C++11的标准，但是他并没有使用std::thread，而是自己实现了一套多线程机制。&lt;/p&gt;
&lt;p&gt;在UE4里面创建多线程的三种方式，我们会分三篇来分析和使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承FRunnable接口创建一个线程任务，适用于复杂运算&lt;/li&gt;
&lt;li&gt;直接创建AsyncTask来调用线程池里面空闲的线程&lt;/li&gt;
&lt;li&gt;通过TaskGraph系统来异步完成一些自定义任务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种方式本质相同，但是用法不同。&lt;/p&gt;
&lt;p&gt;本篇尝试使用FRunnable。&lt;/p&gt;
&lt;h3 id=&quot;案例说明&quot;&gt;&lt;a href=&quot;#案例说明&quot; class=&quot;headerlink&quot; title=&quot;案例说明&quot;&gt;&lt;/a&gt;案例说明&lt;/h3&gt;&lt;p&gt;给定一个txt文件路径数组，通过异步的方式读取文件，并且返回文件的内容数组。&lt;/p&gt;
&lt;h3 id=&quot;FRunnable分析&quot;&gt;&lt;a href=&quot;#FRunnable分析&quot; class=&quot;headerlink&quot; title=&quot;FRunnable分析&quot;&gt;&lt;/a&gt;FRunnable分析&lt;/h3&gt;&lt;p&gt;FRunnable 是线程的执行体，提供相应的接口。FRunnable需要依附与一个FRunnableThread对象，才能被执行，  &lt;/p&gt;
&lt;p&gt;真正的线程其实是FRunnableThread，不同平台的线程都继承自他，如FRunnableThreadWin，里面会调用Windows平台的创建线程的API接口。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
      <category term="多线程" scheme="https://nkoo.top/categories/UE4/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Ansyc" scheme="https://nkoo.top/tags/Ansyc/"/>
    
      <category term="异步" scheme="https://nkoo.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="多线程" scheme="https://nkoo.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>UE4 打包相关（一）</title>
    <link href="https://nkoo.top/2019/08/04/UE4-Pack01/"/>
    <id>https://nkoo.top/2019/08/04/UE4-Pack01/</id>
    <published>2019-08-04T12:17:41.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>想知道从C++代码/蓝图脚本/资产到打包成可执行程序，UE都帮我们干了些什么吗？<br>版本：UE4.21</p></blockquote><h3 id="基本名词解释"><a href="#基本名词解释" class="headerlink" title="基本名词解释"></a>基本名词解释</h3><blockquote><p>ps:受限于当前的知识水平，难免产生理解错误，后期会继续完善修正。</p></blockquote><h4 id="UHT-UnrealHeaderTool"><a href="#UHT-UnrealHeaderTool" class="headerlink" title="UHT (UnrealHeaderTool )"></a>UHT (UnrealHeaderTool )</h4><p>我粗浅的理解就是UE自己的代码预处理器（相对于C++ 的预处理过程），UHT对代码文件内容进行处理，生成 .generated.h/.gen.cpp 文件，加入反射信息，适配UObject，在以便在在运行时能获取和使用这些数据。<br>生成的文件在 \Intermediate\Build\Win64\UE4Editor\Inc\YourProject 目录下。</p><blockquote><p>UObject提供了 元数据、反射数据、GC垃圾回收、序列化</p></blockquote><h4 id="UBT-UnrealBuildTool"><a href="#UBT-UnrealBuildTool" class="headerlink" title="UBT (UnrealBuildTool)"></a>UBT (UnrealBuildTool)</h4><p>UnrealBuildTool (UBT)管理在各种不同的构建配置下构建UE4源代码的过程；<br>UBT 程序源代码在Engine\Source\Programs\UnrealBuildTool 目录下；<br>UBT 的配置项在 UnrealBuildTool\Configuration\BuildConfiguration.cs 文件中。  </p><a id="more"></a> <h4 id="UAT-AutomotionTool"><a href="#UAT-AutomotionTool" class="headerlink" title="UAT (AutomotionTool)"></a>UAT (AutomotionTool)</h4><p>UnrealBuildTool (UBT)管理在各种不同的构建配置下构建UE4源代码的过程；<br>UBT 程序源代码在Engine\Source\Programs\UnrealBuildTool 目录下；<br>UBT 的配置项在 UnrealBuildTool\Configuration\BuildConfiguration.cs 文件中。  </p><h4 id="Build-构建"><a href="#Build-构建" class="headerlink" title="Build 构建"></a>Build 构建</h4><p>这里说的不是 UE 编辑器上Build按钮，那主要是负责提前计算场景中光照数据、物体可见性、导航网格等。<br>我们说的是源代码source code 的构建。<br>首先我们执行编辑器的 File-&gt;Refresh Visual Studio Project，在输出日志中我们会看到如下信息：<br>（此操作等同在 xxx.uproject 上右击 Generate visual studio project files, ps:必须是C++ 项目）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Running .../UnrealEngine/Engine/Binaries/DotNET/UnrealBuildTool.exe  -projectfiles -project=".../MyProject.uproject" -game -engine -progress</span><br><span class="line">Discovering modules, targets and source code for project...</span><br><span class="line">Binding IntelliSense data...</span><br><span class="line">Binding IntelliSense data... 100%</span><br><span class="line">Writing project files...</span><br><span class="line">Writing project files... 100%</span><br></pre></td></tr></table></figure><p>我们看到UBT(UnrealBuildTool)这个程序开始执行了。   </p><h3 id="Complie-编译"><a href="#Complie-编译" class="headerlink" title="Complie 编译"></a>Complie 编译</h3><p>在VS等IDE 中执行编译， UE 引擎也提供了热编译功能（在不关闭引擎的情况下，对修改的c++代码进行重新编译） 。<br>这个过程就是编译C++ 代码，生成Binaries二进制文件。</p><h3 id="Cook-烘焙"><a href="#Cook-烘焙" class="headerlink" title="Cook 烘焙"></a>Cook 烘焙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UATHelper: Cooking (Windows (64-bit)): Running AutomationTool...</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Parsing command line: -ScriptsForProject=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; BuildCookRun -nocompileeditor -nop4 -project=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; -cook -skipstage -ue4exe=C:\Users\Administrator\Documents\UnrealEngine\Engi</span><br><span class="line">ne\Binaries\Win64\UE4Editor-Cmd.exe -targetplatform=Win64 -utf8output -compile</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Dependencies are up to date (0.071s). Skipping compile.</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Setting up ProjectParams for C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): ********** COOK COMMAND STARTED **********</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Running UE4Editor Cook for project C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Commandlet log file is C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Cook-2021.08.21-15.00.49.txt</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\Win64\UE4Editor-Cmd.exe &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -run=Cook  -TargetPlatform=WindowsNoEditor -fileopenlog -unversioned -abslog=C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\Automat</span><br><span class="line">ionTool\Saved\Cook-2021.08.21-15.00.49.txt -stdout -CrashForUAT -unattended -NoLogTimes  -UTF8Output</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LogUObjectHash: Compacting FUObjectHashTables data took   0.52ms</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Running AutomationTool...</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Parsing command line: -ScriptsForProject=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; BuildCookRun -nocompileeditor -nop4 -project=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; -cook -stage -archive -archivedirectory=&quot;C:/Users/Administrator/Documents</span><br><span class="line">/Unreal Projects/MyProject&quot; -package -ue4exe=C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\Win64\UE4Editor-Cmd.exe -pak -prereqs -nodebuginfo -targetplatform=Win64 -build -target=MyProject -clientconfig=Development -utf8output -compile</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Dependencies are up to date (0.073s). Skipping compile.</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Setting up ProjectParams for C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): ********** BUILD COMMAND STARTED **********</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe UnrealPak Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -Manif</span><br><span class="line">est=C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-UnrealPak-Win64-Development.txt&quot;</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Building UnrealPak...</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Using Visual Studio 2019 14.28.29913 toolchain (C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29910) and Windows 10.0.18362.0 SDK (C:\Program Files (x86)\Windows Kits\10).</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Building 1 action with 12 processes...</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):     [1/1] UnrealPak.target</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Total time in Parallel executor: 0.15 seconds</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Total execution time: 2.46 seconds</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Took 2.5490017s to run UnrealBuildTool.exe, ExitCode=0</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe MyProject Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -remot</span><br><span class="line">eini=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject&quot; -skipdeploy -Manifest=C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-MyProject-Win64-Development.txt&quot;</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Parsing headers for MyProject</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):     Running UnrealHeaderTool &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\Intermediate\Build\Win64\MyProject\Development\MyProject.uhtmanifest&quot; -LogCmds=&quot;loginit warning, logexit warning, logdatabase error&quot; -Unattended -Warn</span><br><span class="line">ingsAsErrors -abslog=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UHT-MyProject-Win64-Development.txt&quot;</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Reflection code generated for MyProject in 7.6218441 seconds</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Building MyProject...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LogPlayLevel: Completed Launch On Stage: Cooking in the editor, Time: 5.859237</span><br><span class="line">LogPlayLevel: Running AutomationTool...</span><br><span class="line">LogPlayLevel: Parsing command line: -ScriptsForProject=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; BuildCookRun -project=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; -noP4 -clientconfig=Development -serverconfig=Development -nocompileeditor -ue4exe=C:\Users\Administrator\Documents\UnrealE</span><br><span class="line">ngine\Engine\Binaries\Win64\UE4Editor-Cmd.exe -utf8output -platform=Win64 -targetplatform=Win64 -ini:Game:[/Script/UnrealEd.ProjectPackagingSettings]:BlueprintNativizationMethod=Disabled -build -map=/Game/ThirdPersonCPP/Maps/ThirdPersonExampleMap -skipcook -CookInEditor -iterativecooking -compressed -iterativedeploy -stage -deploy -cmdline=&quot;/Game/ThirdPerson</span><br><span class="line">CPP/Maps/ThirdPersonExampleMap -Messaging&quot; -device=WindowsNoEditor@FNEO48MGKFVU1R6 -addcmdline=&quot;-SessionId=F0F275C749ED33221ED7CE83A5061BC4 -SessionOwner=&apos;Administrator&apos; -SessionName=&apos;Launch On Device&apos;  &quot; -run -compile</span><br><span class="line">LogPlayLevel: Dependencies are up to date (0.078s). Skipping compile.</span><br><span class="line">LogPlayLevel: Setting up ProjectParams for C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">LogPlayLevel: ********** BUILD COMMAND STARTED **********</span><br><span class="line">LogPlayLevel: Completed Launch On Stage: Build Task, Time: 2.761045</span><br><span class="line">LogPlayLevel: Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe UnrealPak Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -Manifest=C:\Users\Administrator\</span><br><span class="line">Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-UnrealPak-Win64-Development.txt&quot;</span><br><span class="line">LogPlayLevel:   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">LogPlayLevel:   Target is up to date</span><br><span class="line">LogPlayLevel:   Total execution time: 1.16 seconds</span><br><span class="line">LogPlayLevel: Took 1.2479697s to run UnrealBuildTool.exe, ExitCode=0</span><br><span class="line">LogPlayLevel: Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe MyProject Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -remoteini=&quot;C:\Users\Administrato</span><br><span class="line">r\Documents\Unreal Projects\MyProject&quot; -skipdeploy -ini:Game:[/Script/UnrealEd.ProjectPackagingSettings]:BlueprintNativizationMethod=Disabled -Manifest=C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-MyProject-Wi</span><br><span class="line">n64-Development.txt&quot;</span><br><span class="line">LogPlayLevel:   Parsing headers for MyProject</span><br><span class="line">LogPlayLevel:     Running UnrealHeaderTool &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\Intermediate\Build\Win64\MyProject\Development\MyProject.uhtmanifest&quot; -LogCmds=&quot;loginit warning, logexit warning, logdatabase error&quot; -Unattended -WarningsAsErrors -abslog=&quot;C:\Us</span><br><span class="line">ers\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UHT-MyProject-Win64-Development.txt&quot;</span><br><span class="line">LogPlayLevel:   Reflection code generated for MyProject in 5.4499816 seconds</span><br><span class="line">LogPlayLevel:   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">LogPlayLevel:   Building MyProject...</span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;想知道从C++代码/蓝图脚本/资产到打包成可执行程序，UE都帮我们干了些什么吗？&lt;br&gt;版本：UE4.21&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本名词解释&quot;&gt;&lt;a href=&quot;#基本名词解释&quot; class=&quot;headerlink&quot; title=&quot;基本名词解释&quot;&gt;&lt;/a&gt;基本名词解释&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ps:受限于当前的知识水平，难免产生理解错误，后期会继续完善修正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;UHT-UnrealHeaderTool&quot;&gt;&lt;a href=&quot;#UHT-UnrealHeaderTool&quot; class=&quot;headerlink&quot; title=&quot;UHT (UnrealHeaderTool )&quot;&gt;&lt;/a&gt;UHT (UnrealHeaderTool )&lt;/h4&gt;&lt;p&gt;我粗浅的理解就是UE自己的代码预处理器（相对于C++ 的预处理过程），UHT对代码文件内容进行处理，生成 .generated.h/.gen.cpp 文件，加入反射信息，适配UObject，在以便在在运行时能获取和使用这些数据。&lt;br&gt;生成的文件在 \Intermediate\Build\Win64\UE4Editor\Inc\YourProject 目录下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UObject提供了 元数据、反射数据、GC垃圾回收、序列化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;UBT-UnrealBuildTool&quot;&gt;&lt;a href=&quot;#UBT-UnrealBuildTool&quot; class=&quot;headerlink&quot; title=&quot;UBT (UnrealBuildTool)&quot;&gt;&lt;/a&gt;UBT (UnrealBuildTool)&lt;/h4&gt;&lt;p&gt;UnrealBuildTool (UBT)管理在各种不同的构建配置下构建UE4源代码的过程；&lt;br&gt;UBT 程序源代码在Engine\Source\Programs\UnrealBuildTool 目录下；&lt;br&gt;UBT 的配置项在 UnrealBuildTool\Configuration\BuildConfiguration.cs 文件中。  &lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://nkoo.top/categories/UE4/"/>
    
      <category term="PACK" scheme="https://nkoo.top/categories/UE4/PACK/"/>
    
    
      <category term="UBT" scheme="https://nkoo.top/tags/UBT/"/>
    
      <category term="UHT" scheme="https://nkoo.top/tags/UHT/"/>
    
      <category term="build" scheme="https://nkoo.top/tags/build/"/>
    
      <category term="cook" scheme="https://nkoo.top/tags/cook/"/>
    
      <category term="pack" scheme="https://nkoo.top/tags/pack/"/>
    
      <category term="run" scheme="https://nkoo.top/tags/run/"/>
    
  </entry>
  
  <entry>
    <title>关于char * ,char a[ ] , string</title>
    <link href="https://nkoo.top/2019/01/24/UE4-CPP-about-char/"/>
    <id>https://nkoo.top/2019/01/24/UE4-CPP-about-char/</id>
    <published>2019-01-24T11:22:17.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>借此理解数组名和数组首地址</p></blockquote><ol><li><p>c 语言中没有 string 类型， 用 char 类型的数组来表示string，也就是 一串内存地址连续的 char</p></li><li><p>\0 是字符串的结束符</p></li><li><p><font color="red">“asfkhj”</font> 双引号中的内容表示一个常量字符串 const string，本质是一个地址，是第一个字符的地址</p></li><li><p>char* 表示一个指针变量，当然可以用一个地址来赋值</p></li><li><p>char a[ ] 表示一个字符串数组，a 是数组名，是const 常量，只能初始化，不能直接赋值，a也表示数组的首地址，也就是第一个元素的地址a[0]</p><a id="more"></a> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">16</span>] = &#123; <span class="string">"it's a string"</span> &#125;;</span><br><span class="line">p = <span class="string">"it's a string"</span>;</span><br><span class="line">p = buff;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, &amp;buff[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">打印结果一致,所有相同的字符串常量都是同一个地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;借此理解数组名和数组首地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;c 语言中没有 string 类型， 用 char 类型的数组来表示string，也就是 一串内存地址连续的 char&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\0 是字符串的结束符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;“asfkhj”&lt;/font&gt; 双引号中的内容表示一个常量字符串 const string，本质是一个地址，是第一个字符的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;char* 表示一个指针变量，当然可以用一个地址来赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;char a[ ] 表示一个字符串数组，a 是数组名，是const 常量，只能初始化，不能直接赋值，a也表示数组的首地址，也就是第一个元素的地址a[0]&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://nkoo.top/categories/C-C/"/>
    
    
      <category term="char" scheme="https://nkoo.top/tags/char/"/>
    
  </entry>
  
</feed>
