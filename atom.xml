<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>做梦诗人的博客</title>
  <icon>https://www.gravatar.com/avatar/83682c37b4f0631369445a297d50bbe5</icon>
  <subtitle>仰天大笑出门去</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://worldnot.com/"/>
  <updated>2022-10-08T10:39:01.019Z</updated>
  <id>https://worldnot.com/</id>
  
  <author>
    <name>Dreamingpoet</name>
    <email>Dreamingpoet@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Docker 中运行 PostgreSQL</title>
    <link href="https://worldnot.com/2022/10/08/Docker-PostgreSQL/"/>
    <id>https://worldnot.com/2022/10/08/Docker-PostgreSQL/</id>
    <published>2022-10-08T10:46:12.000Z</published>
    <updated>2022-10-08T10:39:01.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>我们在这里要做的是下载PostgreSQL镜像，检查镜像是否准备好，使用特定参数运行镜像，最后连接到正在运行的PostgreSQL实例。</p></blockquote><h3 id="1-拉取一个-PostgreSQL-服务器-Docker-镜像"><a href="#1-拉取一个-PostgreSQL-服务器-Docker-镜像" class="headerlink" title="1.拉取一个 PostgreSQL 服务器 Docker 镜像"></a>1.拉取一个 PostgreSQL 服务器 Docker 镜像</h3><p>首先，我们需要从Docker Hub获取现有的 PostgreSQL 官方镜像。如果您需要特定版本，latest 请将标签更改 为所需版本。<br>现在让我们拉取镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull postgres:latest</span><br></pre></td></tr></table></figure></p><p>使用上述命令将从 Docker Hub 存储库中提取最新可用版本的 PostgreSQL。</p><h3 id="2-从-PostgreSQL-服务器-Docker-镜像运行容器"><a href="#2-从-PostgreSQL-服务器-Docker-镜像运行容器" class="headerlink" title="2. 从 PostgreSQL 服务器 Docker 镜像运行容器"></a>2. 从 PostgreSQL 服务器 Docker 镜像运行容器</h3><p>在部署之前，您需要设置一个 Docker 卷或绑定安装来持久化您的数据库。否则，当容器重新启动时，您的数据将丢失。安装应该 /var/lib/postgresql/data 在容器内的目录中。<br>出于本指南的目的，我们将创建一个 docker 卷并将其附加到您的 PostgreSQL 容器。<br>以下命令将在您的本地计算机中创建卷，您可以稍后与 PostgreSQL 容器连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker volume create postgres-volume</span><br></pre></td></tr></table></figure><p>现在你的机器上有 PostgreSQL 镜像和一个用于保存数据的卷，你可以部署一个容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name=postgres14 -p 5432:5432 -v postgres-volume:/var/lib/postgresql/data -e POSTGRES_PASSWORD=your_password postgres</span><br></pre></td></tr></table></figure><p>默认用户名是 postgres</p><a id="more"></a><p>该 docker run 命令将在 Docker 容器中创建一个正在运行的 PostgreSQL 数据库。</p><p>让我们分解一下这个语法。以下是该命令中每个参数的含义：</p><p>-d 将以分离模式运行此容器，以便它在后台运行。<br>–name 将名称“postgres13”分配给您的容器实例。<br>-p会将 PostgreSQL 容器端口 5432 绑定到主机上的相同端口。您将能够localhost:5432 使用psql在您的主机上运行的PostgreSQL 客户端进行连接 。<br>-v选项将容器卷 ( /var/lib/postgresql)内的数据文件夹绑定到postgres-volume您在上一步中创建的本地 Docker 卷。<br>-e设置环境变量。在这种情况下，PostgreSQL 根密码。<br>postgres 是我们用来创建容器的镜像的名称。<br>您可以通过列出正在运行的容器来检查容器是否正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure><p>恭喜！您的新 PostgreSQL 实例现在正在 Docker 上运行。</p><p>此外，您可以使用以下命令检查正在运行的 PostgreSQL 容器的日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs postgres14</span><br></pre></td></tr></table></figure><h3 id="3-连接到PostgreSQL服务器"><a href="#3-连接到PostgreSQL服务器" class="headerlink" title="3. 连接到PostgreSQL服务器"></a>3. 连接到PostgreSQL服务器</h3><p>您可以通过附加到容器并运行psql命令来获得交互式 PostgreSQL shell 。这提供了完整的 PostgreSQL 命令行界面，因此您可以使用所有熟悉的命令和标志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it postgres13 psql -U postgres</span><br></pre></td></tr></table></figure><p>psql如果您在主机上预安装了PostgreSQL 客户端，您还可以使用PostgreSQL 客户端连接 PostgreSQL Docker 实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h localhost -U postgres</span><br></pre></td></tr></table></figure><h3 id="4-用可视化工具-pgadmin4-管理"><a href="#4-用可视化工具-pgadmin4-管理" class="headerlink" title="4. 用可视化工具 pgadmin4 管理"></a>4. 用可视化工具 pgadmin4 管理</h3><h3 id="4-1-在docker中部署pgadmin4"><a href="#4-1-在docker中部署pgadmin4" class="headerlink" title="4.1 在docker中部署pgadmin4"></a>4.1 在docker中部署pgadmin4</h3><p>拉取postgresql可视化工具pgadmin4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dpage/pgadmin4</span><br></pre></td></tr></table></figure><p>运行pgadmin4：</p><p>-p 5433:80 将容器的80端口映射到宿主机的5433端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5433:80 --name pgadmin4 -e PGADMIN_DEFAULT_EMAIL=<span class="built_in">test</span>@123.com -e PGADMIN_DEFAULT_PASSWORD=your_password dpage/pgadmin4</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;我们在这里要做的是下载PostgreSQL镜像，检查镜像是否准备好，使用特定参数运行镜像，最后连接到正在运行的PostgreSQL实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-拉取一个-PostgreSQL-服务器-Docker-镜像&quot;&gt;&lt;a href=&quot;#1-拉取一个-PostgreSQL-服务器-Docker-镜像&quot; class=&quot;headerlink&quot; title=&quot;1.拉取一个 PostgreSQL 服务器 Docker 镜像&quot;&gt;&lt;/a&gt;1.拉取一个 PostgreSQL 服务器 Docker 镜像&lt;/h3&gt;&lt;p&gt;首先，我们需要从Docker Hub获取现有的 PostgreSQL 官方镜像。如果您需要特定版本，latest 请将标签更改 为所需版本。&lt;br&gt;现在让我们拉取镜像：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker pull postgres:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用上述命令将从 Docker Hub 存储库中提取最新可用版本的 PostgreSQL。&lt;/p&gt;
&lt;h3 id=&quot;2-从-PostgreSQL-服务器-Docker-镜像运行容器&quot;&gt;&lt;a href=&quot;#2-从-PostgreSQL-服务器-Docker-镜像运行容器&quot; class=&quot;headerlink&quot; title=&quot;2. 从 PostgreSQL 服务器 Docker 镜像运行容器&quot;&gt;&lt;/a&gt;2. 从 PostgreSQL 服务器 Docker 镜像运行容器&lt;/h3&gt;&lt;p&gt;在部署之前，您需要设置一个 Docker 卷或绑定安装来持久化您的数据库。否则，当容器重新启动时，您的数据将丢失。安装应该 /var/lib/postgresql/data 在容器内的目录中。&lt;br&gt;出于本指南的目的，我们将创建一个 docker 卷并将其附加到您的 PostgreSQL 容器。&lt;br&gt;以下命令将在您的本地计算机中创建卷，您可以稍后与 PostgreSQL 容器连接：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker volume create postgres-volume&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在你的机器上有 PostgreSQL 镜像和一个用于保存数据的卷，你可以部署一个容器：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker run -d --name=postgres14 -p 5432:5432 -v postgres-volume:/var/lib/postgresql/data -e POSTGRES_PASSWORD=your_password postgres&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认用户名是 postgres&lt;/p&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://worldnot.com/categories/DataBase/"/>
    
      <category term="PostgreSQL" scheme="https://worldnot.com/categories/DataBase/PostgreSQL/"/>
    
    
      <category term="PostgreSQL" scheme="https://worldnot.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>FString和各种数据格式间转换</title>
    <link href="https://worldnot.com/2022/04/20/UE4-FString/"/>
    <id>https://worldnot.com/2022/04/20/UE4-FString/</id>
    <published>2022-04-20T14:46:15.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、UE4-Source-Header-References"><a href="#一、UE4-Source-Header-References" class="headerlink" title="一、UE4 Source Header References"></a>一、UE4 Source Header References</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CString.h</span><br><span class="line">UnrealString.h</span><br><span class="line">NameTypes.h</span><br><span class="line">StringConv.h (TCHAR_TO_ANSI etc)</span><br></pre></td></tr></table></figure><p>CString.h可以查到更多，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atoi64 (<span class="built_in">string</span> to int64)</span><br><span class="line">Atod (<span class="built_in">string</span> to <span class="keyword">double</span> precision <span class="keyword">float</span>)</span><br></pre></td></tr></table></figure></p><h3 id="二、日志打印"><a href="#二、日志打印" class="headerlink" title="二、日志打印"></a>二、日志打印</h3><h4 id="1-输出字符串到output-log中"><a href="#1-输出字符串到output-log中" class="headerlink" title="1.输出字符串到output log中"></a>1.输出字符串到output log中</h4><h4 id="1-1-最普通的三种"><a href="#1-1-最普通的三种" class="headerlink" title="1.1 最普通的三种"></a>1.1 最普通的三种</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FString filePath</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"Hello,World!"</span>));</span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(<span class="string">"Hello,World!"</span>));</span><br><span class="line">UE_LOG(LogTemp, Error, TEXT(<span class="string">"Hello,World!"</span>));</span><br><span class="line">#### <span class="number">1.2</span> %d打印<span class="keyword">int</span>，%f打印<span class="keyword">float</span>，%s <span class="built_in">string</span></span><br></pre></td></tr></table></figure><a id="more"></a> <p>前面加throttle是为了知道打印的对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">UE_LOG(LogTemp，Log，TEXT(<span class="string">"throttle %d"</span>), throttle);</span><br><span class="line"><span class="comment">//输出：throttle 1532</span></span><br><span class="line">FString filePath</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"%s"</span>), *filePath);</span><br></pre></td></tr></table></figure></p><h4 id="1-3-自定义-分类的名字-的log"><a href="#1-3-自定义-分类的名字-的log" class="headerlink" title="1.3 自定义 分类的名字 的log"></a>1.3 自定义 分类的名字 的log</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">    <span class="function">DECLARE LOG CATEGORY <span class="title">EXTERN</span><span class="params">(MyLog,Log，All)</span></span>;</span><br><span class="line">.cpp</span><br><span class="line">    DEFINE_LOG_CATEGORY(MyLog);</span><br><span class="line">​</span><br><span class="line">UE_LOG(MyLog,Warning,TEXT (<span class="string">"Success"</span>));</span><br><span class="line">​</span><br><span class="line">输出：</span><br><span class="line">MyLog:Warning:Success</span><br></pre></td></tr></table></figure><h4 id="2-输出字符串到屏幕上"><a href="#2-输出字符串到屏幕上" class="headerlink" title="2.输出字符串到屏幕上"></a>2.输出字符串到屏幕上</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FString filePath;</span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">5.f</span>, FColor::Green, FString::Printf(TEXT(<span class="string">"DLL_Init"</span>)));</span><br><span class="line"> </span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">5.f</span>, FColor::Green, FString::Printf(TEXT(<span class="string">"%s"</span>), *filePath));</span><br></pre></td></tr></table></figure><h3 id="三、FString"><a href="#三、FString" class="headerlink" title="三、FString"></a>三、FString</h3><h4 id="3-1-FString-To-FNames"><a href="#3-1-FString-To-FNames" class="headerlink" title="3.1 FString To FNames"></a>3.1 FString To FNames</h4><p>不可靠，因为FName不区分大小写，所以转换存在丢失<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line">FString TheString = <span class="string">"Hello，world"</span>;</span><br><span class="line"><span class="comment">//将FString转换为FName</span></span><br><span class="line">FName ConvertedFString = FName(*TheString);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-FString-To-FText"><a href="#3-2-FString-To-FText" class="headerlink" title="3.2 FString To FText"></a>3.2 FString To FText</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"Hello，world"</span>;</span><br><span class="line">FText ConvertedFSting=FText::FromSting(TheString);</span><br></pre></td></tr></table></figure><h4 id="3-3-FString-To-Array"><a href="#3-3-FString-To-Array" class="headerlink" title="3.3 FString To Array"></a>3.3 FString To Array</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">FString JsonStr;  </span><br><span class="line">TArray&lt;uint8&gt; content;  </span><br><span class="line"> </span><br><span class="line">content.SetNum(JsonStr.Len());  </span><br><span class="line"><span class="built_in">memcpy</span>(content.GetData(), TCHAR_TO_ANSI(*JsonStr), JsonStr.Len());</span><br><span class="line">​</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">FString StrData;  </span><br><span class="line"><span class="keyword">const</span> TCHAR* StrPtr = *StrData;  </span><br><span class="line"><span class="function">FTCHARToUTF8 <span class="title">UTF8String</span><span class="params">(StrPtr)</span></span>;  </span><br><span class="line">int32 CTXSize = UTF8String.Length();  </span><br><span class="line"> </span><br><span class="line">TArray&lt;uint8&gt; URLData;  </span><br><span class="line">URLData.SetNum(CTXSize);  </span><br><span class="line"><span class="built_in">memcpy</span>(URLData.GetData(), UTF8String.Get(), CTXSize);</span><br></pre></td></tr></table></figure><h4 id="3-4-FString-To-char"><a href="#3-4-FString-To-char" class="headerlink" title="3.4 FString To char*"></a>3.4 FString To char*</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"Hello，world"</span>;</span><br><span class="line"><span class="keyword">char</span>* MyCharPtr = TCHAR_TO_UTF8(*MyFString);</span><br></pre></td></tr></table></figure><h4 id="3-5-FString-To-const-char"><a href="#3-5-FString-To-const-char" class="headerlink" title="3.5 FString To const char *"></a>3.5 FString To const char *</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *plainText= TCHAR_TO_ANSI(*aes_content);</span><br></pre></td></tr></table></figure><h4 id="3-6-FString-To-TCHAR"><a href="#3-6-FString-To-TCHAR" class="headerlink" title="3.6 FString To TCHAR*"></a>3.6 FString To TCHAR*</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString s=<span class="string">"a"</span>;</span><br><span class="line">TCHAR* t=*s;</span><br></pre></td></tr></table></figure><h4 id="3-7-FString-To-std-string"><a href="#3-7-FString-To-std-string" class="headerlink" title="3.7 FString To std::string"></a>3.7 FString To std::string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">​</span><br><span class="line">FString UE4Str = <span class="string">"Flowers"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> MyStdString = TCHAR_TO_UTF8(*UE4Str);</span><br></pre></td></tr></table></figure><h4 id="3-8-FString-To-JsonObject"><a href="#3-8-FString-To-JsonObject" class="headerlink" title="3.8 FString To JsonObject"></a>3.8 FString To JsonObject</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;FJsonObject&gt; JsonObject = MakeShareable(<span class="keyword">new</span> FJsonObject);</span><br><span class="line">TSharedRef&lt;TJsonReader&lt;&gt;&gt; Reader = TJsonReaderFactory&lt;&gt;::Create(JsonStr);</span><br><span class="line">FJsonSerializer::Deserialize(Reader,JsonObject);</span><br><span class="line"><span class="comment">//JsonObject就是Json</span></span><br></pre></td></tr></table></figure><h4 id="3-9-FString-To-bool"><a href="#3-9-FString-To-bool" class="headerlink" title="3.9 FString To bool"></a>3.9 FString To bool</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="keyword">bool</span> MyBool = MyFString.ToBool();</span><br></pre></td></tr></table></figure><h4 id="3-10-FString-To-int32"><a href="#3-10-FString-To-int32" class="headerlink" title="3.10 FString To int32"></a>3.10 FString To int32</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="comment">//注意，Atoi和Atof是静态函数，所以使用语法FCString：：TheFunction调用它：)</span></span><br><span class="line">int32 MyShinyNewInt = FCString::Atoi(*TheString);</span><br></pre></td></tr></table></figure><h4 id="3-11-FString-To-int64"><a href="#3-11-FString-To-int64" class="headerlink" title="3.11 FString To int64"></a>3.11 FString To int64</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"12312345678789561234879"</span>;</span><br><span class="line"><span class="comment">//注意，Atoi64是静态函数，所以使用语法FCString::TheFunction调用它：)</span></span><br><span class="line">int64 MyShinyNewInt = FCString::Atoi64(*TheString);</span><br></pre></td></tr></table></figure><h4 id="3-12-FString-To-float"><a href="#3-12-FString-To-float" class="headerlink" title="3.12 FString To float"></a>3.12 FString To float</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="comment">//注意，Atoi和Atof是静态函数，所以使用语法FCString：：TheFunction调用它：)</span></span><br><span class="line"><span class="keyword">float</span> MyShinyNewFloat = FCString::Atof(*TheString);</span><br></pre></td></tr></table></figure><h4 id="3-13-FString-To-double"><a href="#3-13-FString-To-double" class="headerlink" title="3.13 FString To double"></a>3.13 FString To double</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数方式</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UDoubleFunction::FStringToDouble</span><span class="params">(FString str,<span class="keyword">double</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> numString = TCHAR_TO_UTF8(*str);</span><br><span class="line">    <span class="keyword">double</span> b = atof(numString.c_str());</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num =b;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//直接转换</span></span><br><span class="line">FString TheString = <span class="string">"123.021"</span>;</span><br><span class="line"><span class="comment">//注意，Atod是静态函数，所以使用语法FCString：：TheFunction调用它：)</span></span><br><span class="line"><span class="keyword">double</span> MyShinyNewFloat = FCString::Atod(*TheString);</span><br><span class="line">​</span><br><span class="line"><span class="comment">//FString转String转Double</span></span><br><span class="line">FString str = <span class="string">"113.5246854"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> numString = TCHAR_TO_UTF8(*str);</span><br><span class="line"><span class="keyword">double</span> b = atof(numString.c_str());</span><br></pre></td></tr></table></figure><h4 id="3-14-转换-To-FString"><a href="#3-14-转换-To-FString" class="headerlink" title="3.14 转换 To FString"></a>3.14 转换 To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int</span></span><br><span class="line">FString NewString = FString::FromInt(MyInt);</span><br><span class="line"><span class="comment">//float //double    ----只能精确到小数点后6位</span></span><br><span class="line">FString VeryCleanString = FString::SanitizeFloat(MyFloat);</span><br><span class="line"><span class="comment">//bool</span></span><br><span class="line">FString MyFString = MyBool?TEXT(<span class="string">"true"</span>) :TEXT(<span class="string">"false"</span>);</span><br><span class="line"><span class="comment">//FVector</span></span><br><span class="line">FString MyFString = MyVector.ToString();</span><br><span class="line"><span class="comment">//FVector2D</span></span><br><span class="line">FString MyFString = MyVector2D.ToString();</span><br><span class="line"><span class="comment">//FRotator</span></span><br><span class="line">FString MyFString = MyRotator.ToString();</span><br><span class="line"><span class="comment">//FLinearColor</span></span><br><span class="line">FString MyFString = MyLinearColor.ToString();</span><br><span class="line"><span class="comment">//UObject</span></span><br><span class="line">FString MyFString = (MyObj != <span class="literal">NULL</span>) ? MyObj-&gt;GetName() : FString(TEXT(<span class="string">"None"</span>));</span><br><span class="line"><span class="comment">//FMatrix</span></span><br><span class="line"><span class="function">FMatrix <span class="title">rotationMatrix</span><span class="params">(FPlane(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),FPlane(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>),FPlane(<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>),FPlane(<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>))</span></span>;          </span><br><span class="line">FString str = rotationMatrix.ToString();</span><br></pre></td></tr></table></figure><h4 id="3-15-double-To-FString"><a href="#3-15-double-To-FString" class="headerlink" title="3.15 double To FString"></a>3.15 double To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接转换：精确到小数点后6位</span></span><br><span class="line"><span class="keyword">return</span>   FString::SanitizeFloat(numeral.dou);</span><br><span class="line"></span><br><span class="line"><span class="comment">//double→string→FString精确到小数点后6位</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Str = <span class="built_in">std</span>::to_string(numeral.dou);</span><br><span class="line">FString <span class="built_in">string</span> = UTF8_TO_TCHAR(Str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出有效位数15位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">double</span> d = numeral.dou;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; setprecision(<span class="number">15</span>) &lt;&lt; d;</span><br><span class="line">str = ss.str();</span><br><span class="line">FString <span class="built_in">string</span> = UTF8_TO_TCHAR(str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定小数点后几位   --注：double的有效位数只有16位，小数点算一位</span></span><br><span class="line"><span class="keyword">double</span> doub = <span class="number">9999.1234567891011121314</span>;</span><br><span class="line">FString TimeDesc = FString::Printf(TEXT(<span class="string">"%.15f"</span>), doub);<span class="comment">//9999.123456789100601</span></span><br></pre></td></tr></table></figure><h4 id="3-16-bytes-To-FString"><a href="#3-16-bytes-To-FString" class="headerlink" title="3.16 bytes To FString"></a>3.16 bytes To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FString fstr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; FaceArray.Num() * <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    FString tmpStr;</span><br><span class="line">    ByteToHex(f_arrbytes[i], tmpStr);</span><br><span class="line">    fstr.Append(tmpStr);</span><br><span class="line">&#125;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"%S"</span>), *fstr);</span><br></pre></td></tr></table></figure><h4 id="3-17-FArrayReaderPtr-to-FString"><a href="#3-17-FArrayReaderPtr-to-FString" class="headerlink" title="3.17 FArrayReaderPtr to FString"></a>3.17 FArrayReaderPtr to FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8 data[<span class="number">512</span>];  </span><br><span class="line">FMemory::Memzero(data, <span class="number">512</span>);  </span><br><span class="line">FMemory::Memcpy(data, ArrayReaderPtr-&gt;GetData(), ArrayReaderPtr-&gt;Num());</span><br></pre></td></tr></table></figure><p>FString str = ((const char*)data);</p><h4 id="3-18-Array-to-FString"><a href="#3-18-Array-to-FString" class="headerlink" title="3.18 Array to FString"></a>3.18 Array to FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;uint8&gt; content;  </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">cstr</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(content.GetData()), content.Num())</span></span>;  </span><br><span class="line">FString frameAsFString = cstr.c_str();  </span><br><span class="line">UE_LOG(VRSLog, Warning, TEXT(<span class="string">"%s"</span>), *frameAsFString);</span><br></pre></td></tr></table></figure><h3 id="四、FName"><a href="#四、FName" class="headerlink" title="四、FName"></a>四、FName</h3><h4 id="4-1-FName-To-FString"><a href="#4-1-FName-To-FString" class="headerlink" title="4.1 FName To FString"></a>4.1 FName To FString</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FName str = FName(TEXT(<span class="string">"hello"</span>));</span><br><span class="line">FString fstr = str.ToString();</span><br></pre></td></tr></table></figure><h4 id="4-2-FName-To-FText"><a href="#4-2-FName-To-FText" class="headerlink" title="4.2 FName To FText"></a>4.2 FName To FText</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FName str = FName(TEXT(<span class="string">"hello"</span>));</span><br><span class="line">FText = FText::FromName(str);</span><br></pre></td></tr></table></figure><h3 id="五、FText"><a href="#五、FText" class="headerlink" title="五、FText"></a>五、FText</h3><p>FText To FString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不可靠，在一些语言中存在损耗</span></span><br><span class="line">FString Name = MyText.ToString();</span><br></pre></td></tr></table></figure></p><h3 id="六、TChar"><a href="#六、TChar" class="headerlink" title="六、TChar*"></a>六、TChar*</h3><p>TChar<em> 与 char</em> 的互相转换<br>主要是使用下面的四个宏定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCHAR_TO_ANSI(str) ANSI_TO_TCHAR(str) TCHAR_TO_UTF8(str) UTF8_TO_TCHAR(str)</span><br></pre></td></tr></table></figure></p><h3 id="七、std-string"><a href="#七、std-string" class="headerlink" title="七、std::string"></a>七、std::string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> To FString</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>std::string MyStdString = “Happy”;<br>FString HappyString(UTF8_TO_TCHAR(MyStdString.c_str()));  //可防止string的中文转换出错<br>To string函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c++<span class="number">11</span>标准增加了全局函数<span class="built_in">std</span>::to_string:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">float</span> val)</span></span>;       <span class="comment">//只能精确到小数点后6位</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">double</span> val)</span></span>;      <span class="comment">//只能精确到小数点后6位</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure></p><p>string To函数<br>string To int<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> n = atoi(str.c_str());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n; <span class="comment">//123</span></span><br></pre></td></tr></table></figure></p><p>double-&gt;string<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有效位数20位   ---据说待考证</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">double</span> b=<span class="number">1245683.141592653</span>;</span><br><span class="line"><span class="keyword">int</span> ndight=<span class="number">20</span>;<span class="comment">//有效数字位数</span></span><br><span class="line">gcvt(b,ndight,buffer);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//一般使用方法:只能精确到小数点后6位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.1415926535897932384</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(d);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 3.141593</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">//使用stringstream，在输入流时使用setprecision设置精度，需包含头文件 &lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">//精度保持到小数点后15位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; setprecision(<span class="number">15</span>) &lt;&lt; d;</span><br><span class="line">str = ss.str();   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 3.14159265358979</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>//对于double类型，setprecision(15) 参数最大有效值为15，超过15，数据就不保证可靠了。<br>string-&gt;double<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"1245683.141592653"</span>;</span><br><span class="line"><span class="keyword">double</span> num=atof(str.c_str());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0.9lf\n"</span>,num);</span><br></pre></td></tr></table></figure></p><h3 id="八、char"><a href="#八、char" class="headerlink" title="八、char*"></a>八、char*</h3><p>char* To FString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FString MyFString = FString(UTF8_TO_TCHAR(MyCharPtr));</span><br></pre></td></tr></table></figure></p><h3 id="九、UE4-Json"><a href="#九、UE4-Json" class="headerlink" title="九、UE4_Json"></a>九、UE4_Json</h3><p>JsonObject To FString<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Jdata转换为了JsonStr</span></span><br><span class="line">FString JsonStr;</span><br><span class="line">TSharedRef&lt;TJsonWriter&lt;&gt;&gt; Writer = TJsonWriterFactory&lt;&gt;::Create(&amp;JsonStr);</span><br><span class="line">FJsonSerializer::Serialize(Jdata.ToSharedRef(), Writer);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、UE4-Source-Header-References&quot;&gt;&lt;a href=&quot;#一、UE4-Source-Header-References&quot; class=&quot;headerlink&quot; title=&quot;一、UE4 Source Header References&quot;&gt;&lt;/a&gt;一、UE4 Source Header References&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CString.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UnrealString.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NameTypes.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringConv.h (TCHAR_TO_ANSI etc)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CString.h可以查到更多，如&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;atoi64 (&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; to int64)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Atod (&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; to &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; precision &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、日志打印&quot;&gt;&lt;a href=&quot;#二、日志打印&quot; class=&quot;headerlink&quot; title=&quot;二、日志打印&quot;&gt;&lt;/a&gt;二、日志打印&lt;/h3&gt;&lt;h4 id=&quot;1-输出字符串到output-log中&quot;&gt;&lt;a href=&quot;#1-输出字符串到output-log中&quot; class=&quot;headerlink&quot; title=&quot;1.输出字符串到output log中&quot;&gt;&lt;/a&gt;1.输出字符串到output log中&lt;/h4&gt;&lt;h4 id=&quot;1-1-最普通的三种&quot;&gt;&lt;a href=&quot;#1-1-最普通的三种&quot; class=&quot;headerlink&quot; title=&quot;1.1 最普通的三种&quot;&gt;&lt;/a&gt;1.1 最普通的三种&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FString filePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UE_LOG(LogTemp, Log, TEXT(&lt;span class=&quot;string&quot;&gt;&quot;Hello,World!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UE_LOG(LogTemp, Warning, TEXT(&lt;span class=&quot;string&quot;&gt;&quot;Hello,World!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UE_LOG(LogTemp, Error, TEXT(&lt;span class=&quot;string&quot;&gt;&quot;Hello,World!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### &lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt; %d打印&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;，%f打印&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;，%s &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="FString" scheme="https://worldnot.com/tags/FString/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统目录结构</title>
    <link href="https://worldnot.com/2022/04/16/LinuxFileSys/"/>
    <id>https://worldnot.com/2022/04/16/LinuxFileSys/</id>
    <published>2022-04-16T07:30:22.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<p>树状目录结构：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p><a id="more"></a> <p>以下是对这些目录的解释：</p><p>/bin：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p><p>/boot：<br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><p>/dev ：<br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p><p>/etc：<br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><p>/home：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p><p>/lib：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><p>/lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>/media：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p><p>/mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p><p>/opt：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p><p>/proc：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><p>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all<br>/root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p><p>/sbin：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p><p>/selinux：<br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p><p>/srv：<br> 该目录存放一些服务启动之后需要提取的数据。</p><p>/sys：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><p>/tmp：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p><p>/usr：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p><p>/usr/bin：<br>系统用户使用的应用程序。</p><p>/usr/sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</p><p>/usr/src：<br>内核源代码默认的放置目录。</p><p>/var：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p><p>/run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p>/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p><p>值得提出的是 /bin、/usr/bin 是给系统用户使用的指令（除 root 外的通用用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树状目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://worldnot.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://worldnot.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UE4PythonHelper</title>
    <link href="https://worldnot.com/2022/03/27/UnrealEnginePythonHelper/"/>
    <id>https://worldnot.com/2022/03/27/UnrealEnginePythonHelper/</id>
    <published>2022-03-27T05:20:10.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE4PythonHelper"><a href="#UE4PythonHelper" class="headerlink" title="UE4PythonHelper"></a>UE4PythonHelper</h1><p>This plugin is only used in editor mode!!!</p><p><img src="/images/ph01.webp" alt="ph01"></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol><li>This plug-in provides an “unreallib.py” module, which contains a complete UnrealEngine Python API. When you use it in text editors such as VS Code, you will get intelligent code prompt, function parameter prompt, return value type inference, comments, etc. you can also jump to the function in the module to view the detailed function definition. It’s better than automatically generated unreal.py file, smaller and compact, and supports the Type Hint syntax of python3.<a id="more"></a> </li><li><p>Automatically detect all Python files in the “$ProjectDir$/ Python” directory and run the file by clicking a button.</p></li><li><p>After clicking the python file, it will automatically identify the functions defined and call them directly by clicking a button (only functions without parameters can be executed)</p></li><li><p>When you edit a file in VS Code, it will automatically detect the change of the file and refresh the list of callable functions. The automatic refresh function can be turned off. Note: when “import” a module for the first time or through “importlib.reload ()” to reload a module, it executes the entire module.</p></li><li><p>You can directly open the python folder of the current work by shortcut.</p></li><li><p>When the panel is closed, all automatic detection will be closed until the panel is reopened.</p></li></ol><h2 id="Startup"><a href="#Startup" class="headerlink" title="Startup"></a>Startup</h2><ol><li>Open PythonHelper Tab( MainMenu -&gt; Window -&gt; PythonHelper)  </li></ol><p><img src="/images/ph02.webp" alt="ph02"></p><h2 id="Known-Issue"><a href="#Known-Issue" class="headerlink" title="Known Issue"></a>Known Issue</h2><ol><li><p>File named in “test.py” or directory named in “test” is not supported.</p></li><li><p>File name or directory start with number is not supported.</p></li><li><p>Numeric directory and file name are not supported.</p></li><li><p>Chinese directory and Chinese file name are not supported.</p></li></ol><h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>本插件只能在编辑器模式下使用</p><h2 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h2><ol><li><p>本插件提供一个 unreallib.py 模块，模块中包含了完整的 UnrealEngine Python API, 当你在VS Code 等编辑器中使用的时候，将获得智能代码提示，函数参数提示，返回值类型推断，注释等，也能跳转到模块中的函数，查看详细的函数定义。</p></li><li><p>自动检测 “$ProjectDir$/ Python” 目录下的所有 python 文件，通过点击按钮运行该文件</p></li><li><p>点选Python文件后，会自动识别文件中定义的函数，通过点击按钮直接调用（只能执行无参数的函数）</p></li><li><p>当你在VS Code 中编辑文件的时候，自动检测文件的变动，并且重新刷新可调用函数列表。自动刷新功能可以关闭。注意：在第一次 import 模块的时候，和通过 importlib.reload() 重新加载模块的时候，会执行整个模块。</p></li><li><p>可以通过快捷方式，直接打开当前工作的Python文件夹</p></li><li><p>当面板关闭的时候，所有的自动检测将会关闭，直到重新打开面板</p></li></ol><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ol><li><p>文件 “test.py” 和目录 “test” 不被支持.</p></li><li><p>以纯数字开头的文件目录和文件名不被支持.</p></li><li><p>纯数字的文件目录和文件名不被支持.</p></li><li><p>不支持中文目录和中文文件名.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UE4PythonHelper&quot;&gt;&lt;a href=&quot;#UE4PythonHelper&quot; class=&quot;headerlink&quot; title=&quot;UE4PythonHelper&quot;&gt;&lt;/a&gt;UE4PythonHelper&lt;/h1&gt;&lt;p&gt;This plugin is only used in editor mode!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ph01.webp&quot; alt=&quot;ph01&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Features&quot;&gt;&lt;a href=&quot;#Features&quot; class=&quot;headerlink&quot; title=&quot;Features&quot;&gt;&lt;/a&gt;Features&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;This plug-in provides an “unreallib.py” module, which contains a complete UnrealEngine Python API. When you use it in text editors such as VS Code, you will get intelligent code prompt, function parameter prompt, return value type inference, comments, etc. you can also jump to the function in the module to view the detailed function definition. It’s better than automatically generated unreal.py file, smaller and compact, and supports the Type Hint syntax of python3.
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="python" scheme="https://worldnot.com/tags/python/"/>
    
      <category term="tools" scheme="https://worldnot.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼编码在 UE4 中的实现</title>
    <link href="https://worldnot.com/2021/12/04/HuffmanEncode/"/>
    <id>https://worldnot.com/2021/12/04/HuffmanEncode/</id>
    <published>2021-12-04T03:05:10.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在UE4 中实现哈夫曼编码的本意是在网络数据传输的时候，进行数据包一定程度的数据压缩。但是实现完之后发现并无用武之地，一个是因为压缩的数据中还必须要包含编码表，对于高频、小数据包反而会增加数据的大小和增加编码解码的计算消耗。二是因为好多要传输的数据本身就是已经编码压缩过了，再次编码压缩已经没有效果了（比如UE4 的 RenderTarget 图像数据 和 VoiceData）。所以权当是一次代码练习吧。</p></blockquote><h2 id="关于哈夫曼编码"><a href="#关于哈夫曼编码" class="headerlink" title="关于哈夫曼编码"></a>关于哈夫曼编码</h2><p>Huffman于1952年提出一种编码方法，该方法完全依据出现概率来构造异字头的平均长度最短的码字 。简单来说就是用最少的bit来表示出现频率最高的字符，生成一张编码对照表，解码的时候根据对照表依次还原就行。<br>比如 “aabccade”，其中总共有a、b、c、d、e 五个字符，a出现3次，c出现2次，b、d、e出现1次，<br>那么可以用0表示a，用1表示c，用10表示b，用11表示d，用100表示e。所以原字符就可以用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span><span class="number">-0</span><span class="number">-10</span><span class="number">-1</span><span class="number">-1</span><span class="number">-0</span><span class="number">-11</span><span class="number">-100</span></span><br></pre></td></tr></table></figure></p><p>来表示了。当然具体实现细节要更复杂一点，涉及到二叉树，前缀码等。</p><p>好了，话不多说，上代码！<br><a id="more"></a> </p><p>HuffmanEncode.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETBIT(souce, index) souce |= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 设置0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEARBIT(souce, index) souce &amp;= ~(1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 位取反</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVERSEBIT(souce, index) souce ^= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 获取位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETBIT(souce, index) ((souce) &gt;&gt; (index) &amp; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">DECLARE_LOG_CATEGORY_EXTERN(HuffmanEncode, Log, All);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Huffman</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一颗 哈夫曼 树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ch = <span class="string">'\0'</span>; <span class="comment">// 该节点中的字符</span></span><br><span class="line"><span class="keyword">int</span> freq = <span class="number">0</span>; <span class="comment">// 该节点字符出现的次数（频率）</span></span><br><span class="line">Node* left = <span class="literal">nullptr</span>; <span class="comment">// 左叶子节点</span></span><br><span class="line">Node* right = <span class="literal">nullptr</span>; <span class="comment">// 右叶子节点</span></span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">unsigned</span> <span class="keyword">char</span> _c, <span class="keyword">int</span> f, Node* l = <span class="literal">nullptr</span>, Node* r = <span class="literal">nullptr</span>)</span><br><span class="line">:ch(_c), freq(f), left(l), right(r)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~Node()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; "~ Node " &lt;&lt; this-&gt;ch &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt; 运算符，在加入优先队列的时候决定如何处理结点位置</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> freq &gt; node.freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从输入流中读字节流，并将编码后的结果写入输出流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* inData, <span class="keyword">const</span> <span class="keyword">int</span> dataNum, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码</span></span><br><span class="line"><span class="comment"> * 读取编码的比特流，</span></span><br><span class="line"><span class="comment"> * 将比特流对应为路径在单词查找树上找，将找到的结点中的字符写出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span> dataSize, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataSize)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============= 辅助函数 ============ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delTree</span><span class="params">(Node* root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读比特流，得出一颗单词查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node* <span class="title">readTree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span>&amp; nodeIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将单词查找树编码成比特输出串并写入到输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTree</span><span class="params">(Node* x, <span class="keyword">int</span>&amp; count, <span class="keyword">unsigned</span> <span class="keyword">char</span>* tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建编译表，每个char值与一个比特字符串（即Huffman树上路径）的对照表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(<span class="built_in">string</span> st[], Node* x, <span class="built_in">string</span> s)</span></span>; <span class="comment">// st[63] = "001"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param freq 字符出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> freq[], <span class="keyword">int</span>&amp; outLeafNum)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HuffmanEncode.cpp </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HuffmanEncode.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">DEFINE_LOG_CATEGORY(HuffmanEncode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Huffman</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* inData, <span class="keyword">const</span> <span class="keyword">int</span> dataNum, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 计算【ascii 0-255】每个字符出现的次数，数组的index就是字符的值，数组的值是字符出现的次数</span></span><br><span class="line"><span class="keyword">int</span> freq[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataNum; i++) &#123;</span><br><span class="line">freq[inData[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 构建Huffman树</span></span><br><span class="line"><span class="keyword">int</span> leafNum = <span class="number">0</span>; <span class="comment">// 叶子节点数量</span></span><br><span class="line">Node* root = buildTree(freq, leafNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 构建编译表，每个char值与一个比特字符串（即Huffman树上路径）的对照表</span></span><br><span class="line"><span class="built_in">string</span> st[<span class="number">256</span>] = &#123; <span class="string">""</span> &#125;;</span><br><span class="line">buildCode(st, root, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 将单词查找树编码成比特输出串并写入到buff</span></span><br><span class="line">short <span class="keyword">int</span> treeByteNum = leafNum * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* tree = &amp;outData[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> currentByteIndex = <span class="number">0</span>; <span class="comment">// 当前写到第几个字节</span></span><br><span class="line">writeTree(root, currentByteIndex, tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用前面 1 个字节存储最后个1字节写到第几个bit,从0开始算起</span></span><br><span class="line"><span class="comment">// outData[0] = xxx;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 将单词总数编码成比特输出串并写入到输出流</span></span><br><span class="line"><span class="keyword">int</span> outBitCount = <span class="number">0</span>; <span class="comment">// 写当前字节的第几位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* outBitBuff = &amp;outData[treeByteNum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> outBuffCount = <span class="number">0</span>; <span class="comment">// 当前在写第几个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataNum; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> code = st[inData[i]];   <span class="comment">//code表示Huffman单词查找数上的路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; code.length(); j++) &#123;  <span class="comment">//要一位一位地输出</span></span><br><span class="line"><span class="keyword">if</span> (code[j] == <span class="string">'1'</span>)</span><br><span class="line">&#123;</span><br><span class="line">SETBIT(outBitBuff[outBuffCount], outBitCount);</span><br><span class="line">outBitCount++;</span><br><span class="line"><span class="keyword">if</span> (outBitCount == <span class="number">8</span>) &#123; outBitCount = <span class="number">0</span>; outBuffCount++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">CLEARBIT(outBitBuff[outBuffCount], outBitCount);</span><br><span class="line">outBitCount++;</span><br><span class="line"><span class="keyword">if</span> (outBitCount == <span class="number">8</span>) &#123; outBitCount = <span class="number">0</span>; outBuffCount++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经压缩的字节总数</span></span><br><span class="line"><span class="keyword">int</span> inDataEncodeByte = outBuffCount + (outBitCount &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用前面 1 个字节存储最后个1字节写到第几个bit,从0开始算起</span></span><br><span class="line">outData[<span class="number">0</span>] = outBitCount;</span><br><span class="line"></span><br><span class="line">outDataNum = <span class="number">1</span> + treeByteNum + inDataEncodeByte;</span><br><span class="line">UE_LOG(HuffmanEncode, Warning, TEXT(<span class="string">"======= Encode finished ========="</span>));</span><br><span class="line">delTree(root);  <span class="comment">// 清空内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span> dataSize, <span class="keyword">unsigned</span> <span class="keyword">char</span>* outData, <span class="keyword">int</span>&amp; outDataSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1，获取最后一个字节需要读到第几个bit</span></span><br><span class="line"><span class="keyword">int</span> lastByteBitCount = indata[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2，读出查找树</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* treeData = &amp;indata[<span class="number">1</span>];</span><br><span class="line">Node* root = readTree(treeData, index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3，</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* encodedData = &amp;indata[index + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> N = dataSize - index - <span class="number">2</span>;  <span class="comment">//读出存在压缩文件中的字符串长度</span></span><br><span class="line"></span><br><span class="line">outDataSize = <span class="number">0</span>;</span><br><span class="line">Node* x = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;   <span class="comment">//找出源文件中每个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == N - <span class="number">1</span> &amp;&amp; j == lastByteBitCount + <span class="number">1</span>) <span class="comment">// </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!x-&gt;isLeaf()) <span class="comment">//遍历，直到叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (GETBIT(encodedData[i], j)) &#123;</span><br><span class="line">x = x-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x = x-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; " decode is " &lt;&lt; x-&gt;ch &lt;&lt; endl;</span></span><br><span class="line">outData[outDataSize] = x-&gt;ch;</span><br><span class="line">outDataSize++;</span><br><span class="line">j--;</span><br><span class="line">x = root; <span class="comment">// 重新从根节点出发</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UE_LOG(HuffmanEncode, Warning, TEXT(<span class="string">"======= Decode finished ========="</span>));</span><br><span class="line">delTree(root); <span class="comment">// 清空内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delTree</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root-&gt;isLeaf()) <span class="comment">//读到1，说明是叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">delTree(root-&gt;left);</span><br><span class="line">delTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">readTree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* indata, <span class="keyword">int</span>&amp; nodeIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nodeIndex++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indata[nodeIndex] == <span class="number">1</span>) <span class="comment">//读到1，说明是叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">nodeIndex++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(indata[nodeIndex], <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//读到的是0，说明是中间结点，需要递归直到读到1为止</span></span><br><span class="line">&#123;</span><br><span class="line">Node* left = readTree(indata, nodeIndex);</span><br><span class="line">Node* right = readTree(indata, nodeIndex);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTree</span><span class="params">(Node* x, <span class="keyword">int</span>&amp; count, <span class="keyword">unsigned</span> <span class="keyword">char</span>* tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x-&gt;isLeaf()) &#123;</span><br><span class="line">tree[count] = <span class="number">1</span>; count++;</span><br><span class="line">tree[count] = x-&gt;ch;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree[count] = <span class="number">0</span>; count++;</span><br><span class="line">writeTree(x-&gt;left, count, tree);</span><br><span class="line">writeTree(x-&gt;right, count, tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(<span class="built_in">string</span> st[], Node* x, <span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x-&gt;isLeaf()) &#123;</span><br><span class="line">buildCode(st, x-&gt;left, s + <span class="string">"0"</span>);</span><br><span class="line">buildCode(st, x-&gt;right, s + <span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">st[x-&gt;ch] = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> freq[], <span class="keyword">int</span>&amp; outLeafNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小列队</span></span><br><span class="line">priority_queue&lt;Node&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化多个将构成一颗Huffman树的结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>) pq.push(Node(i, freq[i], <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outLeafNum = pq.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// special case in case there is only one character with a nonzero frequency</span></span><br><span class="line"><span class="keyword">if</span> (pq.size() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (freq[<span class="string">'\0'</span>] == <span class="number">0</span>) pq.push(Node(<span class="string">'\0'</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line"><span class="keyword">else</span> pq.push(Node(<span class="string">'\1'</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并两个小树</span></span><br><span class="line"><span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">Node* left = <span class="keyword">new</span> Node(pq.top()); pq.pop();</span><br><span class="line">Node* right = <span class="keyword">new</span> Node(pq.top()); pq.pop();</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, left-&gt;freq + right-&gt;freq, left, right);<span class="comment">//创建连接子树的中间结点</span></span><br><span class="line">pq.push(*parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* root = <span class="keyword">new</span> Node(pq.top()); pq.pop();</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝图代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TArray&lt;uint8&gt; <span class="title">UBPFLibrary::HFM_Encode</span><span class="params">(TArray&lt;uint8&gt; indata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8* outdata = <span class="keyword">new</span> uint8[indata.Num()* <span class="number">3</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> outdatasize =<span class="number">0</span>;</span><br><span class="line">    Huffman::Encode(indata.GetData),indata.Numo,outdata, outdatasize);</span><br><span class="line">    TArray&lt;uint8&gt; outdatal;</span><br><span class="line">    outdata1.Init(o,outdatasize);</span><br><span class="line">    FMemory::Memcpy(outdata1.GetData(),outdata,outdatasize);</span><br><span class="line">    <span class="keyword">return</span> outdatal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt;UBPFLibrary::HFM_Decode(TArray&lt;uint8&gt; indata)</span><br><span class="line">&#123;</span><br><span class="line">    uint8* outdata = <span class="keyword">new</span> uint8[indata.Num)* <span class="number">3</span>]&#123; e &#125;;</span><br><span class="line">    <span class="keyword">int</span> outdatasize = <span class="number">0</span>;</span><br><span class="line">    Huffman::Decode(indata.GetData(),indata.Num(),outdata, outdatasize);</span><br><span class="line">    TArray&lt;uint8&gt;outdatal;</span><br><span class="line">    outdata1.Init(e,outdatasize);</span><br><span class="line">    FMemory::Memcpy(outdata1.GetData(),outdata,outdatasize);</span><br><span class="line">    <span class="keyword">return</span> outdatal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在UE4 中实现哈夫曼编码的本意是在网络数据传输的时候，进行数据包一定程度的数据压缩。但是实现完之后发现并无用武之地，一个是因为压缩的数据中还必须要包含编码表，对于高频、小数据包反而会增加数据的大小和增加编码解码的计算消耗。二是因为好多要传输的数据本身就是已经编码压缩过了，再次编码压缩已经没有效果了（比如UE4 的 RenderTarget 图像数据 和 VoiceData）。所以权当是一次代码练习吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于哈夫曼编码&quot;&gt;&lt;a href=&quot;#关于哈夫曼编码&quot; class=&quot;headerlink&quot; title=&quot;关于哈夫曼编码&quot;&gt;&lt;/a&gt;关于哈夫曼编码&lt;/h2&gt;&lt;p&gt;Huffman于1952年提出一种编码方法，该方法完全依据出现概率来构造异字头的平均长度最短的码字 。简单来说就是用最少的bit来表示出现频率最高的字符，生成一张编码对照表，解码的时候根据对照表依次还原就行。&lt;br&gt;比如 “aabccade”，其中总共有a、b、c、d、e 五个字符，a出现3次，c出现2次，b、d、e出现1次，&lt;br&gt;那么可以用0表示a，用1表示c，用10表示b，用11表示d，用100表示e。所以原字符就可以用&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-10&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来表示了。当然具体实现细节要更复杂一点，涉及到二叉树，前缀码等。&lt;/p&gt;
&lt;p&gt;好了，话不多说，上代码！&lt;br&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="编码" scheme="https://worldnot.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="哈夫曼" scheme="https://worldnot.com/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/"/>
    
  </entry>
  
  <entry>
    <title>C++ 智能指针</title>
    <link href="https://worldnot.com/2021/09/12/smartpointer01/"/>
    <id>https://worldnot.com/2021/09/12/smartpointer01/</id>
    <published>2021-09-12T03:56:23.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇不对智能指针的实现原理做详细研究，只讨论为什么要使用智能指针，以及使用规范和注意事项。</p></blockquote><h2 id="关于指针和智能指针"><a href="#关于指针和智能指针" class="headerlink" title="关于指针和智能指针"></a>关于指针和智能指针</h2><p>指针是一个变量，存储一块内存区域的地址。<br>指针指向一块内存，通过该指针可随意修改或者删除其中内容，那么我们可以说这个指针对这块内存具有所有权(ownership) 。</p><p>PS:通常说的指向一个对象的指针，严格意义上来说应该是指向一个对象所在内存的指针。指针可以说和对象本身是没关系的，只是对象的类型(class)更详细的描述这块内存区域存的是什么内容。</p><p>指针存在的意义:<br>1.访问特定内存中的数据<br>2.管理所拥有的内存，不再使用的内存要及时通知系统释放  </p><p>裸指针能满足以上的访问和管理内存的需求，但是存在缺陷:<br> <strong>多个指针可以指向同一块内存</strong><br>也就是意味着权限混乱，比如创建(new)多个指针指向同一块内存，但是每个指针使用完毕，都没有释放(delete)，从而导致内存泄露。<br>或者所有的指针只要自己使用完毕就去释放内存，势必会造成正在使用该内存的地方产生未知结果，或者重复释放(delete)同一块内存导致崩溃。</p><a id="more"></a> <p>案例一:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Entity* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// e 的生命周期有多长，在我使用过程中会被其他函数删除吗？</span></span><br><span class="line"><span class="comment">// 我用完了e，需要删除它吗？删除它会对其他引用e 的地方造成未知影响吗？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = <span class="keyword">new</span> Entity();</span><br><span class="line">e-&gt;dosomething();</span><br><span class="line">foo(e);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存泄露了，e 的内存没有被释放</span></span><br></pre></td></tr></table></figure></p><p>智能指针就是为了解决这些问题而出现的。<br><strong>意味着不再使用 new 和 delete。</strong></p><p>三种智能指针:<br>unique_ptr 独占指针<br>shared_ptr 共享指针<br>weak_ptr  弱指针  </p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>同一时刻只能有一个unique_ptr指针指向一块内存；<br>独占所有权，所有权可以转移，转移之后该指针不可使用；<br>离开作用域之时，指向的内存自动释放(默认使用delete操作符，用户可指定其他操作)。<br>（通过禁止拷贝语义、只有移动语义来实现）。<br>基本操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Entity() construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Entity() destruct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" Do something "</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Entity&gt; <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp_entity = make_unique&lt;Entity&gt;();</span><br><span class="line">    <span class="keyword">return</span> temp_entity; <span class="comment">// 转移所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;Entity&gt; entity_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    entity_-&gt;DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========enter scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Entity&gt; entity1 = make_unique&lt;Entity&gt;(); <span class="comment">//推荐用法创建唯一指针</span></span><br><span class="line"><span class="keyword">auto</span> entity2 = make_unique&lt;Entity&gt;(); <span class="comment">//推荐用法创建</span></span><br><span class="line"><span class="keyword">auto</span> entity3 = move(entity2); <span class="comment">// 转移所有权</span></span><br><span class="line">foo(move(entity3)); <span class="comment">// 转移所有权</span></span><br><span class="line">foo(bar());</span><br><span class="line"></span><br><span class="line">Entity* rawe = entity1.release(); <span class="comment">// 放弃所有权，并置为nullptr，不释放内存，返回对象的裸指针。请慎重操作</span></span><br><span class="line"><span class="keyword">delete</span> rawe;</span><br><span class="line"></span><br><span class="line">entity1.reset(<span class="comment">/* p */</span>); <span class="comment">// 释放内存，并置为nullptr。如果传入一个裸指针p作为参数，则释放内存后重新指向p。</span></span><br><span class="line">entity1 = <span class="literal">nullptr</span>; <span class="comment">// 释放内存，并置为nullptr。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave main scope========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用智能指针来实现文章开头的案例一<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;Entity&gt; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e-&gt;DoSomething();</span><br><span class="line"><span class="comment">// e 离开作用域会自动释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = make_unique&lt;Entity&gt;(); <span class="comment">// 创建智能指针</span></span><br><span class="line">e-&gt;dosomething();</span><br><span class="line">foo(move(e));  <span class="comment">// 转移所有权</span></span><br><span class="line"><span class="comment">// e 的权限被转移，以下不可以使用e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 没有内存泄露</span></span><br></pre></td></tr></table></figure></p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个shared_ptr指向同一块内存，当所有shared_ptr都全部释放时，该内存释放。每个shared_ptr都对这块内存有所有权。<br>简单实现原理:<br>一个对象被shared_ptr指针引用的次数，由一个计数对象来记录。每次复制一个shared_ptr，计数+1，每次释放(主动调用或者离开作用域时)一个shared_ptr，计数-1，当计数为0时，释放该对象所在内存。<br>基本操作:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">Entity(<span class="keyword">int</span> id_)</span><br><span class="line">&#123;</span><br><span class="line">id=id_;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Entity(id"</span>&lt;&lt; id &lt;&lt;<span class="string">") construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Entity(id"</span>&lt;&lt; id &lt;&lt;<span class="string">") destruct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" Do something "</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp_entity = make_shared&lt;Entity&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> temp_entity; <span class="comment">// 移动所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Entity&gt; entity_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"entity"</span>&lt;&lt; entity_-&gt;getId() &lt;&lt;<span class="string">"转移所有权到函数后计数"</span>&lt;&lt; entity_.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    entity_-&gt;DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========enter scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Entity&gt; entity0 = make_shared&lt;Entity&gt;(<span class="number">0</span>); <span class="comment">//推荐用法创建共享指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> entity1 = make_shared&lt;Entity&gt;(<span class="number">1</span>); <span class="comment">//推荐用法创建</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1创建赋值后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> entity2 = entity1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1复制赋值后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> entity3 = move(entity2); <span class="comment">// 移动所有权</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1转移所有权后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">foo(move(entity3)); <span class="comment">// 移动所有权</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"entity1离开函数作用域后计数"</span>&lt;&lt; entity1.use_count()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">foo(bar());</span><br><span class="line"></span><br><span class="line">entity1.reset(<span class="comment">/* p */</span>); <span class="comment">// 释放内存，并置为nullptr。如果传入一个裸指针p作为参数，则释放内存后重新指向p。</span></span><br><span class="line">entity1 = <span class="literal">nullptr</span>; <span class="comment">// 释放内存，并置为nullptr。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave scope 1========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========leave main scope========="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 只能和shared_ptr搭配使用的。<br>弱指针的弱是相对于shared_ptr和unique_ptr对对象的所有权来说的。shared_ptr和unique_ptr的所有权关乎所指对象的生死(销毁)。<br>weak_ptr只是提供一种访问对象的途径，没有对对象的所有权。通俗点可以说先用weak_ptr占个坑位，但并不能直接使用它。<br>使用之前先检查所指向的对象是否已经销毁( expired() )，如果没销毁就通过调用weak_ptr.lock()获得一个shared_ptr同时对象的引用计数+1。<br>至于weak_ptr，有几个关键词，循环引用，多线程保活，比较复杂，但是又不是很常用，所以打算另写一篇来记录。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于指针到底指向什么？<br>指针就是一块内存区域的地址，所以可以说指向一块内存区域是没问题的。<br>但是有的时候又希望表述为指向一个对象（c++ 中一切皆对象），可以说指向一个空对象，可以说指向的对象被销毁了。我觉得都没问题，因为指针虽然是一个地址，但是指针大部分情况是带着类型信息的，就是用来描述所指向的内存中的数据的组织方式，类型信息决定了如何正确使用这块内存中的记录的一堆东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇不对智能指针的实现原理做详细研究，只讨论为什么要使用智能指针，以及使用规范和注意事项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于指针和智能指针&quot;&gt;&lt;a href=&quot;#关于指针和智能指针&quot; class=&quot;headerlink&quot; title=&quot;关于指针和智能指针&quot;&gt;&lt;/a&gt;关于指针和智能指针&lt;/h2&gt;&lt;p&gt;指针是一个变量，存储一块内存区域的地址。&lt;br&gt;指针指向一块内存，通过该指针可随意修改或者删除其中内容，那么我们可以说这个指针对这块内存具有所有权(ownership) 。&lt;/p&gt;
&lt;p&gt;PS:通常说的指向一个对象的指针，严格意义上来说应该是指向一个对象所在内存的指针。指针可以说和对象本身是没关系的，只是对象的类型(class)更详细的描述这块内存区域存的是什么内容。&lt;/p&gt;
&lt;p&gt;指针存在的意义:&lt;br&gt;1.访问特定内存中的数据&lt;br&gt;2.管理所拥有的内存，不再使用的内存要及时通知系统释放  &lt;/p&gt;
&lt;p&gt;裸指针能满足以上的访问和管理内存的需求，但是存在缺陷:&lt;br&gt; &lt;strong&gt;多个指针可以指向同一块内存&lt;/strong&gt;&lt;br&gt;也就是意味着权限混乱，比如创建(new)多个指针指向同一块内存，但是每个指针使用完毕，都没有释放(delete)，从而导致内存泄露。&lt;br&gt;或者所有的指针只要自己使用完毕就去释放内存，势必会造成正在使用该内存的地方产生未知结果，或者重复释放(delete)同一块内存导致崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://worldnot.com/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://worldnot.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>宏 Macro</title>
    <link href="https://worldnot.com/2021/09/05/macro/"/>
    <id>https://worldnot.com/2021/09/05/macro/</id>
    <published>2021-09-04T23:43:11.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇是关于宏定义的一些知识总结</p></blockquote><h3 id="1-预处理-preprocess"><a href="#1-预处理-preprocess" class="headerlink" title="1. 预处理 preprocess"></a>1. 预处理 preprocess</h3><p>根据程序中的预处理指令，预处理器把宏名替换成其表示的内容–宏展开（macro expansion）；<br>预处理器指令从#开始运行，到后面的第1个换行符为止(指用Enter按下的换行，而不是 \n)。即：指令的长度仅限于一行；<br>在预处理开始前，编译器会把多行物理行（physical line）处理为一行逻辑行（logical line）。即：找到反斜杠\后面的换行符，把反斜杠和换行符删掉<br>双引号字符串中的文本不会被宏替换！<br> <a id="more"></a></p><h3 id="2-宏定义常量和表达式"><a href="#2-宏定义常量和表达式" class="headerlink" title="2. 宏定义常量和表达式"></a>2. 宏定义常量和表达式</h3><p>宏定义只做简单的替换，不计算，不对表达式求值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14<span class="comment">// 定义常量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR (2*2)<span class="comment">// 定义表达式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIX (2 * 3)<span class="comment">// 不要求代码中用空格来分隔记号（token：2 * 3 代表三个token，2*3 是一个token）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIGHT (2 \</span></span><br><span class="line">*<span class="number">4</span>)<span class="comment">// 反斜杠扩展逻辑行</span></span><br></pre></td></tr></table></figure></p><p>关于 #define 和 const 定义常量</p><p>#define 定义的常量是直接替换，没有类型检查，而 const 有对应的数据类型，有类型检查  </p><p>#define 仅展开，不分配内存；const 会分配内存；#define 定义的常量占用代码段的内存，const 定义的常量占用数据段的内存</p><p>#define 可以通过 #undef 取消再重新定义，const 不能重定义。</p><blockquote><p>建议！！！只使用const常量而不使用宏常量。</p></blockquote><h3 id="3-在宏定义中使用参数"><a href="#3-在宏定义中使用参数" class="headerlink" title="3. 在宏定义中使用参数"></a>3. 在宏定义中使用参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVSQR(x) (1/((x)*(x))) <span class="comment">// 求x平方的倒数</span></span></span><br></pre></td></tr></table></figure><blockquote><p>建议！！！用()把所有的参数和整个替换体包裹起来<br>建议！！！不要在宏中使用递增或递减运算符(++,–)</p></blockquote><h4 id="3-1-运算符-，-，以及宏VA-ARGS"><a href="#3-1-运算符-，-，以及宏VA-ARGS" class="headerlink" title="3.1 运算符 #，##，以及宏VA_ARGS"></a>3.1 运算符 #，##，以及宏<strong>VA_ARGS</strong></h4><h5 id="3-1-1-把记号-token-转换成字符串"><a href="#3-1-1-把记号-token-转换成字符串" class="headerlink" title="3.1.1 # :把记号(token)转换成字符串"></a>3.1.1 # :把记号(token)转换成字符串</h5><p>例如，如果x是一个宏形参，那么#x就是转换为字符串”x”的形参名。这个过程称为字符串化（stringizing）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_ARG_NANE(x) printf(#x <span class="meta-string">"\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTSQR(x) printf(<span class="meta-string">"The square of "</span> #x <span class="meta-string">" is %d \n"</span>, ((x)*(x))) <span class="comment">// ANSI C字符串可以自动串联</span></span></span><br></pre></td></tr></table></figure></p><h5 id="3-1-2-连接运算符"><a href="#3-1-2-连接运算符" class="headerlink" title="3.1.2 ## :连接运算符"></a>3.1.2 ## :连接运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x##n <span class="comment">// 给传入的宏参数加上一个x前缀  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTXN(n) printf(<span class="meta-string">"x"</span> #n <span class="meta-string">" is %d \n"</span> , x##n) <span class="comment">// 注意其中的x就等于是你键盘敲入的一个x，不代表其他任何东西</span></span></span><br></pre></td></tr></table></figure><h5 id="3-1-3-VA-ARGS-宏"><a href="#3-1-3-VA-ARGS-宏" class="headerlink" title="3.1.3 __VA_ARGS__宏"></a>3.1.3 __VA_ARGS__宏</h5><p>__VA_ARGS__就是把…表示的参数包，原封不动的抄过去<br> … 表示可变的参数（variadic argument）,包括里面的逗号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变参数不可为空</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPRINT(...) \</span></span><br><span class="line">        <span class="built_in">printf</span>(__VA_ARGS__)</span><br></pre></td></tr></table></figure><p>如果可变参数为空，就会出现一个多余的逗号printf(,)会报错<br>“##”操作符如果一侧没有内容就会连接失败，并且删除两侧要连接的内容，此处就会删除这个多余的逗号<br>也可以给可变参数…起个名字，而不用__VA_ARGS__，使用方法和效果是完全一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(fomart, args...) \</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"debug: "</span> fomart, ##args)</span><br></pre></td></tr></table></figure><p>测试代码及结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; FOUR * (SIX + EIGHT) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 56</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; SIX / EIGHT &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; EIGHT &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"EIGHT"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// EIGHT 双引号字符串中的文本不会被宏替换</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; INVSQR(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; INVSQR(<span class="number">2.f</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> int_a = <span class="number">10</span>;</span><br><span class="line">    PRINT_ARG_NANE(int_a); <span class="comment">// int_a</span></span><br><span class="line">    PRINTSQR(int_a); <span class="comment">// The square of int_a is 100</span></span><br><span class="line">    PRINTSQR(<span class="number">4</span> + <span class="number">6</span>); <span class="comment">// The square of 4 + 6 is 100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">10</span>; <span class="comment">//  展开后：int x1 = 10;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">20</span>; <span class="comment">//  展开后：int x2 = 20;</span></span><br><span class="line">    <span class="keyword">int</span> x3 = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 20</span></span><br><span class="line">    PRINTXN(<span class="number">3</span>); <span class="comment">// x3 is 30</span></span><br><span class="line">    </span><br><span class="line">    MYPRINT(<span class="string">"a = %d \n"</span>, <span class="number">5</span>); <span class="comment">// a = 5</span></span><br><span class="line">    DEBUG(<span class="string">"a = %d \n"</span>, <span class="number">5</span>); <span class="comment">// debug: a = 5</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他<br>预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma<br>关键字：_Generic、_Noreturn、_Static_assert<br>函数/宏：sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_copy()、va_end()</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇是关于宏定义的一些知识总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-预处理-preprocess&quot;&gt;&lt;a href=&quot;#1-预处理-preprocess&quot; class=&quot;headerlink&quot; title=&quot;1. 预处理 preprocess&quot;&gt;&lt;/a&gt;1. 预处理 preprocess&lt;/h3&gt;&lt;p&gt;根据程序中的预处理指令，预处理器把宏名替换成其表示的内容–宏展开（macro expansion）；&lt;br&gt;预处理器指令从#开始运行，到后面的第1个换行符为止(指用Enter按下的换行，而不是 \n)。即：指令的长度仅限于一行；&lt;br&gt;在预处理开始前，编译器会把多行物理行（physical line）处理为一行逻辑行（logical line）。即：找到反斜杠\后面的换行符，把反斜杠和换行符删掉&lt;br&gt;双引号字符串中的文本不会被宏替换！&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://worldnot.com/categories/C-C/"/>
    
    
      <category term="宏" scheme="https://worldnot.com/tags/%E5%AE%8F/"/>
    
      <category term="macro" scheme="https://worldnot.com/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Working with git and ssh</title>
    <link href="https://worldnot.com/2021/08/29/git-ssh/"/>
    <id>https://worldnot.com/2021/08/29/git-ssh/</id>
    <published>2021-08-29T01:26:22.000Z</published>
    <updated>2022-10-08T09:54:45.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>从2021年8月14日之后，使用git对github进行身份验证操作的时候不再接受使用账号密码形式clone和push代码，必须使用acces_token或者基于SSH 的方式了。本文记录SSH 的使用过程。</p></blockquote><h3 id="一、生成shh密钥"><a href="#一、生成shh密钥" class="headerlink" title="一、生成shh密钥"></a>一、生成shh密钥</h3><p>进入 .ssh 目录，windows下一般在默认用户文件夹下 <code>Users/Administrator/.ssh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\Administrator\.ssh</span><br><span class="line"></span><br><span class="line">ssh -V <span class="comment"># 查看版本号，确认是否安装ssh</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"email@abc.com"</span> <span class="comment"># 生成ssh密钥</span></span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_pubrepo <span class="comment"># 此处输入密钥的名称，方便后面管理多个密钥</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="comment"># 回车</span></span><br><span class="line">Enter same passphrase again:<span class="comment"># 回车</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> id_rsa_pubrepo.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> id_rsa_pubrepo.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:xxxxxxxxxxxxx email@abc.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|     .   . .     |</span></span><br><span class="line"><span class="string">|    o =   oo.    |</span></span><br><span class="line"><span class="string">|     . ..*+. .   |</span></span><br><span class="line"><span class="string">|    .  .o.B.*    |</span></span><br><span class="line"><span class="string">|    . *.E=o      |</span></span><br><span class="line"><span class="string">|     ..+*B=      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><a id="more"></a> <h3 id="二、将公钥部署到github"><a href="#二、将公钥部署到github" class="headerlink" title="二、将公钥部署到github"></a>二、将公钥部署到github</h3><p>查看并复制公钥内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa_pubrepo.pub <span class="comment"># 查看公钥，注意是.pub后缀的文件</span></span><br><span class="line"></span><br><span class="line">cat id_rsa_pubrepo.pub | clip <span class="comment"># windows下复制文件内容到剪贴板</span></span><br></pre></td></tr></table></figure><p>登录github，点击头像；</p><p>在Settings -&gt; SSH and GPG keys 设置项中；</p><p>点击New SSH key，粘贴刚才复制的内容(“ ssh-rsa AAA…..= ”)，并输入名称。</p><p>至此，你就可以clone和push该github账户下的所有的仓库内容了。</p><blockquote><p>PS：远程地址一定要用ssh地址 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:XXX/XXX.git ，而不是HTTPS地址。</p></blockquote><h3 id="三、管理多个ssh密钥"><a href="#三、管理多个ssh密钥" class="headerlink" title="三、管理多个ssh密钥"></a>三、管理多个ssh密钥</h3><h4 id="1、多个ssh部署到多个github账户"><a href="#1、多个ssh部署到多个github账户" class="headerlink" title="1、多个ssh部署到多个github账户"></a>1、多个ssh部署到多个github账户</h4><p>因为每个ssh key只能在github上部署一次，如果我们要管理多个github账号，那么就必须生成多个 ssh key，并且用 config 来管理，这样在进行仓库操作的时候，git才知道该使用那么key。</p><p>假如我们有两个 github账号：Account01，Account02；</p><p>首先创建两个 ssh key：id_rsa_mykey01，id_rsa_mykey02</p><p>在 .ssh 目录下创建 config 文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为每个ssh key配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可</span></span><br><span class="line"><span class="comment"># Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如：</span></span><br><span class="line"><span class="comment"># Host mygithub 这样定义的话，命令如下，即git@后面紧跟的名字改为mygithub</span></span><br><span class="line"><span class="comment"># git clone git@mygithub:PopFisher/AndroidRotateAnim.git</span></span><br><span class="line"><span class="comment"># HostName 　　　　　　　   这个是真实的域名地址</span></span><br><span class="line"><span class="comment"># IdentityFile 　　　　　　　  这里是id_rsa的地址，  # 可以指定特定的ssh私钥文件</span></span><br><span class="line"><span class="comment"># PreferredAuthentications   配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等</span></span><br><span class="line"><span class="comment"># User 　　　　　　　　　　　配置使用用户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Host01</span></span><br><span class="line">Host Host01</span><br><span class="line">  HostName github.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_mykey01</span><br><span class="line"></span><br><span class="line"><span class="comment"># Host02</span></span><br><span class="line">Host Host02</span><br><span class="line">  HostName github.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_mykey02</span><br></pre></td></tr></table></figure><p>以上我们配置了2个 Host：</p><p>host01 对应 id_rsa_mykey01 ，id_rsa_mykey01.pub 配置到github 的账号 Account01的 SSH and GPG keys  中；</p><p>host02 对应 id_rsa_mykey02 ，id_rsa_mykey02.pub 配置到github 的账号 Account02的 SSH and GPG keys  中。</p><p>假如我们 clone  Account01 的 mydemo 项目，我们会得到克隆地址  <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Account01/mydemo.git ,不能直接使用，需要把改为 git@Host01:Account01/mydemo.git ，也就是说我们的git项目的远程HostName，以及认证文件的配置采用.ssh  config 中的Host01，账号Account02的项目同理。</p><p>至此，我们在同一台电脑上，用多个ssh key 分别管理了多个github 账号中的仓库文件。</p><h4 id="2、为单个repository部署Deploy-key"><a href="#2、为单个repository部署Deploy-key" class="headerlink" title="2、为单个repository部署Deploy key"></a>2、为单个repository部署Deploy key</h4><p>有的项目是小组多人协同开发的，同一个github下有多个项目，那么如何给每一个仓库设置单独的ssh key呢？</p><p>我们需要配置 Deploy keys。</p><p>打开仓库的 Settings （不同与账户的 Setting），在Deploy keys 设置项中点击 add deploy key 添加。</p><p>至此，我们的账户中配置了 ssh key，用该 key 配对的私钥，可以操作该账户下的所有的仓库的代码。</p><p>而仓库单独设置的 Deploy key 对于的私钥，只能访问和操作该仓库，对其他仓库没有权限。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>github已经不再接受使用账号密码形式。</p><p>ssh key配置方法可以免登录账号密码。</p><p>多个ssh key，需要用config 来配置。</p><p>账户中配置的 ssh key，可以操作该账户下的所有的仓库的代码。</p><p>仓库的 Deploy key 只能操作该仓库。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;从2021年8月14日之后，使用git对github进行身份验证操作的时候不再接受使用账号密码形式clone和push代码，必须使用acces_token或者基于SSH 的方式了。本文记录SSH 的使用过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、生成shh密钥&quot;&gt;&lt;a href=&quot;#一、生成shh密钥&quot; class=&quot;headerlink&quot; title=&quot;一、生成shh密钥&quot;&gt;&lt;/a&gt;一、生成shh密钥&lt;/h3&gt;&lt;p&gt;进入 .ssh 目录，windows下一般在默认用户文件夹下 &lt;code&gt;Users/Administrator/.ssh&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; C:\Users\Administrator\.ssh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -V &lt;span class=&quot;comment&quot;&gt;# 查看版本号，确认是否安装ssh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -C &lt;span class=&quot;string&quot;&gt;&quot;email@abc.com&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 生成ssh密钥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Generating public/private rsa key pair.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter file &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_pubrepo &lt;span class=&quot;comment&quot;&gt;# 此处输入密钥的名称，方便后面管理多个密钥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter passphrase (empty &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; no passphrase):&lt;span class=&quot;comment&quot;&gt;# 回车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter same passphrase again:&lt;span class=&quot;comment&quot;&gt;# 回车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your identification has been saved &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; id_rsa_pubrepo.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your public key has been saved &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; id_rsa_pubrepo.pub.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key fingerprint is:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SHA256:xxxxxxxxxxxxx email@abc.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key&lt;span class=&quot;string&quot;&gt;&#39;s randomart image is:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;+---[RSA 3072]----+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|     .   . .     |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|    o =   oo.    |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|     . ..*+. .   |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|    .  .o.B.*    |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|    . *.E=o      |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;|     ..+*B=      |&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;+----[SHA256]-----+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="git" scheme="https://worldnot.com/categories/git/"/>
    
    
      <category term="ssh" scheme="https://worldnot.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Garbage Collection in UE4</title>
    <link href="https://worldnot.com/2021/08/23/ue4%20GC/"/>
    <id>https://worldnot.com/2021/08/23/ue4 GC/</id>
    <published>2021-08-23T15:42:03.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>UE4 C++ 不同于原生的C++, UE内置了GC系统。对于有些人来说，GC帮我们处理了弃用的对象，防止了内存泄漏，确实是一件令人愉快的事情。然后有的时候，如果不了解GC规则，可能会给开发带来大麻烦。</p></blockquote><h3 id="什么对象会被GC-系统处理？"><a href="#什么对象会被GC-系统处理？" class="headerlink" title="什么对象会被GC 系统处理？"></a>什么对象会被GC 系统处理？</h3><p>GC主要思想很简单——要让 GC系统 相信对象是多余的并删除它，必须满足以下几个条件：</p><ul><li><p>这个对象不再被UE 的反射系统引用。</p></li><li><p>指向对象的指针没有被保存在容器中。</p></li><li><p>对象在其作用域内没有被强指针指向，比如<a href="or just plainly [strong pointers]">shared pointers, shared references, unique pointers</a> </p></li><li><p>创建对象的代码块经结束执行(离开作用域)</p></li><li><p>对象没有添加到根节点 AddToRoot()  </p></li><li><p>对象必须是继承自Uobject</p></li></ul><p>有一个要特殊注意的例外，我们可以显式地将UObject派生的类对象标记为销毁。</p><a id="more"></a> <h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>场景中的 Actor 和 Actor 组件，被他们的父对象引用（比如 level 本身）。在场景中生成的actor，不需要特殊的GC 考虑</li><li>当一个新的关卡或者地图加载的时候，引擎将销毁world 并且创建一个新的world， 所有旧场景中的对象将被垃圾回收，包括GM GS,以及它们引用或指针指向的所有内容（假设这是指向对象的唯一引用或指针）。</li><li>并不是所有的不可用对象的指针都等于nullptr，因为如果一个对象被标记为销毁或者没有被正确初始化，那么它的指针可能不是nullptr。因此要养成用IsValid（）来判断对象是否可用的习惯。</li><li>任何对象类如果不是继承自UObject 将不会被GC回收，也就是我们创建的对象类最好是UE 已经存在的类，至少也应该继承自 UObject.</li></ul><h3 id="GC对象树"><a href="#GC对象树" class="headerlink" title="GC对象树"></a>GC对象树</h3><p>到目前为止，我们已经讨论了UE引擎的GC规则和原理，那么它在技术上是如何实现的呢？</p><p>UE引擎维护了一张所有对象的树状图，在树的最根部节点是永远不会被回收的。</p><p>每当需要GC时，引擎将从根集合开始，并通过[反射系统]查看它们引用和指向的对象(<a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)或容器类。任何指向或引用的内容都将添加到“不可触及”列表。然后，它将检查新添加的对象指向或引用的对象，并将所有这些对象也添加到树中。通过这种方式沿着树移动，垃圾收集系统最终会构建一个所有不可接触对象的列表，并删除所有其他对象。" target="_blank" rel="noopener">https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)或容器类。任何指向或引用的内容都将添加到“不可触及”列表。然后，它将检查新添加的对象指向或引用的对象，并将所有这些对象也添加到树中。通过这种方式沿着树移动，垃圾收集系统最终会构建一个所有不可接触对象的列表，并删除所有其他对象。</a></p><p><img src="/images/gc.webp" alt="img" style="zoom:75%;"></p><p>如果一个对象可以通过引擎的属性系统指针追溯到根集，它将不会被垃圾收集。一旦这些与根集的联系被切断，对象将被GC掉。</p><h2 id="Slate-UI"><a href="#Slate-UI" class="headerlink" title="Slate UI"></a>Slate UI</h2><p>需要注意的是Slate UI 是不太适用之前的GC 规则，从4.25开始，它不使用强指针来保持用户界面中使用的对象（通常是uasset）。这意味着如果一个对象被Slate UI引用，但是不再被其他对象引用，那么GC将无情地删除它。而且，当它使用的对象被GC时，Slate UI可能会使程序崩溃。</p><p>为了处理这一问题，请确保传递给Slate UI的每个对象都已受到严格保护，不受垃圾收集的影响。如有必要，可以使用显式强指针，但通常这将通过属性系统完成。例如，可以在垃圾收集图的根集中创建一个新对象，并让它保存与Slate UI小部件相对应的其他对象数组。这些对象将指向Slate UI使用的资源对象。每个专用于自己的Slate UI小部件的对象都可能在小部件启动后被销毁。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>有时我们的代码中有一个问题可能是由垃圾收集引起的，但我们还不能确定。这很可能是一个对象初始化问题，也可能是一系列其他问题。</p><p>我们可以使用断言在代码执行的任何阶段测试对象是否有效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">checkf(IsValid(Object), TEXT(<span class="string">" object is invalid !"</span>));</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"> check(IsValid(Object));</span><br></pre></td></tr></table></figure><p>###　正确示例</p><p>第一个很好的习惯用法是在容器类（如TArray）中使用或者用UPROPERTY（）声明指针。</p><p>一旦不再有“父”对象以这种方式指向“子”对象，“子”对象才能销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中的声明</span></span><br><span class="line"></span><br><span class="line">UPROPERTY()</span><br><span class="line"></span><br><span class="line">UMyCustomClass * MyPointer;</span><br><span class="line"></span><br><span class="line">UPROPERTY()</span><br><span class="line"></span><br><span class="line">UTexture2D * MyTexture;</span><br><span class="line"></span><br><span class="line">UPROPERTY()</span><br><span class="line"></span><br><span class="line">TArray&lt;UStaticMesh*&gt; MyArrayOfMeshes;</span><br></pre></td></tr></table></figure><p>我们可以自由地从多个其他对象指向同一对象。只要至少有一个活动对象使用属性系统指向它，它就不会被垃圾收集。</p><p>“临时对象”会在作用域结束执行后进行垃圾收集。</p><p>下面是一段功能代码，它临时创建一个新对象，以从场景捕获组件捕获图片并将其存储到像素颜色数组中。</p><p>此范围结束后，TextureEnderTarget　本身将被GC适当地清除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 部分定义在 ASceneCapture2D-derived class　中的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint16 Resolution = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line">UTextureRenderTarget2D * TextureRenderTarget = NewObject&lt;UTextureRenderTarget2D &gt;();</span><br><span class="line"></span><br><span class="line">USceneCaptureComponent2D* SCC2D = GetCaptureComponent2D();</span><br><span class="line"></span><br><span class="line">TextureRenderTarget-&gt;InitCustomFormat(Resolution,Resolution,PF_B8G8R8A8,**<span class="literal">false</span>**);</span><br><span class="line"></span><br><span class="line">SCC2D-&gt;TextureTarget = TextureRenderTarget;</span><br><span class="line"></span><br><span class="line">SCC2D-&gt;CaptureScene();</span><br><span class="line"></span><br><span class="line">TArray&lt;FColor&gt; RawPixels;</span><br><span class="line"></span><br><span class="line">RawPixels.Reserve(Resolution * Resolution);</span><br><span class="line"></span><br><span class="line">TextureRenderTarget-&gt;GameThread_GetRenderTargetResource()-&gt;ReadPixels(RawPixels);</span><br><span class="line"></span><br><span class="line">RawPixels.Shrink();</span><br></pre></td></tr></table></figure><h3 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h3><p>两个坏习惯：</p><p>1、是将所有对象都 AddToRoot（）</p><p>2、创建不符合上述GC规则的对象，但是又没有被及时的删除</p><p>有时在函数定义的范围内使用新指针创建对象，并将其指针返回（返回临时对象了）。有时，甚至大多数时候，它可能会起作用。</p><p>还有一个个坏习惯——过度依赖nullptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="keyword">if</span>**(ObjectPointer) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来非常方便，但即使对象未初始化或标记为kill，ObjectPointer的计算结果也将为true。如果要使用对象，最好使用　IsValid（ObjectPointer）来判断。</p><p>###　总结</p><p>总而言之，GC 系统是UE引擎使得代码强健的一部分，有效避免了内存泄漏。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;UE4 C++ 不同于原生的C++, UE内置了GC系统。对于有些人来说，GC帮我们处理了弃用的对象，防止了内存泄漏，确实是一件令人愉快的事情。然后有的时候，如果不了解GC规则，可能会给开发带来大麻烦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么对象会被GC-系统处理？&quot;&gt;&lt;a href=&quot;#什么对象会被GC-系统处理？&quot; class=&quot;headerlink&quot; title=&quot;什么对象会被GC 系统处理？&quot;&gt;&lt;/a&gt;什么对象会被GC 系统处理？&lt;/h3&gt;&lt;p&gt;GC主要思想很简单——要让 GC系统 相信对象是多余的并删除它，必须满足以下几个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这个对象不再被UE 的反射系统引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指向对象的指针没有被保存在容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象在其作用域内没有被强指针指向，比如&lt;a href=&quot;or just plainly [strong pointers]&quot;&gt;shared pointers, shared references, unique pointers&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建对象的代码块经结束执行(离开作用域)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象没有添加到根节点 AddToRoot()  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象必须是继承自Uobject&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一个要特殊注意的例外，我们可以显式地将UObject派生的类对象标记为销毁。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="GC" scheme="https://worldnot.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>UE4 数据压缩方法(三)</title>
    <link href="https://worldnot.com/2020/11/20/UE4-dataCompress03/"/>
    <id>https://worldnot.com/2020/11/20/UE4-dataCompress03/</id>
    <published>2020-11-20T14:44:23.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>之前我们压缩了整数<a href="/2020/11/19/UE4-dataCompress/">（压缩方法一）</a>，Angle角度浮点数<a href="/2020/11/20/UE4-dataCompress02/">（压缩方法二）</a>，那么用来同步位置的FVector是否也可以压缩呢？<br>整数压缩部分是用编码解压实现的，属于无损压缩，Angle角度浮点数是用一个小范围的数据集来表示一个大范围的数据集，属于有损压缩。那么我们可能会问，如果同步的数据不一致，对于不同客户端的计算或者显示结果是否会有影响呢？比如一个游戏中，一个玩家在不同的客户端上的位置和方向存在较大的差异，那肯定是不行的。</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>本次我的思路是对于特定情况下的一些数据压缩提供一种思路。比如我们的一个多人在线应用，用户的活动范围被限制在一定的范围内，也就是玩家的位置坐标的最大值能用更短的整数来存储。那么我们就有压缩的空间了。</p><a id="more"></a> <h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用短整形表示的坐标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FShortLoc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">int16 X;</span><br><span class="line">int16 Y;</span><br><span class="line">int16 Z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩位置信息 -3275 -&gt; +3275</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE FShortLoc <span class="title">LocDataCom</span><span class="params">(FVector Loc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FShortLoc a;</span><br><span class="line">a.X = CompFloatTo16Bit_(Loc.X);</span><br><span class="line">a.Y = CompFloatTo16Bit_(Loc.Y);</span><br><span class="line">a.Z = CompFloatTo16Bit_(Loc.Z);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压缩位置信息 -3275 -&gt; +3275</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE FVector <span class="title">LocDataDec</span><span class="params">(FShortLoc source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FVector a;</span><br><span class="line">a.X = DecomFloatTo16Bit_(source.X);</span><br><span class="line">a.Y = DecomFloatTo16Bit_(source.Y);</span><br><span class="line">a.Z = DecomFloatTo16Bit_(source.Z);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE int16 <span class="title">CompFloatTo16Bit_</span><span class="params">(<span class="keyword">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// -3276.7 -&gt; +3276.7</span></span><br><span class="line">int16 a = value * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE <span class="keyword">float</span> <span class="title">DecomFloatTo16Bit_</span><span class="params">(int16 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// -3276.7 -&gt; +3276.7</span></span><br><span class="line"><span class="keyword">return</span> (value / <span class="number">10.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上代码我们把坐标的范围控制在了 -3275.0 -&gt; +3275.0 ,并且保留了一位小数点。对于位置精度不高，玩家获得范围不超过半径为32.75米的圆形区域（约3,367.8㎡）内的情况下，这种数据压缩节约了1/2的带宽。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;之前我们压缩了整数&lt;a href=&quot;/2020/11/19/UE4-dataCompress/&quot;&gt;（压缩方法一）&lt;/a&gt;，Angle角度浮点数&lt;a href=&quot;/2020/11/20/UE4-dataCompress02/&quot;&gt;（压缩方法二）&lt;/a&gt;，那么用来同步位置的FVector是否也可以压缩呢？&lt;br&gt;整数压缩部分是用编码解压实现的，属于无损压缩，Angle角度浮点数是用一个小范围的数据集来表示一个大范围的数据集，属于有损压缩。那么我们可能会问，如果同步的数据不一致，对于不同客户端的计算或者显示结果是否会有影响呢？比如一个游戏中，一个玩家在不同的客户端上的位置和方向存在较大的差异，那肯定是不行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;本次我的思路是对于特定情况下的一些数据压缩提供一种思路。比如我们的一个多人在线应用，用户的活动范围被限制在一定的范围内，也就是玩家的位置坐标的最大值能用更短的整数来存储。那么我们就有压缩的空间了。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="压缩" scheme="https://worldnot.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="编码" scheme="https://worldnot.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="FVector" scheme="https://worldnot.com/tags/FVector/"/>
    
  </entry>
  
  <entry>
    <title>UE4 数据压缩方法(二)</title>
    <link href="https://worldnot.com/2020/11/20/UE4-dataCompress02/"/>
    <id>https://worldnot.com/2020/11/20/UE4-dataCompress02/</id>
    <published>2020-11-20T00:16:20.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在之前的<a href="/2020/11/19/UE4-dataCompress/">压缩方法一</a>里面我们把表示状态的数据编码到uint32的每个bit上，进行网络传输后再解码出来，以达到压缩数据，节省带宽的效果。这次我们尝试把UE4中的Rotator数据也进行压缩。</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>UE中的Rotator本质上就是一个结构体，其中有三个float，那么传输一个Rotator要占用12个字节。<br>但是可以发现Rotator就是表示三个轴的旋转角度，而角度的范围是0 - 360.0，远小于float可以表示的范围，那么我们的目标就变成了如何用更小的数据量来传递0 - 360.0 了。<br>根据压缩精度不同，本文提供2种压缩方法，均为有损压缩。</p><a id="more"></a> <h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p>其实UE 的 Actor 移动同步中已经有一些对数据进行量化（Quantization）的设置了。</p><p>量化的意思就是把某个数值范围映射（Map）到另一个数值范围。</p><p><img src="/images/image-20210818221744775.webp" alt="image-20210818221744775"></p><p>我把源码翻出来了，需要的话自己封装一下，就可以用啦！</p><p>Runtime\Core\Public\Math\Rotator.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩一个float的角度值为一个byte.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 要压缩的角度.</span></span><br><span class="line"><span class="comment"> * @return 压缩后的角度byte值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8 <span class="title">CompressAxisToByte</span><span class="params">( <span class="keyword">float</span> Angle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个byte的角度值到解压为一个float.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 角度byte值.</span></span><br><span class="line"><span class="comment"> * @return 解压后的角度.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">DecompressAxisFromByte</span><span class="params">( uint8 Angle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩一个float的角度值为一个uint16.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 要压缩的角度.</span></span><br><span class="line"><span class="comment"> * @return 压缩后的角度uint16值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint16 <span class="title">CompressAxisToShort</span><span class="params">( <span class="keyword">float</span> Angle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个uint16的角度值到解压为一个float.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Angle 角度uint16值.</span></span><br><span class="line"><span class="comment"> * @return 解压后的角度.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">DecompressAxisFromShort</span><span class="params">( uint16 Angle )</span></span>;</span><br></pre></td></tr></table></figure><p>Rotator.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE uint8 <span class="title">FRotator::CompressAxisToByte</span><span class="params">( <span class="keyword">float</span> Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 映射 [0-&gt;360) 到 [0-&gt;256) and mask off any winding</span></span><br><span class="line"><span class="keyword">return</span> FMath::RoundToInt(Angle * <span class="number">256.f</span> / <span class="number">360.f</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">float</span> <span class="title">FRotator::DecompressAxisFromByte</span><span class="params">( uint8 Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map [0-&gt;256) to [0-&gt;360)</span></span><br><span class="line"><span class="keyword">return</span> (Angle * <span class="number">360.f</span> / <span class="number">256.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE uint16 <span class="title">FRotator::CompressAxisToShort</span><span class="params">( <span class="keyword">float</span> Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map [0-&gt;360) to [0-&gt;65536) and mask off any winding</span></span><br><span class="line"><span class="keyword">return</span> FMath::RoundToInt(Angle * <span class="number">65536.f</span> / <span class="number">360.f</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">float</span> <span class="title">FRotator::DecompressAxisFromShort</span><span class="params">( uint16 Angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// map [0-&gt;65536) to [0-&gt;360)</span></span><br><span class="line"><span class="keyword">return</span> (Angle * <span class="number">360.f</span> / <span class="number">65536.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>UE 中有很多优秀的源码的，多读源码可以少造轮子。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在之前的&lt;a href=&quot;/2020/11/19/UE4-dataCompress/&quot;&gt;压缩方法一&lt;/a&gt;里面我们把表示状态的数据编码到uint32的每个bit上，进行网络传输后再解码出来，以达到压缩数据，节省带宽的效果。这次我们尝试把UE4中的Rotator数据也进行压缩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;UE中的Rotator本质上就是一个结构体，其中有三个float，那么传输一个Rotator要占用12个字节。&lt;br&gt;但是可以发现Rotator就是表示三个轴的旋转角度，而角度的范围是0 - 360.0，远小于float可以表示的范围，那么我们的目标就变成了如何用更小的数据量来传递0 - 360.0 了。&lt;br&gt;根据压缩精度不同，本文提供2种压缩方法，均为有损压缩。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="压缩" scheme="https://worldnot.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="编码" scheme="https://worldnot.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="Rotator" scheme="https://worldnot.com/tags/Rotator/"/>
    
  </entry>
  
  <entry>
    <title>UE4 数据压缩方法(一)</title>
    <link href="https://worldnot.com/2020/11/19/UE4-dataCompress/"/>
    <id>https://worldnot.com/2020/11/19/UE4-dataCompress/</id>
    <published>2020-11-19T00:42:11.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>对于一个多人实时在线系统，数据同步是关键环节，在相同的网络环境下，数据量决定了同时在线用户量体，数据量也会影响网络延迟和加载时间。所以承载数据的网络带宽是珍贵且昂贵的，所以要在网络数据同步环节细扣每一个 bit !</p></blockquote><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>一个用户有16个设备，每个设备有三种状态: 0 未连接，1 连接异常，2 连接正常。需要用最小的数据量来同步这16个设备的连接状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DeviceState</span><br><span class="line">&#123;</span><br><span class="line">Connected,</span><br><span class="line">Abnormal,</span><br><span class="line">Normal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>每个 bit 有 0 和 1 两种状态，那么至少需要用2个 bit 来表示三种状态，16个设备需要32个 bit。<br>可以把这8个属性编码到一个 uint32 的整数中，前16位分别表示是否连接，后16位分别表示连接是否正常。  </p><a id="more"></a> <h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>这里涉及到整数每个位的操作，我们先在蓝图函数库中写几个位操作的函数，同时暴露给蓝图。  </p><p>MyBPFLibrary.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyBPFLibrary.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 source 第 index 位设置为 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETBIT(souce, index) souce |= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 把 source 第 index 位设置为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEARBIT(souce, index) souce &amp;= ~(1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 把 source 第 index 位取反</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVERSEBIT(souce, index) souce ^= (1 &lt;&lt; index)</span></span><br><span class="line"><span class="comment">// 获取 source 第 index 位的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETBIT(souce, index) ((souce) &gt;&gt; (index) &amp; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYPROJECT_API</span> <span class="title">UMyBPFLibrary</span> :</span> <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置一个 int32 的每一个位的值 0 or 1</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param source 输入值</span></span><br><span class="line"><span class="comment">* @param index 第几位</span></span><br><span class="line"><span class="comment">* @param value 要设置的值 0 or 1</span></span><br><span class="line"><span class="comment">* @return 修改后的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UFUNCTION(BlueprintPure, BlueprintCallable, Category = <span class="string">"Bitwise"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE int32 <span class="title">SetBitValue</span><span class="params">(int32 source, <span class="keyword">const</span> int32 index, <span class="keyword">const</span> uint8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value ? SETBIT(source, index) : CLEARBIT(source, index) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取一个 int32 的某位的值 0 or 1</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param source 输入值</span></span><br><span class="line"><span class="comment">* @param index 第几位</span></span><br><span class="line"><span class="comment">* @return 获取的值 0 or 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UFUNCTION(BlueprintPure, BlueprintCallable, Category = <span class="string">"Bitwise"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> FORCEINLINE uint8 <span class="title">GetBitValue</span><span class="params">(<span class="keyword">const</span> int32 source, <span class="keyword">const</span> int32 index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> GETBIT(source, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20210817233346631.webp" alt="image-20210817233346631"></p><h3 id="纯蓝图实现"><a href="#纯蓝图实现" class="headerlink" title="纯蓝图实现"></a>纯蓝图实现</h3><p>蓝图只支持 int32 的位运算，而且只有四种（ 与，或，非，异或）。所以实现起来稍微麻烦一点，执行效率未知。</p><p>因为涉及到求2的n次方，所以先写一个求n次方的函数：<br><img src="/images/image-20210818213329750.webp" alt="image-20210818213329750"></p><p>默认输入值设置为 2<br><img src="/images/image-20210818213524122.webp" alt="image-20210818213524122"></p><p>再写一个获取某一位的值：<br><img src="/images/image-20210818213651817.webp" alt="image-20210818213651817"></p><p>然后是设置某一位的值：<br><img src="/images/image-20210818213727555.webp" alt="image-20210818213727555"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上我们就通过C++ 和 蓝图分别实现了如何对一个整数的每一个位的0/1值进行编码，用来表示和传输一些属性的状态。接收到数据后再根据编码规则获得每个位的值所表示的状态。<br>设备的状态原来用 uint8 也就是8个 bit来存储，编码后只需要2个bit就可以了，数据量减少了3/4。在同步帧率较高的情况下，效果是显著的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;对于一个多人实时在线系统，数据同步是关键环节，在相同的网络环境下，数据量决定了同时在线用户量体，数据量也会影响网络延迟和加载时间。所以承载数据的网络带宽是珍贵且昂贵的，所以要在网络数据同步环节细扣每一个 bit !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;案例说明&quot;&gt;&lt;a href=&quot;#案例说明&quot; class=&quot;headerlink&quot; title=&quot;案例说明&quot;&gt;&lt;/a&gt;案例说明&lt;/h3&gt;&lt;p&gt;一个用户有16个设备，每个设备有三种状态: 0 未连接，1 连接异常，2 连接正常。需要用最小的数据量来同步这16个设备的连接状态。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; DeviceState&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Connected,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Abnormal,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Normal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;每个 bit 有 0 和 1 两种状态，那么至少需要用2个 bit 来表示三种状态，16个设备需要32个 bit。&lt;br&gt;可以把这8个属性编码到一个 uint32 的整数中，前16位分别表示是否连接，后16位分别表示连接是否正常。  &lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="压缩" scheme="https://worldnot.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="位运算" scheme="https://worldnot.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>UE4 Config配置文件的使用</title>
    <link href="https://worldnot.com/2020/11/17/UE4-Config/"/>
    <id>https://worldnot.com/2020/11/17/UE4-Config/</id>
    <published>2020-11-17T00:54:11.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇文章将简单介绍UE4 项目开发过程中, 如何使用配置文件来修改项目中的参数<br>我们知道在UE4项目的根目录下都会有一个 Config 的文件夹,里面有各种.ini 结尾的文件,这里面都是UE4 默认生成的一些配置文件. 今天我们要做的就是使用自己定义的.ini 文件,定义自己的 Config 变量, 并用这些变量来初始化 Class 中的定义的成员变量.</p><p>版本：UE4.25</p></blockquote><h4 id="1-关于打包后Config文件的位置"><a href="#1-关于打包后Config文件的位置" class="headerlink" title="1.关于打包后Config文件的位置"></a>1.关于打包后Config文件的位置</h4><p>如果采用Development 或者DebugGame 模式打包的话, Config 文件会生成在 <code>打包目录\项目名称\Saved\Config\WindowsNoEditor</code> 目录中, 但是如果用Shipping 模式打包的话, 会发现找不到这个目录了, 那么在Windows 系统下 我们可以在如下地址找到 <code>C:\Users\用户名\AppData\Local\项目名称\Saved\Config\WindowsNoEditor</code>.<br>接下来也会把我们自己的 Config 文件生成在指定的目录下,方便找到和修改.</p><h4 id="2-把成员变量设置为可用Config-配置"><a href="#2-把成员变量设置为可用Config-配置" class="headerlink" title="2. 把成员变量设置为可用Config 配置"></a>2. 把成员变量设置为可用Config 配置</h4><p>在UE4 c++ Class 变量的宏定义中, 加入 <code>config</code> 关键字<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否作为服务器启动</span></span><br><span class="line">UPROPERTY(config ,Category=<span class="string">"CustomIni"</span>)</span><br><span class="line"><span class="keyword">bool</span> bServer=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="3-定义-Config-目录"><a href="#3-定义-Config-目录" class="headerlink" title="3. 定义 Config 目录"></a>3. 定义 Config 目录</h4><p>在类的构造函数中可以定义 自己的 Config 目录, 这里定义为项目目录下的 Settings 文件夹, 配置文件的名称是 Custom.ini<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigPath = FPaths::ProjectDir() / TEXT(<span class="string">"Settings/Custom.ini"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="4-加载和保存-Config-配置"><a href="#4-加载和保存-Config-配置" class="headerlink" title="4. 加载和保存 Config 配置"></a>4. 加载和保存 Config 配置</h4><p>定义两个函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::LoadCustomConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GConfig-&gt;Flush(<span class="literal">true</span>, ConfigPath);</span><br><span class="line">ReloadConfig(<span class="keyword">this</span>-&gt;GetClass(), *ConfigPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::SaveCustomConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SaveConfig(CPF_Config, *ConfigPath);</span><br><span class="line">GConfig-&gt;Flush(<span class="literal">false</span>, ConfigPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在 void UMyGameInstance::Init() 中调用SaveCustomConfig();  (Actor 类可以在 BeginPlay  中 ) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::Init();</span><br><span class="line"></span><br><span class="line">bServer = <span class="literal">true</span>; <span class="comment">// bServer 默认为false, 而SaveCustomConfig() 函数只会把和默认值不一致的变量存入 Custom.ini中,所以此处先修改一下</span></span><br><span class="line">SaveCustomConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用 SaveCustomConfig()  的目的是为了在 <code>项目目录/Settings</code> 下生成 一个 Custom.ini.<br>Custom.ini 里面的 内容如下 <code>我为了测试方便是在蓝图中调用的</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/Game/Blueprints/GameControl/BP_PTGameInstance.BP_PTGameInstance_C]</span><br><span class="line">bServer=true</span><br></pre></td></tr></table></figure></p><p>然后把保存的函数注释掉, 只保留加载函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyGameInstance::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bServer = true;</span></span><br><span class="line"><span class="comment">// SaveCustomConfig();</span></span><br><span class="line"></span><br><span class="line">LoadCustomConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用 LoadCustomConfig() 的目的是为了把 UMyGameInstance 中 bServer 这个变量的值设置为 Custom.ini 中的值. 名称是一一对应的.</p><p>这个就实现了, 无论是Development, Debug模式,还是Shipping 模式打包的项目, 都可以在 <code>项目目录/Settings</code>  下面设置 Custom.ini 中的变量, 设置的变量的值就会被设置为对应的变量的值.<br>对于同一个项目,需要不同自定义配置来启动的话,这将是一个很方面的方式.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇文章将简单介绍UE4 项目开发过程中, 如何使用配置文件来修改项目中的参数&lt;br&gt;我们知道在UE4项目的根目录下都会有一个 Config 的文件夹,里面有各种.ini 结尾的文件,这里面都是UE4 默认生成的一些配置文件. 今天我们要做的就是使用自己定义的.ini 文件,定义自己的 Config 变量, 并用这些变量来初始化 Class 中的定义的成员变量.&lt;/p&gt;
&lt;p&gt;版本：UE4.25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-关于打包后Config文件的位置&quot;&gt;&lt;a href=&quot;#1-关于打包后Config文件的位置&quot; class=&quot;headerlink&quot; title=&quot;1.关于打包后Config文件的位置&quot;&gt;&lt;/a&gt;1.关于打包后Config文件的位置&lt;/h4&gt;&lt;p&gt;如果采用Development 或者DebugGame 模式打包的话, Config 文件会生成在 &lt;code&gt;打包目录\项目名称\Saved\Config\WindowsNoEditor&lt;/code&gt; 目录中, 但是如果用Shipping 模式打包的话, 会发现找不到这个目录了, 那么在Windows 系统下 我们可以在如下地址找到 &lt;code&gt;C:\Users\用户名\AppData\Local\项目名称\Saved\Config\WindowsNoEditor&lt;/code&gt;.&lt;br&gt;接下来也会把我们自己的 Config 文件生成在指定的目录下,方便找到和修改.&lt;/p&gt;
&lt;h4 id=&quot;2-把成员变量设置为可用Config-配置&quot;&gt;&lt;a href=&quot;#2-把成员变量设置为可用Config-配置&quot; class=&quot;headerlink&quot; title=&quot;2. 把成员变量设置为可用Config 配置&quot;&gt;&lt;/a&gt;2. 把成员变量设置为可用Config 配置&lt;/h4&gt;&lt;p&gt;在UE4 c++ Class 变量的宏定义中, 加入 &lt;code&gt;config&lt;/code&gt; 关键字&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 是否作为服务器启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UPROPERTY(config ,Category=&lt;span class=&quot;string&quot;&gt;&quot;CustomIni&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; bServer=&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
    
      <category term="Config" scheme="https://worldnot.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>UE4 重复点击检测</title>
    <link href="https://worldnot.com/2020/10/04/UE4-ClickCheck/"/>
    <id>https://worldnot.com/2020/10/04/UE4-ClickCheck/</id>
    <published>2020-10-03T23:12:23.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在开发过程中，我们经常会有这样的需求：限制用户的点击频率。一方面考虑到服务器数据请求的压力，一方面防止恶意攻击服务器。<br>我在网上也能看到其他的实现方法，有用Delay 节点的，有传递点击按钮对象的。总觉得使用起来不是很方便，因此打算自己实现一个，简单易用，没有任何使用代价的方式。自认为是最优雅的方式了。</p><p>版本：UE4.25</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>本次针对的是UE4 蓝图UMG 系统，所以是在蓝图的基础上实现的，利用了系统的运行时间。<br>首先第一点击之后调用一个宏记录当前的系统运行时间，然后第二次点击再次调用该宏，比对当前时间和上次记录的时间的差值是否小于我们设定的点击间隔。以此来决定后面的代码要不要继续执行。</p><a id="more"></a> <h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p><img src="/images/image-20210818234356402.webp" alt="image-20210818234356402"></p><p><img src="/images/image-20210818234624047.webp" alt="image-20210818234624047"></p><p>蓝图代码地址<code>https://blueprintue.com/render/y96sbq1v/</code></p><iframe src="https://blueprintue.com/render/y96sbq1v/" scrolling="no" allowfullscreen width="100%" height="300px"></iframe><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>没有什么高深的 Code 技术，但是逻辑思维很重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在开发过程中，我们经常会有这样的需求：限制用户的点击频率。一方面考虑到服务器数据请求的压力，一方面防止恶意攻击服务器。&lt;br&gt;我在网上也能看到其他的实现方法，有用Delay 节点的，有传递点击按钮对象的。总觉得使用起来不是很方便，因此打算自己实现一个，简单易用，没有任何使用代价的方式。自认为是最优雅的方式了。&lt;/p&gt;
&lt;p&gt;版本：UE4.25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;本次针对的是UE4 蓝图UMG 系统，所以是在蓝图的基础上实现的，利用了系统的运行时间。&lt;br&gt;首先第一点击之后调用一个宏记录当前的系统运行时间，然后第二次点击再次调用该宏，比对当前时间和上次记录的时间的差值是否小于我们设定的点击间隔。以此来决定后面的代码要不要继续执行。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
      <category term="UMG" scheme="https://worldnot.com/categories/UE4/UMG/"/>
    
    
      <category term="蓝图" scheme="https://worldnot.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
      <category term="宏" scheme="https://worldnot.com/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>UE4 多线程FRunnable（一）</title>
    <link href="https://worldnot.com/2019/11/04/UE4-Ansyc01/"/>
    <id>https://worldnot.com/2019/11/04/UE4-Ansyc01/</id>
    <published>2019-11-04T12:35:33.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>在开发过程中，有时候会遇到需要使用线程相关逻辑，比如网络相关，动态加载资源的，希望不要影响主线程的运行。<br>版本：UE4.25</p></blockquote><p>UE4遵循C++11的标准，但是他并没有使用std::thread，而是自己实现了一套多线程机制。</p><p>在UE4里面创建多线程的三种方式，我们会分三篇来分析和使用：</p><ol><li>继承FRunnable接口创建一个线程任务，适用于复杂运算</li><li>直接创建AsyncTask来调用线程池里面空闲的线程</li><li>通过TaskGraph系统来异步完成一些自定义任务</li></ol><p>这三种方式本质相同，但是用法不同。</p><p>本篇尝试使用FRunnable。</p><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>给定一个txt文件路径数组，通过异步的方式读取文件，并且返回文件的内容数组。</p><h3 id="FRunnable分析"><a href="#FRunnable分析" class="headerlink" title="FRunnable分析"></a>FRunnable分析</h3><p>FRunnable 是线程的执行体，提供相应的接口。FRunnable需要依附与一个FRunnableThread对象，才能被执行，  </p><p>真正的线程其实是FRunnableThread，不同平台的线程都继承自他，如FRunnableThreadWin，里面会调用Windows平台的创建线程的API接口。</p><a id="more"></a> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Windows平台的实现类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRunnableThreadWin</span> :</span> <span class="keyword">public</span> FRunnableThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window平台的线程句柄</span></span><br><span class="line">    HANDLE Thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime\Core\Public\HAL\Runnable.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_API</span> <span class="title">FRunnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，在聚合此方法的线程对象的上下文（FRunnableThread）中调用，而不是在将此runnable传递给新线程的线程中调用</span></span><br><span class="line">    <span class="comment">// 在FRunnableThread创建线程对象后调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化成功后才会调用，这是执行线程任务的地方</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> uint32 <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程请求提前结束</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出，执行清理的时候在聚合线程的上下文（FRunnableThread）中调用。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在禁用多线程情况下运行这个可执行对象的时候，该函数可以获取单线程接口指针</span></span><br><span class="line"><span class="comment">// 如果这个接口没有实现</span></span><br><span class="line"><span class="comment">// 而且当FPlatformProcess::SupportsMultithreading() is false 时这个可执行对象不会被执行</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> class FSingleThreadRunnable* <span class="title">GetSingleThreadInterface</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚析构函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~FRunnable() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>创建TxtReadTask.h 重新生成项目代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TxtReadTask.h</span></span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;在开发过程中，有时候会遇到需要使用线程相关逻辑，比如网络相关，动态加载资源的，希望不要影响主线程的运行。&lt;br&gt;版本：UE4.25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UE4遵循C++11的标准，但是他并没有使用std::thread，而是自己实现了一套多线程机制。&lt;/p&gt;
&lt;p&gt;在UE4里面创建多线程的三种方式，我们会分三篇来分析和使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承FRunnable接口创建一个线程任务，适用于复杂运算&lt;/li&gt;
&lt;li&gt;直接创建AsyncTask来调用线程池里面空闲的线程&lt;/li&gt;
&lt;li&gt;通过TaskGraph系统来异步完成一些自定义任务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种方式本质相同，但是用法不同。&lt;/p&gt;
&lt;p&gt;本篇尝试使用FRunnable。&lt;/p&gt;
&lt;h3 id=&quot;案例说明&quot;&gt;&lt;a href=&quot;#案例说明&quot; class=&quot;headerlink&quot; title=&quot;案例说明&quot;&gt;&lt;/a&gt;案例说明&lt;/h3&gt;&lt;p&gt;给定一个txt文件路径数组，通过异步的方式读取文件，并且返回文件的内容数组。&lt;/p&gt;
&lt;h3 id=&quot;FRunnable分析&quot;&gt;&lt;a href=&quot;#FRunnable分析&quot; class=&quot;headerlink&quot; title=&quot;FRunnable分析&quot;&gt;&lt;/a&gt;FRunnable分析&lt;/h3&gt;&lt;p&gt;FRunnable 是线程的执行体，提供相应的接口。FRunnable需要依附与一个FRunnableThread对象，才能被执行，  &lt;/p&gt;
&lt;p&gt;真正的线程其实是FRunnableThread，不同平台的线程都继承自他，如FRunnableThreadWin，里面会调用Windows平台的创建线程的API接口。&lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
      <category term="多线程" scheme="https://worldnot.com/categories/UE4/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Ansyc" scheme="https://worldnot.com/tags/Ansyc/"/>
    
      <category term="异步" scheme="https://worldnot.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="多线程" scheme="https://worldnot.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>UE4 打包相关（一）</title>
    <link href="https://worldnot.com/2019/08/04/UE4-Pack01/"/>
    <id>https://worldnot.com/2019/08/04/UE4-Pack01/</id>
    <published>2019-08-04T12:17:41.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>想知道从C++代码/蓝图脚本/资产到打包成可执行程序，UE都帮我们干了些什么吗？<br>版本：UE4.21</p></blockquote><h3 id="基本名词解释"><a href="#基本名词解释" class="headerlink" title="基本名词解释"></a>基本名词解释</h3><blockquote><p>ps:受限于当前的知识水平，难免产生理解错误，后期会继续完善修正。</p></blockquote><h4 id="UHT-UnrealHeaderTool"><a href="#UHT-UnrealHeaderTool" class="headerlink" title="UHT (UnrealHeaderTool )"></a>UHT (UnrealHeaderTool )</h4><p>我粗浅的理解就是UE自己的代码预处理器（相对于C++ 的预处理过程），UHT对代码文件内容进行处理，生成 .generated.h/.gen.cpp 文件，加入反射信息，适配UObject，在以便在在运行时能获取和使用这些数据。<br>生成的文件在 \Intermediate\Build\Win64\UE4Editor\Inc\YourProject 目录下。</p><blockquote><p>UObject提供了 元数据、反射数据、GC垃圾回收、序列化</p></blockquote><h4 id="UBT-UnrealBuildTool"><a href="#UBT-UnrealBuildTool" class="headerlink" title="UBT (UnrealBuildTool)"></a>UBT (UnrealBuildTool)</h4><p>UnrealBuildTool (UBT)管理在各种不同的构建配置下构建UE4源代码的过程；<br>UBT 程序源代码在Engine\Source\Programs\UnrealBuildTool 目录下；<br>UBT 的配置项在 UnrealBuildTool\Configuration\BuildConfiguration.cs 文件中。  </p><a id="more"></a> <h4 id="UAT-AutomotionTool"><a href="#UAT-AutomotionTool" class="headerlink" title="UAT (AutomotionTool)"></a>UAT (AutomotionTool)</h4><p>UnrealBuildTool (UBT)管理在各种不同的构建配置下构建UE4源代码的过程；<br>UBT 程序源代码在Engine\Source\Programs\UnrealBuildTool 目录下；<br>UBT 的配置项在 UnrealBuildTool\Configuration\BuildConfiguration.cs 文件中。  </p><h4 id="Build-构建"><a href="#Build-构建" class="headerlink" title="Build 构建"></a>Build 构建</h4><p>这里说的不是 UE 编辑器上Build按钮，那主要是负责提前计算场景中光照数据、物体可见性、导航网格等。<br>我们说的是源代码source code 的构建。<br>首先我们执行编辑器的 File-&gt;Refresh Visual Studio Project，在输出日志中我们会看到如下信息：<br>（此操作等同在 xxx.uproject 上右击 Generate visual studio project files, ps:必须是C++ 项目）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Running .../UnrealEngine/Engine/Binaries/DotNET/UnrealBuildTool.exe  -projectfiles -project=".../MyProject.uproject" -game -engine -progress</span><br><span class="line">Discovering modules, targets and source code for project...</span><br><span class="line">Binding IntelliSense data...</span><br><span class="line">Binding IntelliSense data... 100%</span><br><span class="line">Writing project files...</span><br><span class="line">Writing project files... 100%</span><br></pre></td></tr></table></figure><p>我们看到UBT(UnrealBuildTool)这个程序开始执行了。   </p><h3 id="Complie-编译"><a href="#Complie-编译" class="headerlink" title="Complie 编译"></a>Complie 编译</h3><p>在VS等IDE 中执行编译， UE 引擎也提供了热编译功能（在不关闭引擎的情况下，对修改的c++代码进行重新编译） 。<br>这个过程就是编译C++ 代码，生成Binaries二进制文件。</p><h3 id="Cook-烘焙"><a href="#Cook-烘焙" class="headerlink" title="Cook 烘焙"></a>Cook 烘焙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UATHelper: Cooking (Windows (64-bit)): Running AutomationTool...</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Parsing command line: -ScriptsForProject=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; BuildCookRun -nocompileeditor -nop4 -project=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; -cook -skipstage -ue4exe=C:\Users\Administrator\Documents\UnrealEngine\Engi</span><br><span class="line">ne\Binaries\Win64\UE4Editor-Cmd.exe -targetplatform=Win64 -utf8output -compile</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Dependencies are up to date (0.071s). Skipping compile.</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Setting up ProjectParams for C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): ********** COOK COMMAND STARTED **********</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Running UE4Editor Cook for project C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Commandlet log file is C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Cook-2021.08.21-15.00.49.txt</span><br><span class="line">UATHelper: Cooking (Windows (64-bit)): Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\Win64\UE4Editor-Cmd.exe &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -run=Cook  -TargetPlatform=WindowsNoEditor -fileopenlog -unversioned -abslog=C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\Automat</span><br><span class="line">ionTool\Saved\Cook-2021.08.21-15.00.49.txt -stdout -CrashForUAT -unattended -NoLogTimes  -UTF8Output</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LogUObjectHash: Compacting FUObjectHashTables data took   0.52ms</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Running AutomationTool...</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Parsing command line: -ScriptsForProject=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; BuildCookRun -nocompileeditor -nop4 -project=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; -cook -stage -archive -archivedirectory=&quot;C:/Users/Administrator/Documents</span><br><span class="line">/Unreal Projects/MyProject&quot; -package -ue4exe=C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\Win64\UE4Editor-Cmd.exe -pak -prereqs -nodebuginfo -targetplatform=Win64 -build -target=MyProject -clientconfig=Development -utf8output -compile</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Dependencies are up to date (0.073s). Skipping compile.</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Setting up ProjectParams for C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): ********** BUILD COMMAND STARTED **********</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe UnrealPak Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -Manif</span><br><span class="line">est=C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-UnrealPak-Win64-Development.txt&quot;</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Building UnrealPak...</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Using Visual Studio 2019 14.28.29913 toolchain (C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29910) and Windows 10.0.18362.0 SDK (C:\Program Files (x86)\Windows Kits\10).</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Building 1 action with 12 processes...</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):     [1/1] UnrealPak.target</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Total time in Parallel executor: 0.15 seconds</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Total execution time: 2.46 seconds</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Took 2.5490017s to run UnrealBuildTool.exe, ExitCode=0</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)): Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe MyProject Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -remot</span><br><span class="line">eini=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject&quot; -skipdeploy -Manifest=C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-MyProject-Win64-Development.txt&quot;</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Parsing headers for MyProject</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):     Running UnrealHeaderTool &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\Intermediate\Build\Win64\MyProject\Development\MyProject.uhtmanifest&quot; -LogCmds=&quot;loginit warning, logexit warning, logdatabase error&quot; -Unattended -Warn</span><br><span class="line">ingsAsErrors -abslog=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UHT-MyProject-Win64-Development.txt&quot;</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Reflection code generated for MyProject in 7.6218441 seconds</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">UATHelper: Packaging (Windows (64-bit)):   Building MyProject...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LogPlayLevel: Completed Launch On Stage: Cooking in the editor, Time: 5.859237</span><br><span class="line">LogPlayLevel: Running AutomationTool...</span><br><span class="line">LogPlayLevel: Parsing command line: -ScriptsForProject=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; BuildCookRun -project=&quot;C:/Users/Administrator/Documents/Unreal Projects/MyProject/MyProject.uproject&quot; -noP4 -clientconfig=Development -serverconfig=Development -nocompileeditor -ue4exe=C:\Users\Administrator\Documents\UnrealE</span><br><span class="line">ngine\Engine\Binaries\Win64\UE4Editor-Cmd.exe -utf8output -platform=Win64 -targetplatform=Win64 -ini:Game:[/Script/UnrealEd.ProjectPackagingSettings]:BlueprintNativizationMethod=Disabled -build -map=/Game/ThirdPersonCPP/Maps/ThirdPersonExampleMap -skipcook -CookInEditor -iterativecooking -compressed -iterativedeploy -stage -deploy -cmdline=&quot;/Game/ThirdPerson</span><br><span class="line">CPP/Maps/ThirdPersonExampleMap -Messaging&quot; -device=WindowsNoEditor@FNEO48MGKFVU1R6 -addcmdline=&quot;-SessionId=F0F275C749ED33221ED7CE83A5061BC4 -SessionOwner=&apos;Administrator&apos; -SessionName=&apos;Launch On Device&apos;  &quot; -run -compile</span><br><span class="line">LogPlayLevel: Dependencies are up to date (0.078s). Skipping compile.</span><br><span class="line">LogPlayLevel: Setting up ProjectParams for C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject</span><br><span class="line">LogPlayLevel: ********** BUILD COMMAND STARTED **********</span><br><span class="line">LogPlayLevel: Completed Launch On Stage: Build Task, Time: 2.761045</span><br><span class="line">LogPlayLevel: Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe UnrealPak Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -Manifest=C:\Users\Administrator\</span><br><span class="line">Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-UnrealPak-Win64-Development.txt&quot;</span><br><span class="line">LogPlayLevel:   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">LogPlayLevel:   Target is up to date</span><br><span class="line">LogPlayLevel:   Total execution time: 1.16 seconds</span><br><span class="line">LogPlayLevel: Took 1.2479697s to run UnrealBuildTool.exe, ExitCode=0</span><br><span class="line">LogPlayLevel: Running: C:\Users\Administrator\Documents\UnrealEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe MyProject Win64 Development -Project=&quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot;  &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; -NoUBTMakefiles  -remoteini=&quot;C:\Users\Administrato</span><br><span class="line">r\Documents\Unreal Projects\MyProject&quot; -skipdeploy -ini:Game:[/Script/UnrealEd.ProjectPackagingSettings]:BlueprintNativizationMethod=Disabled -Manifest=C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml -NoHotReload -log=&quot;C:\Users\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UBT-MyProject-Wi</span><br><span class="line">n64-Development.txt&quot;</span><br><span class="line">LogPlayLevel:   Parsing headers for MyProject</span><br><span class="line">LogPlayLevel:     Running UnrealHeaderTool &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\MyProject.uproject&quot; &quot;C:\Users\Administrator\Documents\Unreal Projects\MyProject\Intermediate\Build\Win64\MyProject\Development\MyProject.uhtmanifest&quot; -LogCmds=&quot;loginit warning, logexit warning, logdatabase error&quot; -Unattended -WarningsAsErrors -abslog=&quot;C:\Us</span><br><span class="line">ers\Administrator\Documents\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UHT-MyProject-Win64-Development.txt&quot;</span><br><span class="line">LogPlayLevel:   Reflection code generated for MyProject in 5.4499816 seconds</span><br><span class="line">LogPlayLevel:   Writing manifest to C:\Users\Administrator\Documents\UnrealEngine\Engine\Intermediate\Build\Manifest.xml</span><br><span class="line">LogPlayLevel:   Building MyProject...</span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;想知道从C++代码/蓝图脚本/资产到打包成可执行程序，UE都帮我们干了些什么吗？&lt;br&gt;版本：UE4.21&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本名词解释&quot;&gt;&lt;a href=&quot;#基本名词解释&quot; class=&quot;headerlink&quot; title=&quot;基本名词解释&quot;&gt;&lt;/a&gt;基本名词解释&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ps:受限于当前的知识水平，难免产生理解错误，后期会继续完善修正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;UHT-UnrealHeaderTool&quot;&gt;&lt;a href=&quot;#UHT-UnrealHeaderTool&quot; class=&quot;headerlink&quot; title=&quot;UHT (UnrealHeaderTool )&quot;&gt;&lt;/a&gt;UHT (UnrealHeaderTool )&lt;/h4&gt;&lt;p&gt;我粗浅的理解就是UE自己的代码预处理器（相对于C++ 的预处理过程），UHT对代码文件内容进行处理，生成 .generated.h/.gen.cpp 文件，加入反射信息，适配UObject，在以便在在运行时能获取和使用这些数据。&lt;br&gt;生成的文件在 \Intermediate\Build\Win64\UE4Editor\Inc\YourProject 目录下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UObject提供了 元数据、反射数据、GC垃圾回收、序列化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;UBT-UnrealBuildTool&quot;&gt;&lt;a href=&quot;#UBT-UnrealBuildTool&quot; class=&quot;headerlink&quot; title=&quot;UBT (UnrealBuildTool)&quot;&gt;&lt;/a&gt;UBT (UnrealBuildTool)&lt;/h4&gt;&lt;p&gt;UnrealBuildTool (UBT)管理在各种不同的构建配置下构建UE4源代码的过程；&lt;br&gt;UBT 程序源代码在Engine\Source\Programs\UnrealBuildTool 目录下；&lt;br&gt;UBT 的配置项在 UnrealBuildTool\Configuration\BuildConfiguration.cs 文件中。  &lt;/p&gt;
    
    </summary>
    
      <category term="UE4" scheme="https://worldnot.com/categories/UE4/"/>
    
      <category term="PACK" scheme="https://worldnot.com/categories/UE4/PACK/"/>
    
    
      <category term="UBT" scheme="https://worldnot.com/tags/UBT/"/>
    
      <category term="UHT" scheme="https://worldnot.com/tags/UHT/"/>
    
      <category term="build" scheme="https://worldnot.com/tags/build/"/>
    
      <category term="cook" scheme="https://worldnot.com/tags/cook/"/>
    
      <category term="pack" scheme="https://worldnot.com/tags/pack/"/>
    
      <category term="run" scheme="https://worldnot.com/tags/run/"/>
    
  </entry>
  
  <entry>
    <title>关于char * ,char a[ ] , string</title>
    <link href="https://worldnot.com/2019/01/24/UE4-CPP-about-char/"/>
    <id>https://worldnot.com/2019/01/24/UE4-CPP-about-char/</id>
    <published>2019-01-24T11:22:17.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>借此理解数组名和数组首地址</p></blockquote><ol><li><p>c 语言中没有 string 类型， 用 char 类型的数组来表示string，也就是 一串内存地址连续的 char</p></li><li><p>\0 是字符串的结束符</p></li><li><p><font color="red">“asfkhj”</font> 双引号中的内容表示一个常量字符串 const string，本质是一个地址，是第一个字符的地址</p></li><li><p>char* 表示一个指针变量，当然可以用一个地址来赋值</p></li><li><p>char a[ ] 表示一个字符串数组，a 是数组名，是const 常量，只能初始化，不能直接赋值，a也表示数组的首地址，也就是第一个元素的地址a[0]</p><a id="more"></a> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">16</span>] = &#123; <span class="string">"it's a string"</span> &#125;;</span><br><span class="line">p = <span class="string">"it's a string"</span>;</span><br><span class="line">p = buff;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, &amp;buff[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">打印结果一致,所有相同的字符串常量都是同一个地址</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;借此理解数组名和数组首地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;c 语言中没有 string 类型， 用 char 类型的数组来表示string，也就是 一串内存地址连续的 char&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\0 是字符串的结束符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;“asfkhj”&lt;/font&gt; 双引号中的内容表示一个常量字符串 const string，本质是一个地址，是第一个字符的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;char* 表示一个指针变量，当然可以用一个地址来赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;char a[ ] 表示一个字符串数组，a 是数组名，是const 常量，只能初始化，不能直接赋值，a也表示数组的首地址，也就是第一个元素的地址a[0]&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://worldnot.com/categories/C-C/"/>
    
    
      <category term="char" scheme="https://worldnot.com/tags/char/"/>
    
  </entry>
  
  <entry>
    <title>C++ 临时对象</title>
    <link href="https://worldnot.com/2019/01/23/UE4-CPP-temporary-objects/"/>
    <id>https://worldnot.com/2019/01/23/UE4-CPP-temporary-objects/</id>
    <published>2019-01-23T13:28:15.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>函数<strong>不要返回</strong>引用类型的临时对象，也<strong>不要引用</strong>函数返回的临时对象，因为无法预测会发生什么。</p></blockquote><h3 id="一、引用和指针的区别"><a href="#一、引用和指针的区别" class="headerlink" title="一、引用和指针的区别"></a>一、引用和指针的区别</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用声明时，需要初始化</p><p>引用是被引用对象的别名，和被引用对象绑定后不可变更</p><p>引用一定不为空，不需要判定是否空对象</p><p>使用引用传递，可以避免临时对象</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针可以多次赋值，改变指向的对象</p><p>指针可以指向空</p><h3 id="二、什么是临时对象"><a href="#二、什么是临时对象" class="headerlink" title="二、什么是临时对象"></a>二、什么是临时对象</h3><p>临时对象是在源码中不可见的，是栈上的、没有名字的对象</p><a id="more"></a> <h3 id="三、临时对象产生的原因"><a href="#三、临时对象产生的原因" class="headerlink" title="三、临时对象产生的原因"></a>三、临时对象产生的原因</h3><p>类型不匹配：一般情况是指当需要X类型的对象时提供的却是其它类型的对象。编译器需要以某种方式将提供的类型转换成要求的X类型。这一过程可能会产生临时对象。（为使函数调用成功而进行隐式类型转换）</p><p>按值传递：创建和销毁临时对象的代价是比较高的。倘若可以，我们应该按指针或者引用来传递对象以避免生成临时对象。</p><p>按值返回：如果编写的函数是按值返回对象(与引用或者指针相对)，就很可能生成临时对象。（函数返回值）</p><p>临时对象案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conv</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;  ...  &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    conv(<span class="string">"abcd"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑以上代码</p><p>abcd并不是直接传给str，而是先传递给临时对象，再由临时对象传递给形参str，因为他们俩的类型不一样</p><p>“abcd”（字符常量是 const 类型）—传递—&gt;  临时对象（默认const）—传递—&gt;  变量 str （非 const）</p><p>如果每次调用都产生临时对象，则会增加消耗</p><p>可以考虑用引用传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void conv(string&amp; str)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">conv(&quot;abcd&quot;); </span><br><span class="line">// 会报错，cannot bind non-const lvalue reference of type &apos;std::string&amp;&apos;to an rvalue of type &apos;std::string&apos; </span><br><span class="line">// 不能绑定一个 非const类型的左值引用（str） 到一个右值上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者 加const，但是不可在函数中修改了</span><br><span class="line"></span><br><span class="line">void conv(const string&amp; str)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">conv(&quot;abcd&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">重要知识点，使用非const类型的引用时，参数只能是相同类型，而const类型可以实现传递与此类型相关的参数进来。</span><br><span class="line">（不能把const 类型转换为非const，但是可以把 非const 当做const类型用）</span><br><span class="line">将 &quot;std::string &amp;&quot; 类型的引用绑定到 &quot;const std::string&quot; 类型的初始值设定项时，限定符被丢弃</span><br><span class="line"></span><br><span class="line">void conv(string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    str = &quot;adsfsa&quot;;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    string str1 = &quot;abcd&quot;;</span><br><span class="line">    conv(str1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回值产生的临时对象</p><p>返回值 —传递—&gt;  临时对象 —传递—&gt;  主函数</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>可以使用operator=()消除临时对象。</p><p>临时对象会以构造函数和析构函数的形式降低一半的性能。</p><p>将构造函数声明为explicit，可以阻止编译器在幕后使用类型转换。</p><p>编译器常常创建临时对象来解决类型不匹配问题。通过函数重载可以避免这种情况。</p><p>如果可能，应尽量避免使用对象拷贝。按引用传递和返回对象。</p><p>在 <op> 可能是”+、-、*”或者”/”的地方，使用 <op>= 运算符可以消除临时对象。</op></op></p><p><strong>不要试图使用”引用”来减少构造和析构函数的调用</strong>。如果你非要优化的话，建议使用返回值优化（RVO）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cat foo2()</span><br><span class="line">&#123;</span><br><span class="line">return Cat(&quot;b&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，main函数中的变量c就不会调用拷贝构造了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;函数&lt;strong&gt;不要返回&lt;/strong&gt;引用类型的临时对象，也&lt;strong&gt;不要引用&lt;/strong&gt;函数返回的临时对象，因为无法预测会发生什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、引用和指针的区别&quot;&gt;&lt;a href=&quot;#一、引用和指针的区别&quot; class=&quot;headerlink&quot; title=&quot;一、引用和指针的区别&quot;&gt;&lt;/a&gt;一、引用和指针的区别&lt;/h3&gt;&lt;h4 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h4&gt;&lt;p&gt;引用声明时，需要初始化&lt;/p&gt;
&lt;p&gt;引用是被引用对象的别名，和被引用对象绑定后不可变更&lt;/p&gt;
&lt;p&gt;引用一定不为空，不需要判定是否空对象&lt;/p&gt;
&lt;p&gt;使用引用传递，可以避免临时对象&lt;/p&gt;
&lt;h4 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h4&gt;&lt;p&gt;指针可以多次赋值，改变指向的对象&lt;/p&gt;
&lt;p&gt;指针可以指向空&lt;/p&gt;
&lt;h3 id=&quot;二、什么是临时对象&quot;&gt;&lt;a href=&quot;#二、什么是临时对象&quot; class=&quot;headerlink&quot; title=&quot;二、什么是临时对象&quot;&gt;&lt;/a&gt;二、什么是临时对象&lt;/h3&gt;&lt;p&gt;临时对象是在源码中不可见的，是栈上的、没有名字的对象&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://worldnot.com/categories/C-C/"/>
    
    
      <category term="temporary objects" scheme="https://worldnot.com/tags/temporary-objects/"/>
    
      <category term="临时对象" scheme="https://worldnot.com/tags/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11 特性</title>
    <link href="https://worldnot.com/2019/01/22/UE4-CPP11Feature/"/>
    <id>https://worldnot.com/2019/01/22/UE4-CPP11Feature/</id>
    <published>2019-01-22T12:32:27.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>本篇转载自 <a href="https://blog.csdn.net/jiange_zh/article/details/79356417" target="_blank" rel="noopener">C++11常用新特性快速一览</a> 一是方便将来检索，而是后续会按自己的思路重新整理</p></blockquote><p>最近工作中，遇到一些问题，使用C++11实现起来会更加方便，而线上的生产环境还不支持C++11，于是决定新年开工后，在组内把C++11推广开来，整理以下文档，方便自己查阅，也方便同事快速上手。（对于异步编程十分实用的Future/Promise以及智能指针等，将不做整理介绍，组内使用的框架已经支持并广泛使用了，用的是自己公司参考boost实现的版本）</p><h3 id="1-nullptr"><a href="#1-nullptr" class="headerlink" title="1. nullptr"></a>1. nullptr</h3><p>nullptr 出现的目的是为了替代 NULL。</p><p>在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。</p><p>C++ 不允许直接将 void <em> 隐式转换到其他类型，但如果 NULL 被定义为 ((void</em>)0)，那么当编译char *ch = NULL;时，NULL 只好被定义为 0。</p><p>而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。</p><p>为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。</p><p>nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>当需要使用 NULL 时候，养成直接使用 nullptr的习惯。</p><a id="more"></a> <h3 id="2-类型推导"><a href="#2-类型推导" class="headerlink" title="2. 类型推导"></a>2. 类型推导</h3><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。</p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用，对 auto 的语义变更也就非常自然了。</p><p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)</span><br></pre></td></tr></table></figure></p><p>而有了 auto 之后可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator </span></span><br><span class="line"><span class="comment">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> itr = vec.cbegin(); itr != vec.cend(); ++itr);</span><br></pre></td></tr></table></figure></p><p>一些其他的常见用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;             <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">10</span>) <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure></p><p>注意：auto 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此外，auto 还不能用于推导数组类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">auto</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">auto</span> auto_arr = arr;</span><br><span class="line"> <span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = arr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：</p><p>decltype(表达式)</p><p>在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br>有时候，我们可能需要计算某个表达式的类型，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure></p><h4 id="拖尾返回类型、auto-与-decltype-配合"><a href="#拖尾返回类型、auto-与-decltype-配合" class="headerlink" title="拖尾返回类型、auto 与 decltype 配合"></a>拖尾返回类型、auto 与 decltype 配合</h4><p>你可能会思考，auto 能不能用于推导函数的返回类型。考虑这样一个例子加法函数的例子，在传统 C++ 中我们必须这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。</p><p>在 C++11 中这个问题得到解决。虽然你可能马上回反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y);</span><br></pre></td></tr></table></figure></p><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-区间迭代"><a href="#3-区间迭代" class="headerlink" title="3. 区间迭代"></a>3. 区间迭代</h3><p>基于范围的 for 循环<br>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句。<br>最常用的 std::vector 遍历将从原来的样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = arr.begin(); i != arr.end(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变得非常的简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp; 启用了引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-初始化列表"><a href="#4-初始化列表" class="headerlink" title="4. 初始化列表"></a>4. 初始化列表</h3><p>C++11 提供了统一的语法来初始化任意的对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    B(<span class="keyword">int</span> _a, <span class="keyword">float</span> _b): a(_a), b(_b) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a &#123;<span class="number">1</span>, <span class="number">1.1</span>&#125;;    <span class="comment">// 统一的初始化语法</span></span><br><span class="line">B b &#123;<span class="number">2</span>, <span class="number">2.2</span>&#125;;</span><br></pre></td></tr></table></figure><p>C++11 还把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Magic(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Magic magic = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="5-模板增强"><a href="#5-模板增强" class="headerlink" title="5. 模板增强"></a>5. 模板增强</h3><p>外部模板<br>传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。</p><p>C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;;            <span class="comment">// 强行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;  <span class="comment">// 不在该编译文件中实例化模板</span></span><br></pre></td></tr></table></figure></p><p>尖括号 “&gt;”<br>在传统 C++ 的编译器中，&gt;&gt;一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; wow;</span><br></pre></td></tr></table></figure></p><p>这在传统C++编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</p><p>类型别名模板<br>在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">int</span> value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuckType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a;</span><br><span class="line">    U b;</span><br><span class="line">    SuckType():a(value),b(value)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure></p><p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></p><p>默认模板参数<br>我们可能定义了一个加法函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但在使用时发现，要使用 add，就必须每次都指定其模板参数的类型。<br>在 C++11 中提供了一种便利，可以指定模板的默认参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6. 构造函数"></a>6. 构造函数</h3><h4 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h4><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h4><p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。<br>假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  B(<span class="keyword">int</span> i):A(i)&#123;&#125;</span><br><span class="line">  B(<span class="keyword">double</span> d,<span class="keyword">int</span> i):A(d,i)&#123;&#125;</span><br><span class="line">  B(folat f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c):A(f,i,e)&#123;&#125;</span><br><span class="line">  <span class="comment">//......等等好多个和基类构造函数对应的构造函数</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>C++11的继承构造：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">  A(<span class="keyword">double</span> d,<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  A(<span class="keyword">float</span> f,<span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">char</span>* c)&#123;&#125;</span><br><span class="line">  <span class="comment">//...等等系列的构造函数版本</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> A::A;</span><br><span class="line">  <span class="comment">//关于基类各构造函数的继承一句话搞定</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p><p>如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。</p><h3 id="7-Lambda-表达式"><a href="#7-Lambda-表达式" class="headerlink" title="7. Lambda 表达式"></a>7. Lambda 表达式</h3><p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。</p><p>Lambda 表达式的基本语法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ caputrue ] ( params ) opt -&gt; ret &#123; body; &#125;;</span><br></pre></td></tr></table></figure></p><p>1) capture是捕获列表；<br>2) params是参数表；(选填)<br>3) opt是函数选项；可以填mutable,exception,attribute（选填）<br>mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。<br>exception说明lambda表达式是否抛出异常以及何种异常。<br>attribute用来声明属性。<br>4) ret是返回值类型（拖尾返回类型）。(选填)<br>5) body是函数体。</p><p>捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p><p>1) []不捕获任何变量。<br>2) [&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。<br>3) [=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=] &#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"></span><br><span class="line">a+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//输出0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;a] &#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"></span><br><span class="line">a+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt;<span class="built_in">endl</span>;       <span class="comment">//输出1</span></span><br></pre></td></tr></table></figure></p><p>4) [=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。<br>5) [bar]按值捕获bar变量，同时不捕获其他变量。<br>6) [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> i_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">         <span class="keyword">auto</span> x1 = [] &#123; <span class="keyword">return</span> i_; &#125;;                   <span class="comment">//error,没有捕获外部变量</span></span><br><span class="line">         <span class="keyword">auto</span> x2 = [=] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;          <span class="comment">//OK</span></span><br><span class="line">         <span class="keyword">auto</span> x3 = [&amp;] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">//OK</span></span><br><span class="line">         <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_; &#125;;               <span class="comment">//OK</span></span><br><span class="line">         <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;       <span class="comment">//error,没有捕获x,y</span></span><br><span class="line">         <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123; <span class="keyword">return</span> i_ + x + y; &#125;;     <span class="comment">//OK</span></span><br><span class="line">         <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> i_++; &#125;;             <span class="comment">//OK</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span> , b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [] &#123; <span class="keyword">return</span> a; &#125;;                         <span class="comment">//error,没有捕获外部变量    </span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;] &#123; <span class="keyword">return</span> a++ &#125;;                      <span class="comment">//OK</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=] &#123; <span class="keyword">return</span> a; &#125;;                        <span class="comment">//OK</span></span><br><span class="line"><span class="keyword">auto</span> f4 = [=] &#123;<span class="keyword">return</span> a++; &#125;;                       <span class="comment">//error,a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="keyword">auto</span> f5 = [a] &#123; <span class="keyword">return</span> a+b; &#125;;                      <span class="comment">//error,没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b] &#123; <span class="keyword">return</span> a + (b++); &#125;;                <span class="comment">//OK</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b] &#123; <span class="keyword">return</span> a + (b++); &#125;;                <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></p><p>注意f4，虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p><p>原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123; <span class="keyword">return</span> a++; &#125;;                <span class="comment">//error</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;       <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></p><p>lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lambda表达式是不能被赋值的：</span><br><span class="line">```c++</span><br><span class="line">auto a = [] &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">auto b = [] &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">a = b;   // 非法，lambda无法赋值</span><br><span class="line">auto c = a;   // 合法，生成一个副本</span><br></pre></td></tr></table></figure></p><p>闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个lambda表达式去初始化另外一个lambda表达式而产生副本。</p><p>在多种捕获方式中，最好不要使用[=]和[&amp;]默认捕获所有变量。</p><p>默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的生命周期：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::function&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">add_x</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> x + a; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p><p>但是采用默认值捕获所有变量仍然有风险，看下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Filter(<span class="keyword">int</span> divisorVal):</span><br><span class="line">        divisor&#123;divisorVal&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::function&lt;<span class="title">bool</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">getFilter</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [=](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> divisor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上并没有。因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::function&lt;<span class="title">bool</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">getFilter</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [divisor](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原代码中，lambda表达式实际上捕捉的是<span class="keyword">this</span>指针的副本，所以原来的代码等价于：</span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="built_in">std</span>::function&lt;<span class="title">bool</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">getFilter</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> value % <span class="keyword">this</span>-&gt;divisor == <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，采用默认值捕捉所有变量仍然是不安全的，主要是由于指针变量的复制，实际上还是按引用传值。</p><p>lambda表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以STL定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; wrapper = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span><br></pre></td></tr></table></figure></p><p>lambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。</p><p>最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(v.beigin(), v.end(), [value](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x &gt; value; &#125;);</span><br></pre></td></tr></table></figure></p><p>再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用generate函数，并辅助lambda表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::generate(v.begin(), v.end(), [&amp;a, &amp;b] &#123; <span class="keyword">int</span> value = b; b = b + a; a = value; <span class="keyword">return</span> value; &#125;);</span><br><span class="line"><span class="comment">// 此时v &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;</span></span><br></pre></td></tr></table></figure></p><p>当需要遍历容器并对每个元素进行操作时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each(v.begin(), v.end(), [&amp;even_count](<span class="keyword">int</span> val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(val &amp; <span class="number">1</span>))&#123;</span><br><span class="line">        ++ even_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number of even is "</span> &lt;&lt; even_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。</p><h3 id="8-新增容器"><a href="#8-新增容器" class="headerlink" title="8. 新增容器"></a>8. 新增容器</h3><p>std::array<br>std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。</p><p>std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, len&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// 非法, 数组大小参数必须是常量表达式</span></span><br><span class="line"></span><br><span class="line">当我们开始用上了 <span class="built_in">std</span>::<span class="built_in">array</span> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>std::array<int 4> arr = {1,2,3,4};</int></p><p>// C 风格接口传参<br>// foo(arr, arr.size());           // 非法, 无法隐式转换<br>foo(&amp;arr[0], arr.size());<br>foo(arr.data(), arr.size());</p><p>// 使用 <code>std::sort</code><br>std::sort(arr.begin(), arr.end());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">std::forward_list</span><br><span class="line">std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。</span><br><span class="line">和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</span><br><span class="line"></span><br><span class="line">无序容器</span><br><span class="line">C++11 引入了两组无序容器：</span><br><span class="line">std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。</span><br><span class="line"></span><br><span class="line">无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。</span><br><span class="line"></span><br><span class="line">元组 std::tuple</span><br><span class="line">元组的使用有三个核心的函数：</span><br><span class="line"></span><br><span class="line">std::make_tuple: 构造元组</span><br><span class="line">std::get: 获得元组某个位置的值</span><br><span class="line">std::tie: 元组拆包</span><br><span class="line">```c++</span><br><span class="line">#include &lt;tuple&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">auto get_student(int id)</span><br><span class="line">&#123;</span><br><span class="line">    // 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span><br><span class="line">    if (id == 0)</span><br><span class="line">        return std::make_tuple(3.8, &apos;A&apos;, &quot;张三&quot;);</span><br><span class="line">    if (id == 1)</span><br><span class="line">        return std::make_tuple(2.9, &apos;C&apos;, &quot;李四&quot;);</span><br><span class="line">    if (id == 2)</span><br><span class="line">        return std::make_tuple(1.7, &apos;D&apos;, &quot;王五&quot;);</span><br><span class="line">    return std::make_tuple(0.0, &apos;D&apos;, &quot;null&quot;);   </span><br><span class="line">    // 如果只写 0 会出现推断错误, 编译失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    auto student = get_student(0);</span><br><span class="line">    std::cout &lt;&lt; &quot;ID: 0, &quot;</span><br><span class="line">    &lt;&lt; &quot;GPA: &quot; &lt;&lt; std::get&lt;0&gt;(student) &lt;&lt; &quot;, &quot;</span><br><span class="line">    &lt;&lt; &quot;成绩: &quot; &lt;&lt; std::get&lt;1&gt;(student) &lt;&lt; &quot;, &quot;</span><br><span class="line">    &lt;&lt; &quot;姓名: &quot; &lt;&lt; std::get&lt;2&gt;(student) &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">    double gpa;</span><br><span class="line">    char grade;</span><br><span class="line">    std::string name;</span><br><span class="line">    </span><br><span class="line">    // 元组进行拆包</span><br><span class="line">    std::tie(gpa, grade, name) = get_student(1);</span><br><span class="line">    std::cout &lt;&lt; &quot;ID: 1, &quot;</span><br><span class="line">    &lt;&lt; &quot;GPA: &quot; &lt;&lt; gpa &lt;&lt; &quot;, &quot;</span><br><span class="line">    &lt;&lt; &quot;成绩: &quot; &lt;&lt; grade &lt;&lt; &quot;, &quot;</span><br><span class="line">    &lt;&lt; &quot;姓名: &quot; &lt;&lt; name &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>合并两个元组，可以通过 std::tuple_cat 来实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span><br></pre></td></tr></table></figure></p><h3 id="9-正则表达式"><a href="#9-正则表达式" class="headerlink" title="9. 正则表达式"></a>9. 正则表达式</h3><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：<br>1) 检查一个串是否包含某种形式的子串；<br>2) 将匹配的子串替换；<br>3) 从某个串中取出符合条件的子串。</p><p>C++11 提供的正则表达式库操作 std::string 对象，对模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。</p><p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式：</p><p>[a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个及以上小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 转义后则表示匹配字符 . ，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的所要匹配的内容就是文件名为纯小写字母的文本文件。<br>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">"foo.txt"</span>, <span class="string">"bar.txt"</span>, <span class="string">"test"</span>, <span class="string">"a0.txt"</span>, <span class="string">"AAA.txt"</span>&#125;;</span><br><span class="line">    <span class="comment">// 在 C++ 中 `\` 会被作为字符串内的转义符，为使 `\.` 作为正则表达式传递进去生效，需要对 `\` 进行二次转义，从而有 `\\.`</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::regex <span class="title">txt_regex</span><span class="params">(<span class="string">"[a-z]+\\.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">base_regex</span><span class="params">(<span class="string">"([a-z]+)\\.txt"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::smatch base_match;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::regex_match(fname, base_match, base_regex)) &#123;</span><br><span class="line">        <span class="comment">// sub_match 的第一个元素匹配整个字符串</span></span><br><span class="line">        <span class="comment">// sub_match 的第二个元素匹配了第一个括号表达式</span></span><br><span class="line">        <span class="keyword">if</span> (base_match.size() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> base = base_match[<span class="number">1</span>].str();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sub-match[0]: "</span> &lt;&lt; base_match[<span class="number">0</span>].str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">" sub-match[1]: "</span> &lt;&lt; base &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上两个代码段的输出结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo.txt: <span class="number">1</span></span><br><span class="line">bar.txt: <span class="number">1</span></span><br><span class="line">test: <span class="number">0</span></span><br><span class="line">a0.txt: <span class="number">0</span></span><br><span class="line">AAA.txt: <span class="number">0</span></span><br><span class="line">sub-match[<span class="number">0</span>]: foo.txt</span><br><span class="line">foo.txt sub-match[<span class="number">1</span>]: foo</span><br><span class="line">sub-match[<span class="number">0</span>]: bar.txt</span><br><span class="line">bar.txt sub-match[<span class="number">1</span>]: bar</span><br></pre></td></tr></table></figure></p><h3 id="10语言级线程支持"><a href="#10语言级线程支持" class="headerlink" title="10语言级线程支持"></a>10语言级线程支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread</span><br><span class="line"><span class="built_in">std</span>::mutex/<span class="built_in">std</span>::unique_lock</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>/<span class="built_in">std</span>::packaged_task</span><br><span class="line"><span class="built_in">std</span>::condition_variable</span><br></pre></td></tr></table></figure><p>代码编译需要使用 -pthread 选项</p><h3 id="11-右值引用和move语义"><a href="#11-右值引用和move语义" class="headerlink" title="11. 右值引用和move语义"></a>11. 右值引用和move语义</h3><p>先看一个简单的例子直观感受下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">a</span><span class="params">(x)</span></span>;                                    <span class="comment">// line 1</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">b</span><span class="params">(x + y)</span></span>;                                    <span class="comment">// line 2</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">c</span><span class="params">(some_function_returning_a_string())</span></span>;       <span class="comment">// line 3</span></span><br></pre></td></tr></table></figure></p><p>如果使用以下拷贝构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; that)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(that.data) + <span class="number">1</span>;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="built_in">memcpy</span>(data, that.data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上3行中，只有第一行(line 1)的x深度拷贝是有必要的，因为我们可能会在后边用到x，x是一个左值(lvalues)。</p><p>第二行和第三行的参数则是右值，因为表达式产生的string对象是匿名对象，之后没有办法再使用了。</p><p>C++ 11引入了一种新的机制叫做“右值引用”，以便我们通过重载直接使用右值参数。我们所要做的就是写一个以右值引用为参数的构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; that)   <span class="comment">// string&amp;&amp; is an rvalue reference to a string</span></span><br><span class="line">&#123;</span><br><span class="line">data = that.data;</span><br><span class="line">that.data = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们没有深度拷贝堆内存中的数据，而是仅仅复制了指针，并把源对象的指针置空。事实上，我们“偷取”了属于源对象的内存数据。由于源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做“转移构造函数”（move constructor），他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。</p><p>有了右值引用，再来看看赋值操作符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">string</span> that)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::swap(data, that.data);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到我们是直接对参数that传值，所以that会像其他任何对象一样被初始化，那么确切的说，that是怎样被初始化的呢？对于C++ 98，答案是复制构造函数，但是对于C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择。</p><p>如果是a=b，这样就会调用复制构造函数来初始化that（因为b是左值），赋值操作符会与新创建的对象交换数据，深度拷贝。这就是copy and swap 惯用法的定义：构造一个副本，与副本交换数据，并让副本在作用域内自动销毁。这里也一样。</p><p>如果是a = x + y，这样就会调用转移构造函数来初始化that（因为x+y是右值），所以这里没有深度拷贝，只有高效的数据转移。相对于参数，that依然是一个独立的对象，但是他的构造函数是无用的（trivial），因此堆中的数据没有必要复制，而仅仅是转移。没有必要复制他，因为x+y是右值，再次，从右值指向的对象中转移是没有问题的。</p><p>总结一下：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。</p><p>下面我们进一步讨论右值引用和move语义。</p><p>C++98标准库中提供了一种唯一拥有性的智能指针std::auto_ptr，该类型在C++11中已被废弃，因为其“复制”行为是危险的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Shape&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Triangle)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Shape&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure></p><p>注意b是怎样使用a进行初始化的，它不复制triangle，而是把triangle的所有权从a传递给了b，也可以说成“a 被转移进了b”或者“triangle被从a转移到了b”。</p><p>auto_ptr 的复制构造函数可能看起来像这样（简化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&amp; source)   <span class="comment">// note the missing const</span></span><br><span class="line">&#123;</span><br><span class="line">p = source.p;</span><br><span class="line">source.p = <span class="number">0</span>;   <span class="comment">// now the source no longer owns the object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>auto_ptr 的危险之处在于看上去应该是复制，但实际上确是转移。调用被转移过的auto_ptr 的成员函数将会导致不可预知的后果。所以你必须非常谨慎的使用auto_ptr ，如果他被转移过。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Shape&gt; <span class="title">make_triangle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">auto_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> Triangle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Shape&gt; <span class="title">c</span><span class="params">(make_triangle())</span></span>;      <span class="comment">// move temporary into c</span></span><br><span class="line"><span class="keyword">double</span> area = make_triangle()-&gt;area();   <span class="comment">// perfectly safe</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Shape&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Triangle)</span></span>;    <span class="comment">// create triangle</span></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Shape&gt; <span class="title">b</span><span class="params">(a)</span></span>;               <span class="comment">// move a into b</span></span><br><span class="line"><span class="keyword">double</span> area = a-&gt;area();                <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure></p><p>显然，在持有auto_ptr 对象的a表达式和持有调用函数返回的auto_ptr值类型的make_triangle()表达式之间一定有一些潜在的区别，每调用一次后者就会创建一个新的auto_ptr对象。这里a 其实就是一个左值（lvalue）的例子，而make_triangle()就是右值（rvalue）的例子。</p><p>转移像a这样的左值是非常危险的，因为我们可能调用a的成员函数，这会导致不可预知的行为。另一方面，转移像make_triangle()这样的右值却是非常安全的，因为复制构造函数之后，我们不能再使用这个临时对象了，因为这个转移后的临时对象会在下一行之前销毁掉。</p><p>我们现在知道转移左值是十分危险的，但是转移右值却是很安全的。如果C++能从语言级别支持区分左值和右值参数，我就可以完全杜绝对左值转移，或者把转移左值在调用的时候暴露出来，以使我们不会不经意的转移左值。</p><p>C++ 11对这个问题的答案是右值引用。右值引用是针对右值的新的引用类型，语法是X&amp;&amp;。以前的老的引用类型X&amp; 现在被称作左值引用。</p><p>使用右值引用X&amp;&amp;作为参数的最有用的函数之一就是转移构造函数X::X(X&amp;&amp; source)，它的主要作用是把源对象的本地资源转移给当前对象。</p><p>C++ 11中，std::auto_ptr&lt; T &gt;已经被std::unique_ptr&lt; T &gt;所取代，后者就是利用的右值引用。</p><p>其转移构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; source)   <span class="comment">// note the rvalue reference</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr = source.ptr;</span><br><span class="line">    source.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个转移构造函数跟auto_ptr中复制构造函数做的事情一样，但是它却只能接受右值作为参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Shape&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Triangle)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Shape&gt; <span class="title">b</span><span class="params">(a)</span></span>;                 <span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Shape&gt; <span class="title">c</span><span class="params">(make_triangle())</span></span>;       <span class="comment">// okay</span></span><br></pre></td></tr></table></figure></p><p>第二行不能编译通过，因为a是左值，但是参数unique_ptr&amp;&amp; source只能接受右值，这正是我们所需要的，杜绝危险的隐式转移。第三行编译没有问题，因为make_triangle()是右值，转移构造函数会将临时对象的所有权转移给对象c，这正是我们需要的。</p><p>转移左值<br>有时候，我们可能想转移左值，也就是说，有时候我们想让编译器把左值当作右值对待，以便能使用转移构造函数，即便这有点不安全。出于这个目的，C++ 11在标准库的头文件&lt; utility &gt;中提供了一个模板函数std::move。实际上，std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。</p><p>以下是如何正确的转移左值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Shape&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Triangle)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Shape&gt; <span class="title">b</span><span class="params">(a)</span></span>;              <span class="comment">// still an error</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Shape&gt; <span class="title">c</span><span class="params">(<span class="built_in">std</span>::move(a))</span></span>;   <span class="comment">// okay</span></span><br></pre></td></tr></table></figure></p><p>请注意，第三行之后，a不再拥有Triangle对象。不过这没有关系，因为通过明确的写出std::move(a)，我们很清楚我们的意图：亲爱的转移构造函数，你可以对a做任何想要做的事情来初始化c；我不再需要a了，对于a，您请自便。</p><p>当然，如果你在使用了mova(a)之后，还继续使用a，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误。</p><p>总之，std::move(some_lvalue)将左值转换为右值（可以理解为一种类型转换），使接下来的转移成为可能。</p><p>一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Shape&gt; member;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Foo(<span class="built_in">unique_ptr</span>&lt;Shape&gt;&amp;&amp; parameter)</span><br><span class="line">    : member(parameter)   <span class="comment">// error</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的parameter，其类型是一个右值引用，只能说明parameter是指向右值的引用，而parameter本身是个左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）</p><p>因此以上对parameter的转移是不允许的，需要使用std::move来显示转换成右值。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;本篇转载自 &lt;a href=&quot;https://blog.csdn.net/jiange_zh/article/details/79356417&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++11常用新特性快速一览&lt;/a&gt; 一是方便将来检索，而是后续会按自己的思路重新整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近工作中，遇到一些问题，使用C++11实现起来会更加方便，而线上的生产环境还不支持C++11，于是决定新年开工后，在组内把C++11推广开来，整理以下文档，方便自己查阅，也方便同事快速上手。（对于异步编程十分实用的Future/Promise以及智能指针等，将不做整理介绍，组内使用的框架已经支持并广泛使用了，用的是自己公司参考boost实现的版本）&lt;/p&gt;
&lt;h3 id=&quot;1-nullptr&quot;&gt;&lt;a href=&quot;#1-nullptr&quot; class=&quot;headerlink&quot; title=&quot;1. nullptr&quot;&gt;&lt;/a&gt;1. nullptr&lt;/h3&gt;&lt;p&gt;nullptr 出现的目的是为了替代 NULL。&lt;/p&gt;
&lt;p&gt;在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。&lt;/p&gt;
&lt;p&gt;C++ 不允许直接将 void &lt;em&gt; 隐式转换到其他类型，但如果 NULL 被定义为 ((void&lt;/em&gt;)0)，那么当编译char *ch = NULL;时，NULL 只好被定义为 0。&lt;/p&gt;
&lt;p&gt;而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。&lt;/p&gt;
&lt;p&gt;nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。&lt;/p&gt;
&lt;p&gt;当需要使用 NULL 时候，养成直接使用 nullptr的习惯。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://worldnot.com/categories/C-C/"/>
    
    
      <category term="c++11" scheme="https://worldnot.com/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11 变量初始化</title>
    <link href="https://worldnot.com/2019/01/21/UE4-CPPListInitialization/"/>
    <id>https://worldnot.com/2019/01/21/UE4-CPPListInitialization/</id>
    <published>2019-01-21T14:10:07.000Z</published>
    <updated>2022-10-08T01:37:13.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导语<br>uniform initialization（标准初始化）<br>在c++11之前的版本，初始化是一个没有被统一的写法，有时候用小括号，有时候用大括号，有时候还用赋值号，在c++11中就统一了初始化的形式——“{ }”，直接在对象名后面跟大括号，并在大括号中写入需要初始化的值，并用逗号隔开。甚至类构造函数的初始化列表也可以用“{}”大括号。</p></blockquote><h3 id="1-就地初始化"><a href="#1-就地初始化" class="headerlink" title="1.就地初始化"></a>1.就地初始化</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p>在C++11之前，只能对结构体或类的静态常量成员就行就地初始化，其他的不行。如下代码所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">10</span>;<span class="comment">//yes</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;            <span class="comment">//no</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在C++11中，结构体或类的数据成员在申明时可以直接赋予一个默认值，初始化的方式有两种，一是使用等号“=”，二是使用大括号列表初始化的方式。注意，使用参考如下代码：</p><a id="more"></a> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>    </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">7</span>; <span class="comment">//C++11 only</span></span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">7</span>&#125;;   <span class="comment">//或int b=&#123;7&#125;; C++11 only</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">7</span>)</span></span>;<span class="comment">//error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：小括号初始化方式不能应用于就地初始化。</p><h4 id="1-2-就地初始化与初始化列表的先后顺序"><a href="#1-2-就地初始化与初始化列表的先后顺序" class="headerlink" title="1.2 就地初始化与初始化列表的先后顺序"></a>1.2 就地初始化与初始化列表的先后顺序</h4><p>C++11标准支持了就地初始化非静态数据成员的同时，初始化列表的方式也被保留下来，也就是说既可以使用就地初始化，也可以使用初始化列表来完成数据成员的初始化工作。当二者同时使用时，并不冲突，初始化列表发生在就地初始化之后，即最终的初始化结果以初始化列表为准。参考如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Mem(<span class="keyword">int</span> i,<span class="keyword">int</span> j):m1(i),m2(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m2 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Mem <span class="title">mem</span><span class="params">(<span class="number">11</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"m1="</span>&lt;&lt; mem.m1&lt;&lt;<span class="string">" m2="</span>&lt;&lt;mem.m2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序输出结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m1=<span class="number">11</span> m2=<span class="number">22</span></span><br></pre></td></tr></table></figure></p><p>2.初始化列表<br>C++11之前主要有以下几种初始化方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小括号初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等号初始化</span></span><br><span class="line"><span class="built_in">string</span> str=<span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//POD对象与POD数组列表初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Studnet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">Studnet s=&#123;<span class="string">"dablelv"</span>,<span class="number">18</span>&#125;; <span class="comment">//纯数据（Plain of Data,POD）类型对象</span></span><br><span class="line">Studnet sArr[]=&#123;&#123;<span class="string">"dablelv"</span>,<span class="number">18</span>&#125;,&#123;<span class="string">"tommy"</span>,<span class="number">19</span>&#125;&#125;;  <span class="comment">//POD数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的初始化列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Class():x(<span class="number">0</span>)&#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这么多的对象初始化方式，不仅增加了学习成本，也使得代码风格有较大出入，影响了代码的可读性和统一性。从C++11开始，对列表初始化（List Initialization）的功能进行了扩充，可以作用于任何类型对象的初始化，至此，列表初始化方式完成了天下大一统。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    Test(<span class="keyword">int</span> i, <span class="keyword">int</span> j);    </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line">Test t&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;                    <span class="comment">//C++11 only，相当于 Test t(0,0);    </span></span><br><span class="line">Test* pT=<span class="keyword">new</span> Test&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;         <span class="comment">//C++11 only，相当于 Test* pT=new Test&#123;1,2&#125;;</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;   <span class="comment">//C++11 only</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>  </span><br><span class="line"> 　　 <span class="keyword">int</span> a[<span class="number">4</span>];  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  　　X() : a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; &#123;&#125; <span class="comment">//C++11 only, 初始化数组成员  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此外，C++11列表初始化还可以应用于容器，终于可以摆脱 push_back() 调用了，C++11中可以直观地初始化容器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11 container initializer</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs=&#123;<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; singers =&#123;&#123;<span class="string">"Lady Gaga"</span>, <span class="string">"+1 (212) 555-7890"</span>&#125;,&#123;<span class="string">"Beyonce Knowles"</span>, <span class="string">"+1 (212) 555-0987"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导语&lt;br&gt;uniform initialization（标准初始化）&lt;br&gt;在c++11之前的版本，初始化是一个没有被统一的写法，有时候用小括号，有时候用大括号，有时候还用赋值号，在c++11中就统一了初始化的形式——“{ }”，直接在对象名后面跟大括号，并在大括号中写入需要初始化的值，并用逗号隔开。甚至类构造函数的初始化列表也可以用“{}”大括号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-就地初始化&quot;&gt;&lt;a href=&quot;#1-就地初始化&quot; class=&quot;headerlink&quot; title=&quot;1.就地初始化&quot;&gt;&lt;/a&gt;1.就地初始化&lt;/h3&gt;&lt;h4 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h4&gt;&lt;p&gt;在C++11之前，只能对结构体或类的静态常量成员就行就地初始化，其他的不行。如下代码所示：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;	&lt;span class=&quot;comment&quot;&gt;//yes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;	            &lt;span class=&quot;comment&quot;&gt;//no&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在C++11中，结构体或类的数据成员在申明时可以直接赋予一个默认值，初始化的方式有两种，一是使用等号“=”，二是使用大括号列表初始化的方式。注意，使用参考如下代码：&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://worldnot.com/categories/C-C/"/>
    
    
      <category term="初始化" scheme="https://worldnot.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
